/*! For license information please see 523.523.js.LICENSE.txt */
"use strict";(self.webpackChunksvelte_app=self.webpackChunksvelte_app||[]).push([[523],{523:(t,e,f)=>{f.d(e,{nobleCurves:()=>pe});var n=f(882);"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;const r=BigInt(0),i=BigInt(1);function o(t,e=""){if("boolean"!=typeof t)throw Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t);return t}function s(t,e,f=""){const r=(0,n.i)(t),i=t?.length,o=void 0!==e;if(!r||o&&i!==e)throw Error((f&&`"${f}" `)+"expected Uint8Array"+(o?" of length "+e:"")+", got "+(r?"length="+i:"type="+typeof t));return t}function c(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function a(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return""===t?r:BigInt("0x"+t)}function d(t){return a((0,n.b)(t))}function u(t){return(0,n.a)(t),a((0,n.b)(Uint8Array.from(t).reverse()))}function h(t,e){return(0,n.h)(t.toString(16).padStart(2*e,"0"))}function l(t,e){return h(t,e).reverse()}function b(t,e,f){let r;if("string"==typeof e)try{r=(0,n.h)(e)}catch(e){throw Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!(0,n.i)(e))throw Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const i=r.length;if("number"==typeof f&&i!==f)throw Error(t+" of length "+f+" expected, got "+i);return r}function g(t){return Uint8Array.from(t)}const p=t=>"bigint"==typeof t&&r<=t;function y(t,e,f,n){if(!function(t,e,f){return p(t)&&p(e)&&p(f)&&e<=t&&t<f}(e,f,n))throw Error("expected valid "+t+": "+f+" <= n < "+n+", got "+e)}function m(t){let e;for(e=0;t>r;t>>=i,e+=1);return e}const w=t=>(i<<BigInt(t))-i;function B(t,e,f={}){if(!t||"object"!=typeof t)throw Error("expected valid options object");function n(e,f,n){const r=t[e];if(n&&void 0===r)return;const i=typeof r;if(i!==f||null===r)throw Error(`param "${e}" is invalid: expected ${f}, got ${i}`)}Object.entries(e).forEach(([t,e])=>n(t,e,!1)),Object.entries(f).forEach(([t,e])=>n(t,e,!0))}function x(t){const e=new WeakMap;return(f,...n)=>{const r=e.get(f);if(void 0!==r)return r;const i=t(f,...n);return e.set(f,i),i}}const E=BigInt(0),v=BigInt(1),I=BigInt(2),O=BigInt(3),A=BigInt(4),S=BigInt(5),R=BigInt(7),F=BigInt(8),U=BigInt(9),k=BigInt(16);function L(t,e){const f=t%e;return f>=E?f:e+f}function C(t,e,f){let n=t;for(;e-- >E;)n*=n,n%=f;return n}function H(t,e){if(t===E)throw Error("invert: expected non-zero number");if(e<=E)throw Error("invert: expected positive modulus, got "+e);let f=L(t,e),n=e,r=E,i=v;for(;f!==E;){const t=n%f,e=r-i*(n/f);n=f,f=t,r=i,i=e}if(n!==v)throw Error("invert: does not exist");return L(r,e)}function N(t,e,f){if(!t.eql(t.sqr(e),f))throw Error("Cannot find square root")}function q(t,e){const f=(t.ORDER+v)/A,n=t.pow(e,f);return N(t,n,e),n}function Z(t,e){const f=(t.ORDER-S)/F,n=t.mul(e,I),r=t.pow(n,f),i=t.mul(e,r),o=t.mul(t.mul(i,I),r),s=t.mul(i,t.sub(o,t.ONE));return N(t,s,e),s}function V(t){if(t<O)throw Error("sqrt is not defined for small field");let e=t-v,f=0;for(;e%I===E;)e/=I,f++;let n=I;const r=j(t);for(;1===G(r,n);)if(n++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===f)return q;let i=r.pow(n,e);const o=(e+v)/I;return function(t,n){if(t.is0(n))return n;if(1!==G(t,n))throw Error("Cannot find square root");let r=f,s=t.mul(t.ONE,i),c=t.pow(n,e),a=t.pow(n,o);for(;!t.eql(c,t.ONE);){if(t.is0(c))return t.ZERO;let e=1,f=t.sqr(c);for(;!t.eql(f,t.ONE);)if(e++,f=t.sqr(f),e===r)throw Error("Cannot find square root");const n=v<<BigInt(r-e-1),i=t.pow(s,n);r=e,s=t.sqr(i),c=t.mul(c,s),a=t.mul(a,i)}return a}}const P=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function K(t,e,f=!1){const n=Array(e.length).fill(f?t.ZERO:void 0),r=e.reduce((e,f,r)=>t.is0(f)?e:(n[r]=e,t.mul(e,f)),t.ONE),i=t.inv(r);return e.reduceRight((e,f,r)=>t.is0(f)?e:(n[r]=t.mul(e,n[r]),t.mul(e,f)),i),n}function G(t,e){const f=(t.ORDER-v)/I,n=t.pow(e,f),r=t.eql(n,t.ONE),i=t.eql(n,t.ZERO),o=t.eql(n,t.neg(t.ONE));if(!r&&!i&&!o)throw Error("invalid Legendre symbol result");return r?1:i?0:-1}function T(t,e){void 0!==e&&(0,n.d)(e);const f=void 0!==e?e:t.toString(2).length;return{nBitLength:f,nByteLength:Math.ceil(f/8)}}function j(t,e,f=!1,n={}){if(t<=E)throw Error("invalid field: expected ORDER > 0, got "+t);let r,i,o,s=!1;if("object"==typeof e&&null!=e){if(n.sqrt||f)throw Error("cannot specify opts in two arguments");const t=e;t.BITS&&(r=t.BITS),t.sqrt&&(i=t.sqrt),"boolean"==typeof t.isLE&&(f=t.isLE),"boolean"==typeof t.modFromBytes&&(s=t.modFromBytes),o=t.allowedLengths}else"number"==typeof e&&(r=e),n.sqrt&&(i=n.sqrt);const{nBitLength:c,nByteLength:a}=T(t,r);if(a>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let b;const g=Object.freeze({ORDER:t,isLE:f,BITS:c,BYTES:a,MASK:w(c),ZERO:E,ONE:v,allowedLengths:o,create:e=>L(e,t),isValid:e=>{if("bigint"!=typeof e)throw Error("invalid field element: expected bigint, got "+typeof e);return E<=e&&e<t},is0:t=>t===E,isValidNot0:t=>!g.is0(t)&&g.isValid(t),isOdd:t=>(t&v)===v,neg:e=>L(-e,t),eql:(t,e)=>t===e,sqr:e=>L(e*e,t),add:(e,f)=>L(e+f,t),sub:(e,f)=>L(e-f,t),mul:(e,f)=>L(e*f,t),pow:(t,e)=>function(t,e,f){if(f<E)throw Error("invalid exponent, negatives unsupported");if(f===E)return t.ONE;if(f===v)return e;let n=t.ONE,r=e;for(;f>E;)f&v&&(n=t.mul(n,r)),r=t.sqr(r),f>>=v;return n}(g,t,e),div:(e,f)=>L(e*H(f,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>H(e,t),sqrt:i||(e=>(b||(b=function(t){return t%A===O?q:t%F===S?Z:t%k===U?function(t){const e=j(t),f=V(t),n=f(e,e.neg(e.ONE)),r=f(e,n),i=f(e,e.neg(n)),o=(t+R)/k;return(t,e)=>{let f=t.pow(e,o),s=t.mul(f,n);const c=t.mul(f,r),a=t.mul(f,i),d=t.eql(t.sqr(s),e),u=t.eql(t.sqr(c),e);f=t.cmov(f,s,d),s=t.cmov(a,c,u);const h=t.eql(t.sqr(s),e),l=t.cmov(f,s,h);return N(t,l,e),l}}(t):V(t)}(t)),b(g,e))),toBytes:t=>f?l(t,a):h(t,a),fromBytes:(e,n=!0)=>{if(o){if(!o.includes(e.length)||e.length>a)throw Error("Field.fromBytes: expected "+o+" bytes, got "+e.length);const t=new Uint8Array(a);t.set(e,f?0:t.length-e.length),e=t}if(e.length!==a)throw Error("Field.fromBytes: expected "+a+" bytes, got "+e.length);let r=f?u(e):d(e);if(s&&(r=L(r,t)),!n&&!g.isValid(r))throw Error("invalid field element: outside of range 0..ORDER");return r},invertBatch:t=>K(g,t),cmov:(t,e,f)=>f?e:t});return Object.freeze(g)}function D(t){if("bigint"!=typeof t)throw Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function _(t){const e=D(t);return e+Math.ceil(e/2)}class Y extends n.H{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,n.e)(t);const f=(0,n.t)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(f.length>r?t.create().update(f).digest():f);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),(0,n.f)(i)}update(t){return(0,n.g)(this),this.iHash.update(t),this}digestInto(t){(0,n.g)(this),(0,n.a)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:f,finished:n,destroyed:r,blockLen:i,outputLen:o}=this;return t.finished=n,t.destroyed=r,t.blockLen=i,t.outputLen=o,t.oHash=e._cloneInto(t.oHash),t.iHash=f._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const z=(t,e,f)=>new Y(t,e).update(f).digest();z.create=(t,e)=>new Y(t,e);const X=BigInt(0),M=BigInt(1);function $(t,e){const f=e.negate();return t?f:e}function W(t,e){const f=K(t.Fp,e.map(t=>t.Z));return e.map((e,n)=>t.fromAffine(e.toAffine(f[n])))}function J(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw Error("invalid window size, expected [1.."+e+"], got W="+t)}function Q(t,e){J(t,e);const f=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:w(t),maxNumber:f,shiftBy:BigInt(t)}}function tt(t,e,f){const{windowSize:n,mask:r,maxNumber:i,shiftBy:o}=f;let s=Number(t&r),c=t>>o;s>n&&(s-=i,c+=M);const a=e*n;return{nextN:c,offset:a+Math.abs(s)-1,isZero:0===s,isNeg:s<0,isNegF:e%2!=0,offsetF:a}}const et=new WeakMap,ft=new WeakMap;function nt(t){return ft.get(t)||1}function rt(t){if(t!==X)throw Error("invalid wNAF")}class it{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,f=this.ZERO){let n=t;for(;e>X;)e&M&&(f=f.add(n)),n=n.double(),e>>=M;return f}precomputeWindow(t,e){const{windows:f,windowSize:n}=Q(e,this.bits),r=[];let i=t,o=i;for(let t=0;t<f;t++){o=i,r.push(o);for(let t=1;t<n;t++)o=o.add(i),r.push(o);i=o.double()}return r}wNAF(t,e,f){if(!this.Fn.isValid(f))throw Error("invalid scalar");let n=this.ZERO,r=this.BASE;const i=Q(t,this.bits);for(let t=0;t<i.windows;t++){const{nextN:o,offset:s,isZero:c,isNeg:a,isNegF:d,offsetF:u}=tt(f,t,i);f=o,c?r=r.add($(d,e[u])):n=n.add($(a,e[s]))}return rt(f),{p:n,f:r}}wNAFUnsafe(t,e,f,n=this.ZERO){const r=Q(t,this.bits);for(let t=0;t<r.windows&&f!==X;t++){const{nextN:i,offset:o,isZero:s,isNeg:c}=tt(f,t,r);if(f=i,!s){const t=e[o];n=n.add(c?t.negate():t)}}return rt(f),n}getPrecomputes(t,e,f){let n=et.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&("function"==typeof f&&(n=f(n)),et.set(e,n))),n}cached(t,e,f){const n=nt(t);return this.wNAF(n,this.getPrecomputes(n,t,f),e)}unsafe(t,e,f,n){const r=nt(t);return 1===r?this._unsafeLadder(t,e,n):this.wNAFUnsafe(r,this.getPrecomputes(r,t,f),e,n)}createCache(t,e){J(e,this.bits),ft.set(t,e),et.delete(t)}hasCache(t){return 1!==nt(t)}}function ot(t,e,f,n){!function(t,e){if(!Array.isArray(t))throw Error("array expected");t.forEach((t,f)=>{if(!(t instanceof e))throw Error("invalid point at index "+f)})}(f,t),function(t,e){if(!Array.isArray(t))throw Error("array of scalars expected");t.forEach((t,f)=>{if(!e.isValid(t))throw Error("invalid scalar at index "+f)})}(n,e);const r=f.length,i=n.length;if(r!==i)throw Error("arrays of points and scalars must have equal length");const o=t.ZERO,s=m(BigInt(r));let c=1;s>12?c=s-3:s>4?c=s-2:s>0&&(c=2);const a=w(c),d=Array(Number(a)+1).fill(o);let u=o;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){d.fill(o);for(let e=0;e<i;e++){const r=n[e],i=Number(r>>BigInt(t)&a);d[i]=d[i].add(f[e])}let e=o;for(let t=d.length-1,f=o;t>0;t--)f=f.add(d[t]),e=e.add(f);if(u=u.add(e),0!==t)for(let t=0;t<c;t++)u=u.double()}return u}function st(t,e,f){if(e){if(e.ORDER!==t)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(t){B(t,P.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(e),e}return j(t,{isLE:f})}function ct(t,e,f={},n){if(void 0===n&&(n="edwards"===t),!e||"object"!=typeof e)throw Error(`expected valid ${t} CURVE object`);for(const t of["p","n","h"]){const f=e[t];if(!("bigint"==typeof f&&f>X))throw Error(`CURVE.${t} must be positive bigint`)}const r=st(e.p,f.Fp,n),i=st(e.n,f.Fn,n),o=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const t of o)if(!r.isValid(e[t]))throw Error(`CURVE.${t} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:r,Fn:i}}const at=(t,e)=>(t+(t>=0?e:-e)/gt)/e;function dt(t){if(!["compact","recovered","der"].includes(t))throw Error('Signature format must be "compact", "recovered", or "der"');return t}function ut(t,e){const f={};for(let n of Object.keys(e))f[n]=void 0===t[n]?e[n]:t[n];return o(f.lowS,"lowS"),o(f.prehash,"prehash"),void 0!==f.format&&dt(f.format),f}const ht={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,e)=>{const{Err:f}=ht;if(t<0||t>256)throw new f("tlv.encode: wrong tag");if(1&e.length)throw new f("tlv.encode: unpadded data");const n=e.length/2,r=c(n);if(r.length/2&128)throw new f("tlv.encode: long form length too big");const i=n>127?c(r.length/2|128):"";return c(t)+i+r+e},decode(t,e){const{Err:f}=ht;let n=0;if(t<0||t>256)throw new f("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new f("tlv.decode: wrong tlv");const r=e[n++];let i=0;if(128&r){const t=127&r;if(!t)throw new f("tlv.decode(long): indefinite length not supported");if(t>4)throw new f("tlv.decode(long): byte length is too big");const o=e.subarray(n,n+t);if(o.length!==t)throw new f("tlv.decode: length bytes not complete");if(0===o[0])throw new f("tlv.decode(long): zero leftmost byte");for(const t of o)i=i<<8|t;if(n+=t,i<128)throw new f("tlv.decode(long): not minimal encoding")}else i=r;const o=e.subarray(n,n+i);if(o.length!==i)throw new f("tlv.decode: wrong value length");return{v:o,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=ht;if(t<lt)throw new e("integer: negative integers are not allowed");let f=c(t);if(8&Number.parseInt(f[0],16)&&(f="00"+f),1&f.length)throw new e("unexpected DER parsing assertion: unpadded hex");return f},decode(t){const{Err:e}=ht;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return d(t)}},toSig(t){const{Err:e,_int:f,_tlv:n}=ht,r=b("signature",t),{v:i,l:o}=n.decode(48,r);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:s,l:c}=n.decode(2,i),{v:a,l:d}=n.decode(2,c);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:f.decode(s),s:f.decode(a)}},hexFromSig(t){const{_tlv:e,_int:f}=ht,n=e.encode(2,f.encode(t.r))+e.encode(2,f.encode(t.s));return e.encode(48,n)}},lt=BigInt(0),bt=BigInt(1),gt=BigInt(2),pt=BigInt(3),yt=BigInt(4);function mt(t,e){const{BYTES:f}=t;let n;if("bigint"==typeof e)n=e;else{let r=b("private key",e);try{n=t.fromBytes(r)}catch(t){throw Error(`invalid private key: expected ui8a of size ${f}, got ${typeof e}`)}}if(!t.isValidNot0(n))throw Error("invalid private key: out of range [1..N-1]");return n}function wt(t){return Uint8Array.of(t?2:3)}function Bt(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function xt(t,e={}){const{Fn:f}=t,r=e.randomBytes||n.r,i=Object.assign(Bt(t.Fp,f),{seed:_(f.ORDER)});function o(t){try{return!!mt(f,t)}catch(t){return!1}}function c(t=r(i.seed)){return function(t,e,f=!1){const n=t.length,r=D(e),i=_(e);if(n<16||n<i||n>1024)throw Error("expected "+i+"-1024 bytes of input, got "+n);const o=L(f?u(t):d(t),e-v)+v;return f?l(o,r):h(o,r)}(s(t,i.seed,"seed"),f.ORDER)}function a(e,n=!0){return t.BASE.multiply(mt(f,e)).toBytes(n)}function g(e){if("bigint"==typeof e)return!1;if(e instanceof t)return!0;const{secretKey:n,publicKey:r,publicKeyUncompressed:o}=i;if(f.allowedLengths||n===r)return;const s=b("key",e).length;return s===r||s===o}const p={isValidSecretKey:o,isValidPublicKey:function(e,f){const{publicKey:n,publicKeyUncompressed:r}=i;try{const i=e.length;return!(!0===f&&i!==n||!1===f&&i!==r||!t.fromBytes(e))}catch(t){return!1}},randomSecretKey:c,isValidPrivateKey:o,randomPrivateKey:c,normPrivateKeyToScalar:t=>mt(f,t),precompute:(e=8,f=t.BASE)=>f.precompute(e,!1)};return Object.freeze({getPublicKey:a,getSharedSecret:function(e,n,r=!0){if(!0===g(e))throw Error("first arg must be private key");if(!1===g(n))throw Error("second arg must be public key");const i=mt(f,e);return t.fromHex(n).multiply(i).toBytes(r)},keygen:function(t){const e=c(t);return{secretKey:e,publicKey:a(e)}},Point:t,utils:p,lengths:i})}function Et(t,e){const f=e=>function(t){const{CURVE:e,curveOpts:f,hash:r,ecdsaOpts:i}=function(t){const{CURVE:e,curveOpts:f}=function(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},f=t.Fp;let n=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(t=>Math.ceil(t/2)))):void 0;return{CURVE:e,curveOpts:{Fp:f,Fn:j(e.n,{BITS:t.nBitLength,allowedLengths:n,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}(t),n={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:f,hash:t.hash,ecdsaOpts:n}}(t);return function(t,e){const f=e.Point;return Object.assign({},e,{ProjectivePoint:f,CURVE:Object.assign({},t,T(f.Fn.ORDER,f.Fn.BITS))})}(t,function(t,e,f={}){(0,n.e)(e),B(f,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=f.randomBytes||n.r,i=f.hmac||((t,...f)=>z(e,t,(0,n.c)(...f))),{Fp:o,Fn:c}=t,{ORDER:a,BITS:u}=c,{keygen:h,getPublicKey:l,getSharedSecret:g,utils:p,lengths:m}=xt(t,f),x={prehash:!1,lowS:"boolean"==typeof f.lowS&&f.lowS,format:void 0,extraEntropy:!1},E="compact";function v(t){return t>a>>bt}function I(t,e){if(!c.isValidNot0(e))throw Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);return e}class O{constructor(t,e,f){this.r=I("r",t),this.s=I("s",e),null!=f&&(this.recovery=f),Object.freeze(this)}static fromBytes(t,e=E){let f;if(function(t,e){dt(e);const f=m.signature;s(t,"compact"===e?f:"recovered"===e?f+1:void 0,e+" signature")}(t,e),"der"===e){const{r:e,s:f}=ht.toSig(s(t));return new O(e,f)}"recovered"===e&&(f=t[0],e="compact",t=t.subarray(1));const n=c.BYTES,r=t.subarray(0,n),i=t.subarray(n,2*n);return new O(c.fromBytes(r),c.fromBytes(i),f)}static fromHex(t,e){return this.fromBytes((0,n.h)(t),e)}addRecoveryBit(t){return new O(this.r,this.s,t)}recoverPublicKey(e){const f=o.ORDER,{r,s:i,recovery:s}=this;if(null==s||![0,1,2,3].includes(s))throw Error("recovery id invalid");if(a*gt<f&&s>1)throw Error("recovery id is ambiguous for h>1 curve");const d=2===s||3===s?r+a:r;if(!o.isValid(d))throw Error("recovery id 2 or 3 invalid");const u=o.toBytes(d),h=t.fromBytes((0,n.c)(wt(!(1&s)),u)),l=c.inv(d),g=S(b("msgHash",e)),p=c.create(-g*l),y=c.create(i*l),m=t.BASE.multiplyUnsafe(p).add(h.multiplyUnsafe(y));if(m.is0())throw Error("point at infinify");return m.assertValidity(),m}hasHighS(){return v(this.s)}toBytes(t=E){if(dt(t),"der"===t)return(0,n.h)(ht.hexFromSig(this));const e=c.toBytes(this.r),f=c.toBytes(this.s);if("recovered"===t){if(null==this.recovery)throw Error("recovery bit must be present");return(0,n.c)(Uint8Array.of(this.recovery),e,f)}return(0,n.c)(e,f)}toHex(t){return(0,n.b)(this.toBytes(t))}assertValidity(){}static fromCompact(t){return O.fromBytes(b("sig",t),"compact")}static fromDER(t){return O.fromBytes(b("sig",t),"der")}normalizeS(){return this.hasHighS()?new O(this.r,c.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,n.b)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,n.b)(this.toBytes("compact"))}}const A=f.bits2int||function(t){if(t.length>8192)throw Error("input is too large");const e=d(t),f=8*t.length-u;return f>0?e>>BigInt(f):e},S=f.bits2int_modN||function(t){return c.create(A(t))},R=w(u);function F(t){return y("num < 2^"+u,t,lt,R),c.toBytes(t)}function U(t,f){return s(t,void 0,"message"),f?s(e(t),void 0,"prehashed message"):t}return Object.freeze({keygen:h,getPublicKey:l,getSharedSecret:g,utils:p,lengths:m,Point:t,sign:function(f,o,s={}){f=b("message",f);const{seed:a,k2sig:d}=function(e,f,i){if(["recovered","canonical"].some(t=>t in i))throw Error("sign() legacy options not supported");const{lowS:o,prehash:s,extraEntropy:a}=ut(i,x);e=U(e,s);const d=S(e),u=mt(c,f),h=[F(u),F(d)];if(null!=a&&!1!==a){const t=!0===a?r(m.secretKey):a;h.push(b("extraEntropy",t))}const l=(0,n.c)(...h),g=d;return{seed:l,k2sig:function(e){const f=A(e);if(!c.isValidNot0(f))return;const n=c.inv(f),r=t.BASE.multiply(f).toAffine(),i=c.create(r.x);if(i===lt)return;const s=c.create(n*c.create(g+i*u));if(s===lt)return;let a=(r.x===i?0:2)|Number(r.y&bt),d=s;return o&&v(s)&&(d=c.neg(s),a^=1),new O(i,d,a)}}}(f,o,s);return function(t,e,f){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof e||e<2)throw Error("qByteLen must be a number");if("function"!=typeof f)throw Error("hmacFn must be a function");const r=t=>new Uint8Array(t),i=t=>Uint8Array.of(t);let o=r(t),s=r(t),c=0;const a=()=>{o.fill(1),s.fill(0),c=0},d=(...t)=>f(s,o,...t),u=(t=r(0))=>{s=d(i(0),t),o=d(),0!==t.length&&(s=d(i(1),t),o=d())},h=()=>{if(c++>=1e3)throw Error("drbg: tried 1000 values");let t=0;const f=[];for(;t<e;){o=d();const e=o.slice();f.push(e),t+=o.length}return(0,n.c)(...f)};return(t,e)=>{let f;for(a(),u(t);!(f=e(h()));)u();return a(),f}}(e.outputLen,c.BYTES,i)(a,d)},verify:function(e,f,r,i={}){const{lowS:o,prehash:s,format:a}=ut(i,x);if(r=b("publicKey",r),f=U(b("message",f),s),"strict"in i)throw Error("options.strict was renamed to lowS");const d=void 0===a?function(t){let e;const f="string"==typeof t||(0,n.i)(t),r=!f&&null!==t&&"object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!f&&!r)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(r)e=new O(t.r,t.s);else if(f){try{e=O.fromBytes(b("sig",t),"der")}catch(t){if(!(t instanceof ht.Err))throw t}if(!e)try{e=O.fromBytes(b("sig",t),"compact")}catch(t){return!1}}return e||!1}(e):O.fromBytes(b("sig",e),a);if(!1===d)return!1;try{const e=t.fromBytes(r);if(o&&d.hasHighS())return!1;const{r:n,s:i}=d,s=S(f),a=c.inv(i),u=c.create(s*a),h=c.create(n*a),l=t.BASE.multiplyUnsafe(u).add(e.multiplyUnsafe(h));return!l.is0()&&c.create(l.x)===n}catch(e){return!1}},recoverPublicKey:function(t,e,f={}){const{prehash:n}=ut(f,x);return e=U(e,n),O.fromBytes(t,"recovered").recoverPublicKey(e).toBytes()},Signature:O,hash:e})}(function(t,e={}){const f=ct("weierstrass",t,e),{Fp:r,Fn:i}=f;let c=f.CURVE;const{h:a,n:d}=c;B(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:u}=e;if(u&&(!r.is0(c.a)||"bigint"!=typeof u.beta||!Array.isArray(u.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const h=Bt(r,i);function l(){if(!r.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const g=e.toBytes||function(t,e,f){const{x:i,y:s}=e.toAffine(),c=r.toBytes(i);if(o(f,"isCompressed"),f){l();const t=!r.isOdd(s);return(0,n.c)(wt(t),c)}return(0,n.c)(Uint8Array.of(4),c,r.toBytes(s))},p=e.fromBytes||function(t){s(t,void 0,"Point");const{publicKey:e,publicKeyUncompressed:f}=h,n=t.length,i=t[0],o=t.subarray(1);if(n!==e||2!==i&&3!==i){if(n===f&&4===i){const t=r.BYTES,e=r.fromBytes(o.subarray(0,t)),f=r.fromBytes(o.subarray(t,2*t));if(!E(e,f))throw Error("bad point: is not on curve");return{x:e,y:f}}throw Error(`bad point: got length ${n}, expected compressed=${e} or uncompressed=${f}`)}{const e=r.fromBytes(o);if(!r.isValid(e))throw Error("bad point: is not on curve, wrong x");const f=y(e);let n;try{n=r.sqrt(f)}catch(t){const e=t instanceof Error?": "+t.message:"";throw Error("bad point: is not on curve, sqrt error"+e)}return l(),!(1&~i)!==r.isOdd(n)&&(n=r.neg(n)),{x:e,y:n}}};function y(t){const e=r.sqr(t),f=r.mul(e,t);return r.add(r.add(f,r.mul(t,c.a)),c.b)}function E(t,e){const f=r.sqr(e),n=y(t);return r.eql(f,n)}if(!E(c.Gx,c.Gy))throw Error("bad curve params: generator point");const v=r.mul(r.pow(c.a,pt),yt),I=r.mul(r.sqr(c.b),BigInt(27));if(r.is0(r.add(v,I)))throw Error("bad curve params: a or b");function O(t,e,f=!1){if(!r.isValid(e)||f&&r.is0(e))throw Error("bad point coordinate "+t);return e}function A(t){if(!(t instanceof k))throw Error("ProjectivePoint expected")}function S(t){if(!u||!u.basises)throw Error("no endo");return function(t,e,f){const[[n,r],[i,o]]=e,s=at(o*t,f),c=at(-r*t,f);let a=t-s*n-c*i,d=-s*r-c*o;const u=a<lt,h=d<lt;u&&(a=-a),h&&(d=-d);const l=w(Math.ceil(m(f)/2))+bt;if(a<lt||a>=l||d<lt||d>=l)throw Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:u,k1:a,k2neg:h,k2:d}}(t,u.basises,i.ORDER)}const R=x((t,e)=>{const{X:f,Y:n,Z:i}=t;if(r.eql(i,r.ONE))return{x:f,y:n};const o=t.is0();null==e&&(e=o?r.ONE:r.inv(i));const s=r.mul(f,e),c=r.mul(n,e),a=r.mul(i,e);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(a,r.ONE))throw Error("invZ was invalid");return{x:s,y:c}}),F=x(t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.Y))return;throw Error("bad point: ZERO")}const{x:f,y:n}=t.toAffine();if(!r.isValid(f)||!r.isValid(n))throw Error("bad point: x or y not field elements");if(!E(f,n))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function U(t,e,f,n,i){return f=new k(r.mul(f.X,t),f.Y,f.Z),e=$(n,e),f=$(i,f),e.add(f)}class k{constructor(t,e,f){this.X=O("x",t),this.Y=O("y",e,!0),this.Z=O("z",f),Object.freeze(this)}static CURVE(){return c}static fromAffine(t){const{x:e,y:f}=t||{};if(!t||!r.isValid(e)||!r.isValid(f))throw Error("invalid affine point");if(t instanceof k)throw Error("projective point not allowed");return r.is0(e)&&r.is0(f)?k.ZERO:new k(e,f,r.ONE)}static fromBytes(t){const e=k.fromAffine(p(s(t,void 0,"point")));return e.assertValidity(),e}static fromHex(t){return k.fromBytes(b("pointHex",t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return C.createCache(this,t),e||this.multiply(pt),this}assertValidity(){F(this)}hasEvenY(){const{y:t}=this.toAffine();if(!r.isOdd)throw Error("Field doesn't support isOdd");return!r.isOdd(t)}equals(t){A(t);const{X:e,Y:f,Z:n}=this,{X:i,Y:o,Z:s}=t,c=r.eql(r.mul(e,s),r.mul(i,n)),a=r.eql(r.mul(f,s),r.mul(o,n));return c&&a}negate(){return new k(this.X,r.neg(this.Y),this.Z)}double(){const{a:t,b:e}=c,f=r.mul(e,pt),{X:n,Y:i,Z:o}=this;let s=r.ZERO,a=r.ZERO,d=r.ZERO,u=r.mul(n,n),h=r.mul(i,i),l=r.mul(o,o),b=r.mul(n,i);return b=r.add(b,b),d=r.mul(n,o),d=r.add(d,d),s=r.mul(t,d),a=r.mul(f,l),a=r.add(s,a),s=r.sub(h,a),a=r.add(h,a),a=r.mul(s,a),s=r.mul(b,s),d=r.mul(f,d),l=r.mul(t,l),b=r.sub(u,l),b=r.mul(t,b),b=r.add(b,d),d=r.add(u,u),u=r.add(d,u),u=r.add(u,l),u=r.mul(u,b),a=r.add(a,u),l=r.mul(i,o),l=r.add(l,l),u=r.mul(l,b),s=r.sub(s,u),d=r.mul(l,h),d=r.add(d,d),d=r.add(d,d),new k(s,a,d)}add(t){A(t);const{X:e,Y:f,Z:n}=this,{X:i,Y:o,Z:s}=t;let a=r.ZERO,d=r.ZERO,u=r.ZERO;const h=c.a,l=r.mul(c.b,pt);let b=r.mul(e,i),g=r.mul(f,o),p=r.mul(n,s),y=r.add(e,f),m=r.add(i,o);y=r.mul(y,m),m=r.add(b,g),y=r.sub(y,m),m=r.add(e,n);let w=r.add(i,s);return m=r.mul(m,w),w=r.add(b,p),m=r.sub(m,w),w=r.add(f,n),a=r.add(o,s),w=r.mul(w,a),a=r.add(g,p),w=r.sub(w,a),u=r.mul(h,m),a=r.mul(l,p),u=r.add(a,u),a=r.sub(g,u),u=r.add(g,u),d=r.mul(a,u),g=r.add(b,b),g=r.add(g,b),p=r.mul(h,p),m=r.mul(l,m),g=r.add(g,p),p=r.sub(b,p),p=r.mul(h,p),m=r.add(m,p),b=r.mul(g,m),d=r.add(d,b),b=r.mul(w,m),a=r.mul(y,a),a=r.sub(a,b),b=r.mul(y,g),u=r.mul(w,u),u=r.add(u,b),new k(a,d,u)}subtract(t){return this.add(t.negate())}is0(){return this.equals(k.ZERO)}multiply(t){const{endo:f}=e;if(!i.isValidNot0(t))throw Error("invalid scalar: out of range");let n,r;const o=t=>C.cached(this,t,t=>W(k,t));if(f){const{k1neg:e,k1:i,k2neg:s,k2:c}=S(t),{p:a,f:d}=o(i),{p:u,f:h}=o(c);r=d.add(h),n=U(f.beta,a,u,e,s)}else{const{p:e,f}=o(t);n=e,r=f}return W(k,[n,r])[0]}multiplyUnsafe(t){const{endo:f}=e,n=this;if(!i.isValid(t))throw Error("invalid scalar: out of range");if(t===lt||n.is0())return k.ZERO;if(t===bt)return n;if(C.hasCache(this))return this.multiply(t);if(f){const{k1neg:e,k1:r,k2neg:i,k2:o}=S(t),{p1:s,p2:c}=function(t,e,f,n){let r=e,i=t.ZERO,o=t.ZERO;for(;f>X||n>X;)f&M&&(i=i.add(r)),n&M&&(o=o.add(r)),r=r.double(),f>>=M,n>>=M;return{p1:i,p2:o}}(k,n,r,o);return U(f.beta,s,c,e,i)}return C.unsafe(n,t)}multiplyAndAddUnsafe(t,e,f){const n=this.multiplyUnsafe(e).add(t.multiplyUnsafe(f));return n.is0()?void 0:n}toAffine(t){return R(this,t)}isTorsionFree(){const{isTorsionFree:t}=e;return a===bt||(t?t(k,this):C.unsafe(this,d).is0())}clearCofactor(){const{clearCofactor:t}=e;return a===bt?this:t?t(k,this):this.multiplyUnsafe(a)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}toBytes(t=!0){return o(t,"isCompressed"),this.assertValidity(),g(k,this,t)}toHex(t=!0){return(0,n.b)(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(t=!0){return this.toBytes(t)}_setWindowSize(t){this.precompute(t)}static normalizeZ(t){return W(k,t)}static msm(t,e){return ot(k,i,t,e)}static fromPrivateKey(t){return k.BASE.multiply(mt(i,t))}}k.BASE=new k(c.Gx,c.Gy,r.ONE),k.ZERO=new k(r.ZERO,r.ONE,r.ZERO),k.Fp=r,k.Fn=i;const L=i.BITS,C=new it(k,e.endo?Math.ceil(L/2):L);return k.BASE.precompute(8),k}(e,f),r,i))}({...t,hash:e});return{...f(e),create:f}}const vt={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},It={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},Ot={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},At=j(vt.p),St=j(It.p),Rt=j(Ot.p),Ft=Et({...vt,Fp:At,lowS:!1},n.s),Ut=Et({...It,Fp:St,lowS:!1},n.j),kt=Et({...Ot,Fp:Rt,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},n.k),Lt=BigInt(0),Ct=BigInt(1),Ht=BigInt(2),Nt=BigInt(8);function qt(t,e={}){const f=ct("edwards",t,e,e.FpFnLE),{Fp:r,Fn:i}=f;let c=f.CURVE;const{h:a}=c;B(e,{},{uvRatio:"function"});const d=Ht<<BigInt(8*i.BYTES)-Ct,h=t=>r.create(t),l=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:r.sqrt(r.div(t,e))}}catch(t){return{isValid:!1,value:Lt}}});if(!function(t,e,f,n){const r=t.sqr(f),i=t.sqr(n),o=t.add(t.mul(e.a,r),i),s=t.add(t.ONE,t.mul(e.d,t.mul(r,i)));return t.eql(o,s)}(r,c,c.Gx,c.Gy))throw Error("bad curve params: generator point");function p(t,e,f=!1){return y("coordinate "+t,e,f?Ct:Lt,d),e}function m(t){if(!(t instanceof v))throw Error("ExtendedPoint expected")}const w=x((t,e)=>{const{X:f,Y:n,Z:i}=t,o=t.is0();null==e&&(e=o?Nt:r.inv(i));const s=h(f*e),c=h(n*e),a=r.mul(i,e);if(o)return{x:Lt,y:Ct};if(a!==Ct)throw Error("invZ was invalid");return{x:s,y:c}}),E=x(t=>{const{a:e,d:f}=c;if(t.is0())throw Error("bad point: ZERO");const{X:n,Y:r,Z:i,T:o}=t,s=h(n*n),a=h(r*r),d=h(i*i),u=h(d*d),l=h(s*e);if(h(d*h(l+a))!==h(u+h(f*h(s*a))))throw Error("bad point: equation left != right (1)");if(h(n*r)!==h(i*o))throw Error("bad point: equation left != right (2)");return!0});class v{constructor(t,e,f,n){this.X=p("x",t),this.Y=p("y",e),this.Z=p("z",f,!0),this.T=p("t",n),Object.freeze(this)}static CURVE(){return c}static fromAffine(t){if(t instanceof v)throw Error("extended point not allowed");const{x:e,y:f}=t||{};return p("x",e),p("y",f),new v(e,f,Ct,h(e*f))}static fromBytes(t,e=!1){const f=r.BYTES,{a:n,d:i}=c;t=g(s(t,f,"point")),o(e,"zip215");const a=g(t),b=t[f-1];a[f-1]=-129&b;const p=u(a),m=e?d:r.ORDER;y("point.y",p,Lt,m);const w=h(p*p),B=h(w-Ct),x=h(i*w-n);let{isValid:E,value:I}=l(B,x);if(!E)throw Error("bad point: invalid y coordinate");const O=(I&Ct)===Ct,A=!!(128&b);if(!e&&I===Lt&&A)throw Error("bad point: x=0 and x_0=1");return A!==O&&(I=h(-I)),v.fromAffine({x:I,y:p})}static fromHex(t,e=!1){return v.fromBytes(b("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return I.createCache(this,t),e||this.multiply(Ht),this}assertValidity(){E(this)}equals(t){m(t);const{X:e,Y:f,Z:n}=this,{X:r,Y:i,Z:o}=t,s=h(e*o),c=h(r*n),a=h(f*o),d=h(i*n);return s===c&&a===d}is0(){return this.equals(v.ZERO)}negate(){return new v(h(-this.X),this.Y,this.Z,h(-this.T))}double(){const{a:t}=c,{X:e,Y:f,Z:n}=this,r=h(e*e),i=h(f*f),o=h(Ht*h(n*n)),s=h(t*r),a=e+f,d=h(h(a*a)-r-i),u=s+i,l=u-o,b=s-i,g=h(d*l),p=h(u*b),y=h(d*b),m=h(l*u);return new v(g,p,m,y)}add(t){m(t);const{a:e,d:f}=c,{X:n,Y:r,Z:i,T:o}=this,{X:s,Y:a,Z:d,T:u}=t,l=h(n*s),b=h(r*a),g=h(o*f*u),p=h(i*d),y=h((n+r)*(s+a)-l-b),w=p-g,B=p+g,x=h(b-e*l),E=h(y*w),I=h(B*x),O=h(y*x),A=h(w*B);return new v(E,I,A,O)}subtract(t){return this.add(t.negate())}multiply(t){if(!i.isValidNot0(t))throw Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f}=I.cached(this,t,t=>W(v,t));return W(v,[e,f])[0]}multiplyUnsafe(t,e=v.ZERO){if(!i.isValid(t))throw Error("invalid scalar: expected 0 <= sc < curve.n");return t===Lt?v.ZERO:this.is0()||t===Ct?this:I.unsafe(this,t,t=>W(v,t),e)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return I.unsafe(this,c.n).is0()}toAffine(t){return w(this,t)}clearCofactor(){return a===Ct?this:this.multiplyUnsafe(a)}toBytes(){const{x:t,y:e}=this.toAffine(),f=r.toBytes(e);return f[f.length-1]|=t&Ct?128:0,f}toHex(){return(0,n.b)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return W(v,t)}static msm(t,e){return ot(v,i,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}v.BASE=new v(c.Gx,c.Gy,Ct,h(c.Gx*c.Gy)),v.ZERO=new v(Lt,Ct,Ct,Lt),v.Fp=r,v.Fn=i;const I=new it(v,i.BITS);return v.BASE.precompute(8),v}const Zt=BigInt(0),Vt=BigInt(1),Pt=BigInt(2),Kt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3"),h:BigInt(4),a:BigInt(1),d:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffff6756"),Gx:BigInt("0x4f1970c66bed0ded221d15a622bf36da9e146570470f1767ea6de324a3d3a46412ae1af72ab66511433b80e18b00938e2626a82bc70cc05e"),Gy:BigInt("0x693f46716eb6bc248876203756c9c7624bea73736ca3984087789c1e05a0c2d73ad3ff1ce67c39c4fdbd132c4ed7c8ad9808795bf230fa14")},Gt=Object.assign({},Kt,{d:BigInt("0xd78b4bdc7f0daf19f24f38c29373a2ccad46157242a50f37809b1da3412a12e79ccc9c81264cfe9ad080997058fb61c4243cc32dbaa156b9"),Gx:BigInt("0x79a70b2b70400553ae7c9df416c792c61128751ac92969240c25a07d728bdc93e21f7787ed6972249de732f38496cd11698713093e9c04fc"),Gy:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000001")}),Tt=(0,n.l)(()=>n.m.create({dkLen:114})),jt=BigInt(1),Dt=BigInt(2),_t=BigInt(3);BigInt(4);const Yt=BigInt(11),zt=BigInt(22),Xt=BigInt(44),Mt=BigInt(88),$t=BigInt(223);function Wt(t){const e=Kt.p,f=t*t*t%e,n=f*f*t%e,r=C(n,_t,e)*n%e,i=C(r,_t,e)*n%e,o=C(i,Dt,e)*f%e,s=C(o,Yt,e)*o%e,c=C(s,zt,e)*s%e,a=C(c,Xt,e)*c%e,d=C(a,Mt,e)*a%e,u=C(d,Xt,e)*c%e,h=C(u,Dt,e)*f%e,l=C(h,jt,e)*t%e;return C(l,$t,e)*h%e}function Jt(t){return t[0]&=252,t[55]|=128,t[56]=0,t}function Qt(t,e){const f=Kt.p,n=L(t*t*e,f),r=L(n*t,f),i=L(r*n*e,f),o=L(r*Wt(i),f),s=L(o*o,f);return{isValid:L(s*e,f)===t,value:o}}const te=(()=>j(Kt.p,{BITS:456,isLE:!0}))(),ee=(()=>j(Kt.n,{BITS:456,isLE:!0}))();function fe(t,e,f){if(e.length>255)throw Error("context must be smaller than 255, got: "+e.length);return(0,n.c)((r="SigEd448",Uint8Array.from(r,(t,e)=>{const f=t.charCodeAt(0);if(1!==t.length||f>127)throw Error(`string contains non-ASCII character "${r[e]}" with code ${f} at position ${e}`);return f})),new Uint8Array([f?1:0,e.length]),e,t);var r}const ne=function(t){const{CURVE:e,curveOpts:f,hash:r,eddsaOpts:i}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},f={Fp:t.Fp,Fn:j(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},n={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:f,hash:t.hash,eddsaOpts:n}}(t);return function(t,e){const f=e.Point;return Object.assign({},e,{ExtendedPoint:f,CURVE:t,nBitLength:f.Fn.BITS,nByteLength:f.Fn.BYTES})}(t,function(t,e,f={}){if("function"!=typeof e)throw Error('"hash" function param is required');B(f,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=f,{BASE:i,Fp:c,Fn:a}=t,d=f.randomBytes||n.r,h=f.adjustScalarBytes||(t=>t),l=f.domain||((t,e,f)=>{if(o(f,"phflag"),e.length||f)throw Error("Contexts/pre-hash are not supported");return t});function g(t){return a.create(u(t))}function p(t){const{head:f,prefix:n,scalar:r}=function(t){const f=E.secretKey;t=b("private key",t,f);const n=b("hashed private key",e(t),2*f),r=h(n.slice(0,f));return{head:r,prefix:n.slice(f,2*f),scalar:g(r)}}(t),o=i.multiply(r),s=o.toBytes();return{head:f,prefix:n,scalar:r,point:o,pointBytes:s}}function y(t){return p(t).pointBytes}function m(t=Uint8Array.of(),...f){const i=(0,n.c)(...f);return g(e(l(i,b("context",t),!!r)))}const w={zip215:!0},x=c.BYTES,E={secretKey:x,publicKey:x,signature:2*x,seed:x};function v(t=d(E.seed)){return s(t,E.seed,"seed")}const I={getExtendedPublicKey:p,randomSecretKey:v,isValidSecretKey:function(t){return(0,n.i)(t)&&t.length===a.BYTES},isValidPublicKey:function(e,f){try{return!!t.fromBytes(e,f)}catch(t){return!1}},toMontgomery(e){const{y:f}=t.fromBytes(e),n=E.publicKey,r=32===n;if(!r&&57!==n)throw Error("only defined for 25519 and 448");const i=r?c.div(Ct+f,Ct-f):c.div(f-Ct,f+Ct);return c.toBytes(i)},toMontgomeryPriv(t){const f=E.secretKey;s(t,f);const n=e(t.subarray(0,f));return h(n).subarray(0,f)},randomPrivateKey:v,precompute:(e=8,f=t.BASE)=>f.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=I.randomSecretKey(t);return{secretKey:e,publicKey:y(e)}},getPublicKey:y,sign:function(t,e,f={}){t=b("message",t),r&&(t=r(t));const{prefix:o,scalar:c,pointBytes:d}=p(e),u=m(f.context,o,t),h=i.multiply(u).toBytes(),l=m(f.context,h,d,t),g=a.create(u+l*c);if(!a.isValid(g))throw Error("sign failed: invalid s");return s((0,n.c)(h,a.toBytes(g)),E.signature,"result")},verify:function(e,f,n,s=w){const{context:c,zip215:a}=s,d=E.signature;e=b("signature",e,d),f=b("message",f),n=b("publicKey",n,E.publicKey),void 0!==a&&o(a,"zip215"),r&&(f=r(f));const h=d/2,l=e.subarray(0,h),g=u(e.subarray(h,d));let p,y,B;try{p=t.fromBytes(n,a),y=t.fromBytes(l,a),B=i.multiplyUnsafe(g)}catch(t){return!1}if(!a&&p.isSmallOrder())return!1;const x=m(c,y.toBytes(),p.toBytes(),f);return y.add(p.multiplyUnsafe(x)).subtract(B).clearCofactor().is0()},utils:I,Point:t,lengths:E})}(qt(e,f),r,i))}((()=>({...Kt,Fp:te,Fn:ee,nBitLength:ee.BITS,hash:Tt,adjustScalarBytes:Jt,domain:fe,uvRatio:Qt}))());qt(Gt);const re=(()=>{const t=Kt.p;return function(t){const e=(B(f=t,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...f}));var f;const{P:r,type:i,adjustScalarBytes:o,powPminus2:s,randomBytes:c}=e,a="x25519"===i;if(!a&&"x448"!==i)throw Error("invalid type");const d=c||n.r,h=a?255:448,g=a?32:56,p=a?BigInt(9):BigInt(5),m=a?BigInt(121665):BigInt(39081),w=a?Pt**BigInt(254):Pt**BigInt(447),x=a?BigInt(8)*Pt**BigInt(251)-Vt:BigInt(4)*Pt**BigInt(445)-Vt,E=w+x+Vt,v=t=>L(t,r),I=O(p);function O(t){return l(v(t),g)}function A(t,e){const f=function(t,e){y("u",t,Zt,r),y("scalar",e,w,E);const f=e,n=t;let i=Vt,o=Zt,c=t,a=Vt,d=Zt;for(let t=BigInt(h-1);t>=Zt;t--){const e=f>>t&Vt;d^=e,({x_2:i,x_3:c}=R(d,i,c)),({x_2:o,x_3:a}=R(d,o,a)),d=e;const r=i+o,s=v(r*r),u=i-o,h=v(u*u),l=s-h,b=c+a,g=v((c-a)*r),p=v(b*u),y=g+p,w=g-p;c=v(y*y),a=v(n*v(w*w)),i=v(s*h),o=v(l*(s+v(m*l)))}({x_2:i,x_3:c}=R(d,i,c)),({x_2:o,x_3:a}=R(d,o,a));const u=s(o);return v(i*u)}(function(t){const e=b("u coordinate",t,g);return a&&(e[31]&=127),v(u(e))}(e),function(t){return u(o(b("scalar",t,g)))}(t));if(f===Zt)throw Error("invalid private or public key received");return O(f)}function S(t){return A(t,I)}function R(t,e,f){const n=v(t*(e-f));return{x_2:e=v(e-n),x_3:f=v(f+n)}}const F={secretKey:g,publicKey:g,seed:g},U=(t=d(g))=>((0,n.a)(t,F.seed),t);return{keygen:function(t){const e=U(t);return{secretKey:e,publicKey:S(e)}},getSharedSecret:(t,e)=>A(t,e),getPublicKey:t=>S(t),scalarMult:A,scalarMultBase:S,utils:{randomSecretKey:U,randomPrivateKey:U},GuBytes:I.slice(),lengths:F}}({P:t,type:"x448",powPminus2:e=>L(C(Wt(e),Dt,t)*e,t),adjustScalarBytes:Jt})})(),ie={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},oe={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},se=BigInt(2),ce=j(ie.p,{sqrt:function(t){const e=ie.p,f=BigInt(3),n=BigInt(6),r=BigInt(11),i=BigInt(22),o=BigInt(23),s=BigInt(44),c=BigInt(88),a=t*t*t%e,d=a*a*t%e,u=C(d,f,e)*d%e,h=C(u,f,e)*d%e,l=C(h,se,e)*a%e,b=C(l,r,e)*l%e,g=C(b,i,e)*b%e,p=C(g,s,e)*g%e,y=C(p,c,e)*p%e,m=C(y,s,e)*g%e,w=C(m,f,e)*d%e,B=C(w,o,e)*b%e,x=C(B,n,e)*a%e,E=C(x,se,e);if(!ce.eql(ce.sqr(E),t))throw Error("Cannot find square root");return E}}),ae=Et({...ie,Fp:ce,lowS:!0,endo:oe},n.s),de=j(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),ue=Et({a:de.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:de,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},n.n),he=j(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),le=Et({a:he.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:he,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},n.o),be=j(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),ge=Et({a:be.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:be,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},n.p),pe=new Map(Object.entries({nistP256:Ft,nistP384:Ut,nistP521:kt,brainpoolP256r1:ue,brainpoolP384r1:le,brainpoolP512r1:ge,secp256k1:ae,x448:re,ed448:ne}))},882:(t,e,f)=>{f.d(e,{C:()=>C,H:()=>F,M:()=>H,a:()=>s,b:()=>m,c:()=>R,d:()=>o,e:()=>c,f:()=>u,g:()=>a,h:()=>A,i:()=>i,j:()=>yt,k:()=>pt,l:()=>U,m:()=>qt,n:()=>Zt,o:()=>Kt,p:()=>Pt,q:()=>N,r:()=>L,s:()=>bt,t:()=>S,u:()=>b,v:()=>Nt,w:()=>k,x:()=>Ht,y:()=>Vt});const n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},r="object"==typeof n&&"crypto"in n?n.crypto:void 0;function i(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function o(t){if(!Number.isSafeInteger(t)||t<0)throw Error("positive integer expected, got "+t)}function s(t,...e){if(!i(t))throw Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw Error("Uint8Array expected of length "+e+", got length="+t.length)}function c(t){if("function"!=typeof t||"function"!=typeof t.create)throw Error("Hash should be wrapped by utils.createHasher");o(t.outputLen),o(t.blockLen)}function a(t,e=!0){if(t.destroyed)throw Error("Hash instance has been destroyed");if(e&&t.finished)throw Error("Hash#digest() has already been called")}function d(t,e){s(t);const f=e.outputLen;if(t.length<f)throw Error("digestInto() expects output buffer of length at least "+f)}function u(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function h(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function l(t,e){return t<<32-e|t>>>e}function b(t,e){return t<<e|t>>>32-e>>>0}const g=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])()?t=>t:function(t){for(let f=0;f<t.length;f++)t[f]=(e=t[f])<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;var e;return t},p=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),y=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function m(t){if(s(t),p)return t.toHex();let e="";for(let f=0;f<t.length;f++)e+=y[t[f]];return e}const w=48,B=57,x=65,E=70,v=97,I=102;function O(t){return t>=w&&t<=B?t-w:t>=x&&t<=E?t-(x-10):t>=v&&t<=I?t-(v-10):void 0}function A(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);if(p)return Uint8Array.fromHex(t);const e=t.length,f=e/2;if(e%2)throw Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(f);for(let e=0,r=0;e<f;e++,r+=2){const f=O(t.charCodeAt(r)),i=O(t.charCodeAt(r+1));if(void 0===f||void 0===i){const e=t[r]+t[r+1];throw Error('hex string expected, got non-hex character "'+e+'" at index '+r)}n[e]=16*f+i}return n}function S(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),s(t),t}function R(...t){let e=0;for(let f=0;f<t.length;f++){const n=t[f];s(n),e+=n.length}const f=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const r=t[e];f.set(r,n),n+=r.length}return f}class F{}function U(t){const e=e=>t().update(S(e)).digest(),f=t();return e.outputLen=f.outputLen,e.blockLen=f.blockLen,e.create=()=>t(),e}const k=U;function L(t=32){if(r&&"function"==typeof r.getRandomValues)return r.getRandomValues(new Uint8Array(t));if(r&&"function"==typeof r.randomBytes)return Uint8Array.from(r.randomBytes(t));throw Error("crypto.getRandomValues must be defined")}function C(t,e,f){return t&e^~t&f}function H(t,e,f){return t&e^t&f^e&f}class N extends F{constructor(t,e,f,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=f,this.isLE=n,this.buffer=new Uint8Array(t),this.view=h(this.buffer)}update(t){a(this),s(t=S(t));const{view:e,buffer:f,blockLen:n}=this,r=t.length;for(let i=0;i<r;){const o=Math.min(n-this.pos,r-i);if(o!==n)f.set(t.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=h(t);for(;n<=r-i;i+=n)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){a(this),d(t,this),this.finished=!0;const{buffer:e,view:f,blockLen:n,isLE:r}=this;let{pos:i}=this;e[i++]=128,u(this.buffer.subarray(i)),this.padOffset>n-i&&(this.process(f,0),i=0);for(let t=i;t<n;t++)e[t]=0;!function(t,e,f,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,f,n);const r=BigInt(32),i=BigInt(4294967295),o=Number(f>>r&i),s=Number(f&i),c=n?4:0,a=n?0:4;t.setUint32(e+c,o,n),t.setUint32(e+a,s,n)}(f,n-8,BigInt(8*this.length),r),this.process(f,0);const o=h(t),s=this.outputLen;if(s%4)throw Error("_sha2: outputLen should be aligned to 32bit");const c=s/4,l=this.get();if(c>l.length)throw Error("_sha2: outputLen bigger than state");for(let t=0;t<c;t++)o.setUint32(4*t,l[t],r)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const f=t.slice(0,e);return this.destroy(),f}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:f,length:n,finished:r,destroyed:i,pos:o}=this;return t.destroyed=i,t.finished=r,t.length=n,t.pos=o,n%e&&t.buffer.set(f),t}clone(){return this._cloneInto()}}const q=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Z=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),V=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),P=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),K=BigInt(2**32-1),G=BigInt(32);function T(t,e=!1){return e?{h:Number(t&K),l:Number(t>>G&K)}:{h:0|Number(t>>G&K),l:0|Number(t&K)}}function j(t,e=!1){const f=t.length;let n=new Uint32Array(f),r=new Uint32Array(f);for(let i=0;i<f;i++){const{h:f,l:o}=T(t[i],e);[n[i],r[i]]=[f,o]}return[n,r]}const D=(t,e,f)=>t>>>f,_=(t,e,f)=>t<<32-f|e>>>f,Y=(t,e,f)=>t>>>f|e<<32-f,z=(t,e,f)=>t<<32-f|e>>>f,X=(t,e,f)=>t<<64-f|e>>>f-32,M=(t,e,f)=>t>>>f-32|e<<64-f;function $(t,e,f,n){const r=(e>>>0)+(n>>>0);return{h:t+f+(r/2**32|0)|0,l:0|r}}const W=(t,e,f)=>(t>>>0)+(e>>>0)+(f>>>0),J=(t,e,f,n)=>e+f+n+(t/2**32|0)|0,Q=(t,e,f,n)=>(t>>>0)+(e>>>0)+(f>>>0)+(n>>>0),tt=(t,e,f,n,r)=>e+f+n+r+(t/2**32|0)|0,et=(t,e,f,n,r)=>(t>>>0)+(e>>>0)+(f>>>0)+(n>>>0)+(r>>>0),ft=(t,e,f,n,r,i)=>e+f+n+r+i+(t/2**32|0)|0,nt=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rt=new Uint32Array(64);class it extends N{constructor(t=32){super(64,t,8,!1),this.A=0|q[0],this.B=0|q[1],this.C=0|q[2],this.D=0|q[3],this.E=0|q[4],this.F=0|q[5],this.G=0|q[6],this.H=0|q[7]}get(){const{A:t,B:e,C:f,D:n,E:r,F:i,G:o,H:s}=this;return[t,e,f,n,r,i,o,s]}set(t,e,f,n,r,i,o,s){this.A=0|t,this.B=0|e,this.C=0|f,this.D=0|n,this.E=0|r,this.F=0|i,this.G=0|o,this.H=0|s}process(t,e){for(let f=0;f<16;f++,e+=4)rt[f]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=rt[t-15],f=rt[t-2],n=l(e,7)^l(e,18)^e>>>3,r=l(f,17)^l(f,19)^f>>>10;rt[t]=r+rt[t-7]+n+rt[t-16]|0}let{A:f,B:n,C:r,D:i,E:o,F:s,G:c,H:a}=this;for(let t=0;t<64;t++){const e=a+(l(o,6)^l(o,11)^l(o,25))+C(o,s,c)+nt[t]+rt[t]|0,d=(l(f,2)^l(f,13)^l(f,22))+H(f,n,r)|0;a=c,c=s,s=o,o=i+e|0,i=r,r=n,n=f,f=e+d|0}f=f+this.A|0,n=n+this.B|0,r=r+this.C|0,i=i+this.D|0,o=o+this.E|0,s=s+this.F|0,c=c+this.G|0,a=a+this.H|0,this.set(f,n,r,i,o,s,c,a)}roundClean(){u(rt)}destroy(){this.set(0,0,0,0,0,0,0,0),u(this.buffer)}}class ot extends it{constructor(){super(28),this.A=0|Z[0],this.B=0|Z[1],this.C=0|Z[2],this.D=0|Z[3],this.E=0|Z[4],this.F=0|Z[5],this.G=0|Z[6],this.H=0|Z[7]}}const st=(()=>j(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),ct=(()=>st[0])(),at=(()=>st[1])(),dt=new Uint32Array(80),ut=new Uint32Array(80);class ht extends N{constructor(t=64){super(128,t,16,!1),this.Ah=0|P[0],this.Al=0|P[1],this.Bh=0|P[2],this.Bl=0|P[3],this.Ch=0|P[4],this.Cl=0|P[5],this.Dh=0|P[6],this.Dl=0|P[7],this.Eh=0|P[8],this.El=0|P[9],this.Fh=0|P[10],this.Fl=0|P[11],this.Gh=0|P[12],this.Gl=0|P[13],this.Hh=0|P[14],this.Hl=0|P[15]}get(){const{Ah:t,Al:e,Bh:f,Bl:n,Ch:r,Cl:i,Dh:o,Dl:s,Eh:c,El:a,Fh:d,Fl:u,Gh:h,Gl:l,Hh:b,Hl:g}=this;return[t,e,f,n,r,i,o,s,c,a,d,u,h,l,b,g]}set(t,e,f,n,r,i,o,s,c,a,d,u,h,l,b,g){this.Ah=0|t,this.Al=0|e,this.Bh=0|f,this.Bl=0|n,this.Ch=0|r,this.Cl=0|i,this.Dh=0|o,this.Dl=0|s,this.Eh=0|c,this.El=0|a,this.Fh=0|d,this.Fl=0|u,this.Gh=0|h,this.Gl=0|l,this.Hh=0|b,this.Hl=0|g}process(t,e){for(let f=0;f<16;f++,e+=4)dt[f]=t.getUint32(e),ut[f]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|dt[t-15],f=0|ut[t-15],n=Y(e,f,1)^Y(e,f,8)^D(e,0,7),r=z(e,f,1)^z(e,f,8)^_(e,f,7),i=0|dt[t-2],o=0|ut[t-2],s=Y(i,o,19)^X(i,o,61)^D(i,0,6),c=z(i,o,19)^M(i,o,61)^_(i,o,6),a=Q(r,c,ut[t-7],ut[t-16]),d=tt(a,n,s,dt[t-7],dt[t-16]);dt[t]=0|d,ut[t]=0|a}let{Ah:f,Al:n,Bh:r,Bl:i,Ch:o,Cl:s,Dh:c,Dl:a,Eh:d,El:u,Fh:h,Fl:l,Gh:b,Gl:g,Hh:p,Hl:y}=this;for(let t=0;t<80;t++){const e=Y(d,u,14)^Y(d,u,18)^X(d,u,41),m=z(d,u,14)^z(d,u,18)^M(d,u,41),w=d&h^~d&b,B=et(y,m,u&l^~u&g,at[t],ut[t]),x=ft(B,p,e,w,ct[t],dt[t]),E=0|B,v=Y(f,n,28)^X(f,n,34)^X(f,n,39),I=z(f,n,28)^M(f,n,34)^M(f,n,39),O=f&r^f&o^r&o,A=n&i^n&s^i&s;p=0|b,y=0|g,b=0|h,g=0|l,h=0|d,l=0|u,({h:d,l:u}=$(0|c,0|a,0|x,0|E)),c=0|o,a=0|s,o=0|r,s=0|i,r=0|f,i=0|n;const S=W(E,I,A);f=J(S,x,v,O),n=0|S}({h:f,l:n}=$(0|this.Ah,0|this.Al,0|f,0|n)),({h:r,l:i}=$(0|this.Bh,0|this.Bl,0|r,0|i)),({h:o,l:s}=$(0|this.Ch,0|this.Cl,0|o,0|s)),({h:c,l:a}=$(0|this.Dh,0|this.Dl,0|c,0|a)),({h:d,l:u}=$(0|this.Eh,0|this.El,0|d,0|u)),({h,l}=$(0|this.Fh,0|this.Fl,0|h,0|l)),({h:b,l:g}=$(0|this.Gh,0|this.Gl,0|b,0|g)),({h:p,l:y}=$(0|this.Hh,0|this.Hl,0|p,0|y)),this.set(f,n,r,i,o,s,c,a,d,u,h,l,b,g,p,y)}roundClean(){u(dt,ut)}destroy(){u(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class lt extends ht{constructor(){super(48),this.Ah=0|V[0],this.Al=0|V[1],this.Bh=0|V[2],this.Bl=0|V[3],this.Ch=0|V[4],this.Cl=0|V[5],this.Dh=0|V[6],this.Dl=0|V[7],this.Eh=0|V[8],this.El=0|V[9],this.Fh=0|V[10],this.Fl=0|V[11],this.Gh=0|V[12],this.Gl=0|V[13],this.Hh=0|V[14],this.Hl=0|V[15]}}const bt=U(()=>new it),gt=U(()=>new ot),pt=U(()=>new ht),yt=U(()=>new lt),mt=BigInt(0),wt=BigInt(1),Bt=BigInt(2),xt=BigInt(7),Et=BigInt(256),vt=BigInt(113),It=[],Ot=[],At=[];for(let t=0,e=wt,f=1,n=0;t<24;t++){[f,n]=[n,(2*f+3*n)%5],It.push(2*(5*n+f)),Ot.push((t+1)*(t+2)/2%64);let r=mt;for(let t=0;t<7;t++)e=(e<<wt^(e>>xt)*vt)%Et,e&Bt&&(r^=wt<<(wt<<BigInt(t))-wt);At.push(r)}const St=j(At,!0),Rt=St[0],Ft=St[1],Ut=(t,e,f)=>f>32?((t,e,f)=>e<<f-32|t>>>64-f)(t,e,f):((t,e,f)=>t<<f|e>>>32-f)(t,e,f),kt=(t,e,f)=>f>32?((t,e,f)=>t<<f-32|e>>>64-f)(t,e,f):((t,e,f)=>e<<f|t>>>32-f)(t,e,f);class Lt extends F{constructor(t,e,f,n=!1,r=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=f,this.enableXOF=n,this.rounds=r,o(f),!(0<t&&t<200))throw Error("only keccak-f1600 function is supported");var i;this.state=new Uint8Array(200),this.state32=(i=this.state,new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)))}clone(){return this._cloneInto()}keccak(){g(this.state32),function(t,e=24){const f=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)f[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const n=(e+8)%10,r=(e+2)%10,i=f[r],o=f[r+1],s=Ut(i,o,1)^f[n],c=kt(i,o,1)^f[n+1];for(let f=0;f<50;f+=10)t[e+f]^=s,t[e+f+1]^=c}let e=t[2],r=t[3];for(let f=0;f<24;f++){const n=Ot[f],i=Ut(e,r,n),o=kt(e,r,n),s=It[f];e=t[s],r=t[s+1],t[s]=i,t[s+1]=o}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)f[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~f[(n+2)%10]&f[(n+4)%10]}t[0]^=Rt[n],t[1]^=Ft[n]}u(f)}(this.state32,this.rounds),g(this.state32),this.posOut=0,this.pos=0}update(t){a(this),s(t=S(t));const{blockLen:e,state:f}=this,n=t.length;for(let r=0;r<n;){const i=Math.min(e-this.pos,n-r);for(let e=0;e<i;e++)f[this.pos++]^=t[r++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:f,blockLen:n}=this;t[f]^=e,128&e&&f===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){a(this,!1),s(t),this.finish();const e=this.state,{blockLen:f}=this;for(let n=0,r=t.length;n<r;){this.posOut>=f&&this.keccak();const i=Math.min(f-this.posOut,r-n);t.set(e.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return t}xofInto(t){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return o(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(d(t,this),this.finished)throw Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,u(this.state)}_cloneInto(t){const{blockLen:e,suffix:f,outputLen:n,rounds:r,enableXOF:i}=this;return t||(t=new Lt(e,f,n,i,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=f,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Ct=(t,e,f)=>U(()=>new Lt(e,t,f)),Ht=(()=>Ct(6,136,32))(),Nt=(()=>Ct(6,72,64))(),qt=(()=>function(t){const e=(e,f)=>t(f).update(S(e)).digest(),f=t({});return e.outputLen=f.outputLen,e.blockLen=f.blockLen,e.create=e=>t(e),e}((t={})=>new Lt(136,31,void 0===t.dkLen?32:t.dkLen,!0)))(),Zt=bt,Vt=gt,Pt=pt,Kt=yt}}]);
/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var e,t,r={84:(e,t,r)=>{"use strict";e.exports=r.p+"build/encodedecode_bg.wasm"},508:e=>{function t(e){var r,n,i="";if("string"==typeof e||"number"==typeof e)i+=e;else if("object"==typeof e)if(Array.isArray(e)){var s=e.length;for(r=0;r<s;r++)e[r]&&(n=t(e[r]))&&(i&&(i+=" "),i+=n)}else for(n in e)e[n]&&(i&&(i+=" "),i+=n);return i}function r(){for(var e,r,n=0,i="",s=arguments.length;n<s;n++)(e=arguments[n])&&(r=t(e))&&(i&&(i+=" "),i+=r);return i}e.exports=r,e.exports.clsx=r}},n={};function i(e){var t=n[e];if(void 0!==t)return t.exports;var s=n[e]={exports:{}};return r[e](s,s.exports,i),s.exports}i.m=r,i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce((t,r)=>(i.f[r](e,t),t),[])),i.u=e=>e+"."+e+".js",i.miniCssF=e=>{},i.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e={},t="svelte-app:",i.l=(r,n,s,a)=>{if(e[r])e[r].push(n);else{var o,c;if(void 0!==s)for(var u=document.getElementsByTagName("script"),l=0;l<u.length;l++){var h=u[l];if(h.getAttribute("src")==r||h.getAttribute("data-webpack")==t+s){o=h;break}}o||(c=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,i.nc&&o.setAttribute("nonce",i.nc),o.setAttribute("data-webpack",t+s),o.src=r),e[r]=[n];var y=(t,n)=>{o.onerror=o.onload=null,clearTimeout(p);var i=e[r];if(delete e[r],o.parentNode&&o.parentNode.removeChild(o),i&&i.forEach(e=>e(n)),t)return t(n)},p=setTimeout(y.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=y.bind(null,o.onerror),o.onload=y.bind(null,o.onload),c&&document.head.appendChild(o)}},i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;i.g.importScripts&&(e=i.g.location+"");var t=i.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var n=r.length-1;n>-1&&(!e||!/^http(s?):/.test(e));)e=r[n--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),i.p=e+"../"})(),(()=>{i.b=document.baseURI||self.location.href;var e={572:0};i.f.j=(t,r)=>{var n=i.o(e,t)?e[t]:void 0;if(0!==n)if(n)r.push(n[2]);else{var s=new Promise((r,i)=>n=e[t]=[r,i]);r.push(n[2]=s);var a=i.p+i.u(t),o=new Error;i.l(a,r=>{if(i.o(e,t)&&(0!==(n=e[t])&&(e[t]=void 0),n)){var s=r&&("load"===r.type?"missing":r.type),a=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+s+": "+a+")",o.name="ChunkLoadError",o.type=s,o.request=a,n[1](o)}},"chunk-"+t,t)}};var t=(t,r)=>{var n,s,[a,o,c]=r,u=0;if(a.some(t=>0!==e[t])){for(n in o)i.o(o,n)&&(i.m[n]=o[n]);c&&c(i)}for(t&&t(r);u<a.length;u++)s=a[u],i.o(e,s)&&e[s]&&e[s][0](),e[s]=0},r=self.webpackChunksvelte_app=self.webpackChunksvelte_app||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})(),(()=>{"use strict";"undefined"!=typeof window&&((window.__svelte??={}).v??=new Set).add("5");const e={},t=Symbol(),r=Symbol("filename"),n=(Symbol("hmr"),globalThis.process?.env?.NODE_ENV),s=n&&!n.toLowerCase().startsWith("prod");var a=Array.isArray,o=Array.prototype.indexOf,c=Array.from,u=Object.keys,l=Object.defineProperty,h=Object.getOwnPropertyDescriptor,y=Object.getOwnPropertyDescriptors,p=Object.prototype,d=Array.prototype,f=Object.getPrototypeOf,g=Object.isExtensible;function w(e){for(var t=0;t<e.length;t++)e[t]()}const m=256,b=1024,v=2048,k=4096,A=8192,S=16384,E=32768,K=65536,P=1<<17,U=1<<19,D=1<<21,x=1<<22,_=1<<23,C=Symbol("$state"),I=Symbol("legacy props"),T=Symbol(""),B=Symbol("proxy path"),$=new class extends Error{name="StaleReactionError";message="The reaction that called `getAbortSignal()` was re-run or destroyed"};function L(){if(s){const e=new Error("bind_invalid_checkbox_value\nUsing `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/bind_invalid_checkbox_value")}var N="font-weight: bold",M="font-weight: normal";function R(e){s?console.warn(`%c[svelte] hydration_mismatch\n%c${e?`Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${e}`:"Hydration failed because the initial UI does not match what was rendered on the server"}\nhttps://svelte.dev/e/hydration_mismatch`,N,M):console.warn("https://svelte.dev/e/hydration_mismatch")}function F(e){s?console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${e}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`,N,M):console.warn("https://svelte.dev/e/state_proxy_equality_mismatch")}let O,z=!1;function j(e){z=e}function H(t){if(null===t)throw R(),e;return O=t}function G(){return H(yt(O))}function q(t){if(z){if(null!==yt(O))throw R(),e;O=t}}function W(e=1){if(z){for(var t=e,r=O;t--;)r=yt(r);O=r}}function V(e){return e===this.v}function X(e){return!function(e,t){return e!=e?t==t:e!==t||null!==e&&"object"==typeof e||"function"==typeof e}(e,this.v)}function Q(e){let t=Error();const r=t.stack;if(!r)return null;const n=r.split("\n"),i=["\n"];for(let e=0;e<n.length;e++){const t=n[e];if("Error"!==t){if(t.includes("validate_each_keys"))return null;t.includes("svelte/src/internal")||i.push(t)}}return 1===i.length?null:(l(t,"stack",{value:i.join("\n")}),l(t,"name",{value:`${e}Error`}),t)}function Y(e,t){return e.label=t,Z(e.v,t),e}function Z(e,t){return e?.[B]?.(t),e}let J=null;function ee(e){J=e}let te=null;function re(e){te=e}let ne=null;function ie(e){ne=e}function se(e,t=!1,r){J={p:J,c:null,e:null,s:e,x:null,l:null},s&&(J.function=r,ne=r)}function ae(e){var t=J,r=t.e;if(null!==r)for(var n of(t.e=null,r))St(n);return void 0!==e&&(t.x=e),J=t.p,s&&(ne=J?.function??null),e??{}}const oe=new WeakMap;function ce(e,t){for(;null!==t;){if(128&t.f)try{return void t.b.error(e)}catch(t){e=t}t=t.parent}throw e instanceof Error&&ue(e),e}function ue(e){const t=oe.get(e);t&&(l(e,"message",{value:t.message}),l(e,"stack",{value:t.stack}))}const le="undefined"==typeof requestIdleCallback?e=>setTimeout(e,1):requestIdleCallback;let he=[],ye=[];function pe(){var e=he;he=[],w(e)}function de(){var e=ye;ye=[],w(e)}function fe(){return he.length>0||ye.length>0}function ge(){he.length>0&&pe(),ye.length>0&&de()}let we=null;function me(e){we=e}const be=new Set;function ve(e){var r=2050,n=null!==Ft&&2&Ft.f?Ft:null;null===jt||null!==n&&0!==(n.f&m)?r|=m:jt.f|=U;const i={ctx:J,deps:null,effects:null,equals:V,f:r,fn:e,reactions:null,rv:0,v:t,wv:0,parent:n??jt,ac:null};return i}function ke(e){var t=e.effects;if(null!==t){e.effects=null;for(var r=0;r<t.length;r+=1)xt(t[r])}}let Ae=[];function Se(e){var t,r=jt;if(Ht(function(e){for(var t=e.parent;null!==t;){if(!(2&t.f))return t;t=t.parent}return null}(e)),s){let n=ze;He(new Set);try{Ae.includes(e)&&function(){if(s){const e=new Error("derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/derived_references_self")}(),Ae.push(e),ke(e),t=nr(e)}finally{Ht(r),He(n),Ae.pop()}}else try{ke(e),t=nr(e)}finally{Ht(r)}return t}function Ee(e){var t=Se(e);e.equals(t)||(e.v=t,e.wv=er()),Mt||(null!==xe?xe.set(e,e.v):hr(e,!Jt&&0===(e.f&m)||null===e.deps?b:k))}function Ke(){Ht(null),zt(null),ee(null),s&&me(null)}const Pe=new Set;let Ue=null,De=null,xe=null,_e=new Set,Ce=[],Ie=null,Te=!1,Be=!1;class $e{current=new Map;#e=new Map;#t=new Set;#r=0;#n=null;#i=!1;#s=[];#a=[];#o=[];#c=[];#u=[];#l=[];#h=[];skipped_effects=new Set;process(e){Ce=[],De=null;var t=null;for(const t of e)this.#y(t);if(0===this.#s.length&&0===this.#r){this.#p();var r=this.#o,n=this.#c;this.#o=[],this.#c=[],this.#u=[],De=Ue,Ue=null,Fe(r),Fe(n),null===Ue?Ue=this:Pe.delete(this),this.#n?.resolve()}else this.#d(this.#o),this.#d(this.#c),this.#d(this.#u);if(t){for(const[e,{v:r,wv:n}]of t)e.wv<=n&&(e.v=r);xe=null}for(const e of this.#s)ar(e);for(const e of this.#a)ar(e);this.#s=[],this.#a=[]}#y(e){e.f^=b;for(var t=e.first;null!==t;){var r=t.f,n=!!(96&r);if(!(n&&0!==(r&b)||0!==(r&A)||this.skipped_effects.has(t))&&null!==t.fn){n?t.f^=b:4&r?this.#c.push(t):0===(r&b)&&(0!==(r&x)?(t.b?.is_pending()?this.#a:this.#s).push(t):tr(t)&&(!!(16&t.f)&&this.#u.push(t),ar(t)));var i=t.first;if(null!==i){t=i;continue}}var s=t.parent;for(t=t.next;null===t&&null!==s;)t=s.next,s=s.parent}}#d(e){for(const t of e)(0!==(t.f&v)?this.#l:this.#h).push(t),hr(t,b);e.length=0}capture(e,t){this.#e.has(e)||this.#e.set(e,t),this.current.set(e,e.v)}activate(){Ue=this}deactivate(){Ue=null,De=null;for(const e of _e)if(_e.delete(e),e(),null!==Ue)break}neuter(){this.#i=!0}flush(){Ce.length>0?Ne():this.#p(),Ue===this&&(0===this.#r&&Pe.delete(this),this.deactivate())}#p(){if(!this.#i)for(const e of this.#t)e();this.#t.clear()}increment(){this.#r+=1}decrement(){if(this.#r-=1,0===this.#r){for(const e of this.#l)hr(e,v),Oe(e);for(const e of this.#h)hr(e,k),Oe(e);this.#o=[],this.#c=[],this.flush()}else this.deactivate()}add_callback(e){this.#t.add(e)}settled(){return(this.#n??={promise:new Promise((r,n)=>{e=r,t=n}),resolve:e,reject:t}).promise;var e,t}static ensure(){if(null===Ue){const e=Ue=new $e;Pe.add(Ue),Be||$e.enqueue(()=>{Ue===e&&e.flush()})}return Ue}static enqueue(e){!function(e){if(0===he.length&&!Be){var t=he;queueMicrotask(()=>{t===he&&pe()})}he.push(e)}(e)}}function Le(e){var t=Be;Be=!0;try{var r;for(e&&(Ne(),r=e());;){if(ge(),0===Ce.length&&!fe()&&(Ue?.flush(),0===Ce.length))return Ie=null,r;Ne()}}finally{Be=t}}function Ne(){var e=Lt;Te=!0;try{var t=0;for(Nt(!0);Ce.length>0;){var r=$e.ensure();if(t++>1e3){if(s){var n=new Map;for(const e of r.current.keys())for(const[t,r]of e.updated??[]){var i=n.get(t);i||(i={error:r.error,count:0},n.set(t,i)),i.count+=r.count}for(const e of n.values())console.error(e.error)}Me()}r.process(Ce),je.clear()}}finally{Te=!1,Nt(e),Ie=null}}function Me(){try{!function(){if(s){const e=new Error("effect_update_depth_exceeded\nMaximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state\nhttps://svelte.dev/e/effect_update_depth_exceeded");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/effect_update_depth_exceeded")}()}catch(e){s&&l(e,"stack",{value:""}),ce(e,Ie)}}let Re=null;function Fe(e){var t=e.length;if(0!==t){for(var r=0;r<t;){var n=e[r++];if(!(24576&n.f)&&tr(n)&&(Re=[],ar(n),null===n.deps&&null===n.first&&null===n.nodes_start&&(null===n.teardown&&null===n.ac?_t(n):n.fn=null),Re?.length>0)){je.clear();for(const e of Re)ar(e);Re=[]}}Re=null}}function Oe(e){for(var t=Ie=e;null!==t.parent;){var r=(t=t.parent).f;if(Te&&t===jt&&16&r)return;if(96&r){if(0===(r&b))return;t.f^=b}}Ce.push(t)}let ze=new Set;const je=new Map;function He(e){ze=e}let Ge=!1;function qe(e,t){var r={f:0,v:e,reactions:null,equals:V,rv:0,wv:0};return r}function We(e,t){const r=qe(e);var n;return n=r,null!==Ft&&(null===Gt?Gt=[n]:Gt.push(n)),r}function Ve(e,t,r=!1){null!==Ft&&(!Ot||0!==(Ft.f&P))&&4325394&Ft.f&&!Gt?.includes(e)&&function(){if(s){const e=new Error("state_unsafe_mutation\nUpdating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\nhttps://svelte.dev/e/state_unsafe_mutation");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/state_unsafe_mutation")}();let n=r?et(t):t;return s&&Z(n,e.label),Xe(e,n)}function Xe(e,t){if(!e.equals(t)){var r=e.v;if(Mt?je.set(e,t):je.set(e,r),e.v=t,$e.ensure().capture(e,r),s){if(null!==jt){const t=Q("UpdatedAt");if(null!==t){e.updated??=new Map;let r=e.updated.get(t.stack);r||(r={error:t,count:0},e.updated.set(t.stack,r)),r.count++}}null!==jt&&(e.set_during_effect=!0)}2&e.f&&(0!==(e.f&v)&&Se(e),hr(e,0===(e.f&m)?b:k)),e.wv=er(),Ze(e,v),null===jt||0===(jt.f&b)||96&jt.f||(null===Vt?function(e){Vt=e}([e]):Vt.push(e)),s&&ze.size>0&&!Ge&&Qe()}return t}function Qe(){Ge=!1;const e=Array.from(ze);for(const t of e)0!==(t.f&b)&&hr(t,k),tr(t)&&ar(t);ze.clear()}function Ye(e){Ve(e,e.v+1)}function Ze(e,t){var r=e.reactions;if(null!==r)for(var n=r.length,i=0;i<n;i++){var a=r[i],o=a.f;if(s&&0!==(o&P))ze.add(a);else{var c=0===(o&v);c&&hr(a,t),2&o?Ze(a,k):c&&(!!(16&o)&&null!==Re&&Re.push(a),Oe(a))}}}const Je=/^[a-zA-Z_$][a-zA-Z_$0-9]*$/;function et(e){if("object"!=typeof e||null===e||C in e)return e;const r=f(e);if(r!==p&&r!==d)return e;var n=new Map,i=a(e),o=We(0),c=Yt,u=e=>{if(Yt===c)return e();var t=Ft,r=Yt;zt(null),Zt(c);var n=e();return zt(t),Zt(r),n};i&&(n.set("length",We(e.length)),s&&(e=new Proxy(e,{get(e,t,r){var n=Reflect.get(e,t,r);return it.has(t)?function(...e){Ge=!0;var t=n.apply(this,e);return Qe(),t}:n}})));var l="";let y=!1;function g(e){if(!y){y=!0,Y(o,`${l=e} version`);for(const[e,t]of n)Y(t,tt(l,e));y=!1}}return new Proxy(e,{defineProperty(e,t,r){"value"in r&&!1!==r.configurable&&!1!==r.enumerable&&!1!==r.writable||function(){if(s){const e=new Error("state_descriptors_fixed\nProperty descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\nhttps://svelte.dev/e/state_descriptors_fixed");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/state_descriptors_fixed")}();var i=n.get(t);return void 0===i?i=u(()=>{var e=We(r.value);return n.set(t,e),s&&"string"==typeof t&&Y(e,tt(l,t)),e}):Ve(i,r.value,!0),!0},deleteProperty(e,r){var i=n.get(r);if(void 0===i){if(r in e){const e=u(()=>We(t));n.set(r,e),Ye(o),s&&Y(e,tt(l,r))}}else Ve(i,t),Ye(o);return!0},get(r,i,a){if(i===C)return e;if(s&&i===B)return g;var o=n.get(i),c=i in r;if(void 0!==o||c&&!h(r,i)?.writable||(o=u(()=>{var e=We(et(c?r[i]:t));return s&&Y(e,tt(l,i)),e}),n.set(i,o)),void 0!==o){var y=or(o);return y===t?void 0:y}return Reflect.get(r,i,a)},getOwnPropertyDescriptor(e,r){var i=Reflect.getOwnPropertyDescriptor(e,r);if(i&&"value"in i){var s=n.get(r);s&&(i.value=or(s))}else if(void 0===i){var a=n.get(r),o=a?.v;if(void 0!==a&&o!==t)return{enumerable:!0,configurable:!0,value:o,writable:!0}}return i},has(e,r){if(r===C)return!0;var i=n.get(r),a=void 0!==i&&i.v!==t||Reflect.has(e,r);return!((void 0!==i||null!==jt&&(!a||h(e,r)?.writable))&&(void 0===i&&(i=u(()=>{var n=We(a?et(e[r]):t);return s&&Y(n,tt(l,r)),n}),n.set(r,i)),or(i)===t))&&a},set(e,r,a,c){var y=n.get(r),p=r in e;if(i&&"length"===r)for(var d=a;d<y.v;d+=1){var f=n.get(d+"");void 0!==f?Ve(f,t):d in e&&(f=u(()=>We(t)),n.set(d+"",f),s&&Y(f,tt(l,d)))}void 0===y?p&&!h(e,r)?.writable||(y=u(()=>We(void 0)),s&&Y(y,tt(l,r)),Ve(y,et(a)),n.set(r,y)):(p=y.v!==t,Ve(y,u(()=>et(a))));var g=Reflect.getOwnPropertyDescriptor(e,r);if(g?.set&&g.set.call(c,a),!p){if(i&&"string"==typeof r){var w=n.get("length"),m=Number(r);Number.isInteger(m)&&m>=w.v&&Ve(w,m+1)}Ye(o)}return!0},ownKeys(e){or(o);var r=Reflect.ownKeys(e).filter(e=>{var r=n.get(e);return void 0===r||r.v!==t});for(var[i,s]of n)s.v===t||i in e||r.push(i);return r},setPrototypeOf(){!function(){if(s){const e=new Error("state_prototype_fixed\nCannot set prototype of `$state` object\nhttps://svelte.dev/e/state_prototype_fixed");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/state_prototype_fixed")}()}})}function tt(e,t){return"symbol"==typeof t?`${e}[Symbol(${t.description??""})]`:Je.test(t)?`${e}.${t}`:/^\d+$/.test(t)?`${e}[${t}]`:`${e}['${t}']`}function rt(e){try{if(null!==e&&"object"==typeof e&&C in e)return e[C]}catch{}return e}function nt(e,t){return Object.is(rt(e),rt(t))}const it=new Set(["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"]);var st,at,ot,ct;function ut(){if(void 0===st){st=window,document,at=/Firefox/.test(navigator.userAgent);var e=Element.prototype,t=Node.prototype,r=Text.prototype;ot=h(t,"firstChild").get,ct=h(t,"nextSibling").get,g(e)&&(e.__click=void 0,e.__className=void 0,e.__attributes=null,e.__style=void 0,e.__e=void 0),g(r)&&(r.__t=void 0),s&&(e.__svelte_meta=null,function(){const e=Array.prototype,t=Array.__svelte_cleanup;t&&t();const{indexOf:r,lastIndexOf:n,includes:i}=e;e.indexOf=function(e,t){const n=r.call(this,e,t);if(-1===n)for(let r=t??0;r<this.length;r+=1)if(rt(this[r])===e){F("array.indexOf(...)");break}return n},e.lastIndexOf=function(e,t){const r=n.call(this,e,t??this.length-1);if(-1===r)for(let r=0;r<=(t??this.length-1);r+=1)if(rt(this[r])===e){F("array.lastIndexOf(...)");break}return r},e.includes=function(e,t){const r=i.call(this,e,t);if(!r)for(let t=0;t<this.length;t+=1)if(rt(this[t])===e){F("array.includes(...)");break}return r},Array.__svelte_cleanup=()=>{e.indexOf=r,e.lastIndexOf=n,e.includes=i}}())}}function lt(e=""){return document.createTextNode(e)}function ht(e){return ot.call(e)}function yt(e){return ct.call(e)}function pt(e,t){if(!z)return ht(e);var r=ht(O);if(null===r)r=O.appendChild(lt());else if(t&&3!==r.nodeType){var n=lt();return r?.before(n),H(n),n}return H(r),r}function dt(e,t){if(!z){var r=ht(e);return r instanceof Comment&&""===r.data?yt(r):r}if(t&&3!==O?.nodeType){var n=lt();return O?.before(n),H(n),n}return O}function ft(e,t=1,r=!1){let n=z?O:e;for(var i;t--;)i=n,n=yt(n);if(!z)return n;if(r&&3!==n?.nodeType){var s=lt();return null===n?i?.after(s):n.before(s),H(s),s}return H(n),n}function gt(e){e.textContent=""}function wt(e){z&&null!==ht(e)&&gt(e)}let mt=!1;function bt(){mt||(mt=!0,document.addEventListener("reset",e=>{Promise.resolve().then(()=>{if(!e.defaultPrevented)for(const t of e.target.elements)t.__on_r?.()})},{capture:!0}))}function vt(e){var t=Ft,r=jt;zt(null),Ht(null);try{return e()}finally{zt(t),Ht(r)}}function kt(e,t,r,n=r){e.addEventListener(t,()=>vt(r));const i=e.__on_r;e.__on_r=i?()=>{i(),n(!0)}:()=>n(!0),bt()}function At(e,t,r,n=!0){var i=jt;if(s)for(;null!==i&&0!==(i.f&P);)i=i.parent;null!==i&&0!==(i.f&A)&&(e|=A);var a={ctx:J,deps:null,nodes_start:null,nodes_end:null,f:e|v,first:null,fn:t,last:null,next:null,parent:i,b:i&&i.b,prev:null,teardown:null,transitions:null,wv:0,ac:null};if(s&&(a.component_function=ne),r)try{ar(a),a.f|=E}catch(o){throw xt(a),o}else null!==t&&Oe(a);if(n){var o=a;if(r&&null===o.deps&&null===o.teardown&&null===o.nodes_start&&o.first===o.last&&0===(o.f&U)&&(o=o.first),null!==o&&(o.parent=i,null!==i&&function(e,t){var r=t.last;null===r?t.last=t.first=e:(r.next=e,e.prev=r,t.last=e)}(o,i),null!==Ft&&2&Ft.f&&!(64&e))){var c=Ft;(c.effects??=[]).push(o)}}return a}function St(e){return At(1048580,e,!1)}function Et(e,t=0){return At(8|t,e,!0)}function Kt(e,r=[],n=[]){!function(e,r,n){const i=ve;if(0!==r.length){var a=Ue,o=jt,c=function(){var e=jt,t=Ft,r=J,n=Ue;return function(){Ht(e),zt(t),ee(r),n?.activate(),s&&me(null)}}(),u=function(){const e=jt.b;return null===e&&function(){if(s){const e=new Error("await_outside_boundary\nCannot await outside a `<svelte:boundary>` with a `pending` snippet\nhttps://svelte.dev/e/await_outside_boundary");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/await_outside_boundary")}(),e}();Promise.all(r.map(e=>function(e,r){let n=jt;null===n&&function(){if(s){const e=new Error("async_derived_orphan\nCannot create a `$derived(...)` with an `await` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/async_derived_orphan")}();var i=n.b,a=void 0,o=qe(t),c=null,u=!Ft;return function(e){At(4718592,e,!0)}(()=>{s&&(we=jt);try{var t=e();c&&Promise.resolve(t).catch(()=>{})}catch(e){t=Promise.reject(e)}s&&(we=null);var n=()=>t;a=c?.then(n,n)??Promise.resolve(t),c=a;var l=Ue,h=i.is_pending();u&&(i.update_pending_count(1),h||l.increment());const y=(e,t=void 0)=>{c=null,we=null,h||l.activate(),t?t!==$&&(o.f|=_,Xe(o,t)):(0!==(o.f&_)&&(o.f^=_),Xe(o,e),s&&void 0!==r&&(be.add(o),setTimeout(()=>{be.has(o)&&(function(e,t){s?console.warn(`%c[svelte] await_waterfall\n%cAn async derived, \`${e}\` (${t}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app\nhttps://svelte.dev/e/await_waterfall`,N,M):console.warn("https://svelte.dev/e/await_waterfall")}(o.label,r),be.delete(o))}))),u&&(i.update_pending_count(-1),h||l.decrement()),Ke()};if(a.then(y,e=>y(null,e||"unknown")),l)return()=>{queueMicrotask(()=>l.neuter())}}),s&&(o.f|=x),new Promise(e=>{!function t(r){function n(){r===a?e(o):t(a)}r.then(n,n)}(a)})}(e))).then(t=>{a?.activate(),c();try{n([...e.map(i),...t])}catch(e){0===(o.f&S)&&ce(e,o)}a?.deactivate(),Ke()}).catch(e=>{u.error(e)})}else n(e.map(i))}(r,n,t=>{At(8,()=>e(...t.map(or)),!0)})}function Pt(e,t=!0){return At(524320,e,!0,t)}function Ut(e){var t=e.teardown;if(null!==t){const e=Mt,r=Ft;Rt(!0),zt(null);try{t.call(null)}finally{Rt(e),zt(r)}}}function Dt(e,t=!1){var r=e.first;for(e.first=e.last=null;null!==r;){const e=r.ac;null!==e&&vt(()=>{e.abort($)});var n=r.next;64&r.f?r.parent=null:xt(r,t),r=n}}function xt(e,t=!0){var r=!1;(t||262144&e.f)&&null!==e.nodes_start&&null!==e.nodes_end&&(function(e,t){for(;null!==e;){var r=e===t?null:yt(e);e.remove(),e=r}}(e.nodes_start,e.nodes_end),r=!0),Dt(e,t&&!r),sr(e,0),hr(e,S);var n=e.transitions;if(null!==n)for(const e of n)e.stop();Ut(e);var i=e.parent;null!==i&&null!==i.first&&_t(e),s&&(e.component_function=null),e.next=e.prev=e.teardown=e.ctx=e.deps=e.fn=e.nodes_start=e.nodes_end=e.ac=null}function _t(e){var t=e.parent,r=e.prev,n=e.next;null!==r&&(r.next=n),null!==n&&(n.prev=r),null!==t&&(t.first===e&&(t.first=n),t.last===e&&(t.last=r))}function Ct(e,t){var r=[];It(e,r,!0),function(e,t){var r=e.length;if(r>0){var n=()=>--r||t();for(var i of e)i.out(n)}else t()}(r,()=>{xt(e),t&&t()})}function It(e,t,r){if(0===(e.f&A)){if(e.f^=A,null!==e.transitions)for(const n of e.transitions)(n.is_global||r)&&t.push(n);for(var n=e.first;null!==n;){var i=n.next;It(n,t,!!(0!==(n.f&K)||32&n.f)&&r),n=i}}}function Tt(e){Bt(e,!0)}function Bt(e,t){if(0!==(e.f&A)){e.f^=A,0===(e.f&b)&&(hr(e,v),Oe(e));for(var r=e.first;null!==r;){var n=r.next;Bt(r,!!(0!==(r.f&K)||32&r.f)&&t),r=n}if(null!==e.transitions)for(const r of e.transitions)(r.is_global||t)&&r.in()}}let $t=null,Lt=!1;function Nt(e){Lt=e}let Mt=!1;function Rt(e){Mt=e}let Ft=null,Ot=!1;function zt(e){Ft=e}let jt=null;function Ht(e){jt=e}let Gt=null,qt=null,Wt=0,Vt=null,Xt=1,Qt=0,Yt=Qt;function Zt(e){Yt=e}let Jt=!1;function er(){return++Xt}function tr(e){var t=e.f;if(0!==(t&v))return!0;if(0!==(t&k)){var r=e.deps,n=0!==(t&m);if(null!==r){var i,s,a=!!(512&t),o=n&&null!==jt&&!Jt,c=r.length;if((a||o)&&(null===jt||0===(jt.f&S))){var u=e,l=u.parent;for(i=0;i<c;i++)s=r[i],!a&&s?.reactions?.includes(u)||(s.reactions??=[]).push(u);a&&(u.f^=512),o&&null!==l&&0===(l.f&m)&&(u.f^=m)}for(i=0;i<c;i++)if(tr(s=r[i])&&Ee(s),s.wv>e.wv)return!0}n&&(null===jt||Jt)||hr(e,b)}return!1}function rr(e,t,r=!0){var n=e.reactions;if(null!==n&&!Gt?.includes(e))for(var i=0;i<n.length;i++){var s=n[i];2&s.f?rr(s,t,!1):t===s&&(r?hr(s,v):0!==(s.f&b)&&hr(s,k),Oe(s))}}function nr(e){var t=qt,n=Wt,i=Vt,a=Ft,o=Jt,c=Gt,u=J,l=Ot,y=Yt,p=e.f;qt=null,Wt=0,Vt=null,Jt=0!==(p&m)&&(Ot||!Lt||null===Ft),Ft=96&p?null:e,Gt=null,ee(e.ctx),Ot=!1,Yt=++Qt,null!==e.ac&&(vt(()=>{e.ac.abort($)}),e.ac=null);try{e.f|=D;var d=(0,e.fn)(),f=e.deps;if(null!==qt){var g;if(sr(e,Wt),null!==f&&Wt>0)for(f.length=Wt+qt.length,g=0;g<qt.length;g++)f[Wt+g]=qt[g];else e.deps=f=qt;if(!Jt||2&p&&null!==e.reactions)for(g=Wt;g<f.length;g++)(f[g].reactions??=[]).push(e)}else null!==f&&Wt<f.length&&(sr(e,Wt),f.length=Wt);if(!(null===Vt||Ot||null===f||6146&e.f))for(g=0;g<Vt.length;g++)rr(Vt[g],e);return null!==a&&a!==e&&(Qt++,null!==Vt&&(null===i?i=Vt:i.push(...Vt))),0!==(e.f&_)&&(e.f^=_),d}catch(e){return function(e){var t=jt;if(null===t)return Ft.f|=_,e;if(s&&e instanceof Error&&!oe.has(e)&&oe.set(e,function(e,t){const n=h(e,"message");if(!n||n.configurable){for(var i=at?"  ":"\t",s=`\n${i}in ${t.fn?.name||"<unknown>"}`,a=t.ctx;null!==a;)s+=`\n${i}in ${a.function?.[r].split("/").pop()}`,a=a.p;return{message:e.message+`\n${s}\n`,stack:e.stack?.split("\n").filter(e=>!e.includes("svelte/src/internal")).join("\n")}}}(e,t)),0===(t.f&E)){if(!(128&t.f))throw!t.parent&&e instanceof Error&&ue(e),e;t.b.error(e)}else ce(e,t)}(e)}finally{e.f^=D,qt=t,Wt=n,Vt=i,Ft=a,Jt=o,Gt=c,ee(u),Ot=l,Yt=y}}function ir(e,t){let r=t.reactions;if(null!==r){var n=o.call(r,e);if(-1!==n){var i=r.length-1;0===i?r=t.reactions=null:(r[n]=r[i],r.pop())}}null===r&&2&t.f&&(null===qt||!qt.includes(t))&&(hr(t,k),768&t.f||(t.f^=512),ke(t),sr(t,0))}function sr(e,t){var r=e.deps;if(null!==r)for(var n=t;n<r.length;n++)ir(e,r[n])}function ar(e){var t=e.f;if(0===(t&S)){hr(e,b);var r=jt,n=Lt;if(jt=e,Lt=!0,s){var i=ne;ie(e.component_function);var a=te;re(e.dev_stack??te)}try{16&t?function(e){for(var t=e.first;null!==t;){var r=t.next;!(32&t.f)&&xt(t),t=r}}(e):Dt(e),Ut(e);var o=nr(e);e.teardown="function"==typeof o?o:null,e.wv=Xt}finally{Lt=n,jt=r,s&&(ie(i),re(a))}}}function or(e){var t,r=!!(2&e.f);if($t?.add(e),null===Ft||Ot){if(r&&null===e.deps&&null===e.effects){var n=e,i=n.parent;null!==i&&0===(i.f&m)&&(n.f^=m)}}else if((null===jt||0===(jt.f&S))&&!Gt?.includes(e)){var a=Ft.deps;if(0!==(Ft.f&D))e.rv<Qt&&(e.rv=Qt,null===qt&&null!==a&&a[Wt]===e?Wt++:null===qt?qt=[e]:Jt&&qt.includes(e)||qt.push(e));else{(Ft.deps??=[]).push(e);var o=e.reactions;null===o?e.reactions=[Ft]:o.includes(Ft)||o.push(Ft)}}if(s){if(we){var c=0!==(we.f&D),u=we.deps?.includes(e);if(!c&&!Ot&&!u){t=e.label,s?console.warn(`%c[svelte] await_reactivity_loss\n%cDetected reactivity loss when reading \`${t}\`. This happens when state is read in an async function after an earlier \`await\`\nhttps://svelte.dev/e/await_reactivity_loss`,N,M):console.warn("https://svelte.dev/e/await_reactivity_loss");var l=Q("TracedAt");l&&console.warn(l)}}be.delete(e)}if(Mt){if(je.has(e))return je.get(e);if(r){var h=(n=e).v;return(0===(n.f&b)&&null!==n.reactions||cr(n))&&(h=Se(n)),je.set(n,h),h}}else if(r){if(n=e,xe?.has(n))return xe.get(n);tr(n)&&Ee(n)}if(0!==(e.f&_))throw e.v;return e.v}function cr(e){if(e.v===t)return!0;if(null===e.deps)return!1;for(const t of e.deps){if(je.has(t))return!0;if(2&t.f&&cr(t))return!0}return!1}function ur(e){var t=Ot;try{return Ot=!0,e()}finally{Ot=t}}const lr=-7169;function hr(e,t){e.f=e.f&lr|t}const yr=new Set,pr=new Set;let dr,fr=null;function gr(e){var t=this,r=t.ownerDocument,n=e.type,i=e.composedPath?.()||[],s=i[0]||e.target;fr=e;var o=0,c=fr===e&&e.__root;if(c){var u=i.indexOf(c);if(-1!==u&&(t===document||t===window))return void(e.__root=t);var h=i.indexOf(t);if(-1===h)return;u<=h&&(o=u)}if((s=i[o]||e.target)!==t){l(e,"currentTarget",{configurable:!0,get:()=>s||r});var y=Ft,p=jt;zt(null),Ht(null);try{for(var d,f=[];null!==s;){var g=s.assignedSlot||s.parentNode||s.host||null;try{var w=s["__"+n];if(null!=w&&(!s.disabled||e.target===s))if(a(w)){var[m,...b]=w;m.apply(s,[e,...b])}else w.call(s,e)}catch(e){d?f.push(e):d=e}if(e.cancelBubble||g===t||null===g)break;s=g}if(d){for(let e of f)queueMicrotask(()=>{throw e});throw d}}finally{e.__root=t,delete e.currentTarget,zt(y),Ht(p)}}}function wr(e,t){var r=jt;null===r.nodes_start&&(r.nodes_start=e,r.nodes_end=t)}function mr(e,t){var r,n=!!(1&t),i=!!(2&t),s=!e.startsWith("<!>");return()=>{if(z)return wr(O,null),O;var t,a;void 0===r&&(t=s?e:"<!>"+e,(a=document.createElement("template")).innerHTML=t.replaceAll("<!>","\x3c!----\x3e"),r=a.content,n||(r=ht(r)));var o=i||at?document.importNode(r,!0):r.cloneNode(!0);return n?wr(ht(o),o.lastChild):wr(o,o),o}}function br(){if(z)return wr(O,null),O;var e=document.createDocumentFragment(),t=document.createComment(""),r=lt();return e.append(t,r),wr(t,r),e}function vr(e,t){if(z)return jt.nodes_end=O,void G();null!==e&&e.before(t)}const kr=["touchstart","touchmove"];function Ar(e){return kr.includes(e)}let Sr=!0;function Er(e,t){return Ur(e,t)}function Kr(t,r){ut(),r.intro=r.intro??!1;const n=r.target,i=z,a=O;try{for(var o=ht(n);o&&(8!==o.nodeType||"["!==o.data);)o=yt(o);if(!o)throw e;j(!0),H(o),G();const i=Ur(t,{...r,anchor:o});if(null===O||8!==O.nodeType||"]"!==O.data)throw R(),e;return j(!1),i}catch(i){if(i instanceof Error&&i.message.split("\n").some(e=>e.startsWith("https://svelte.dev/e/")))throw i;return i!==e&&console.warn("Failed to hydrate: ",i),!1===r.recover&&function(){if(s){const e=new Error("hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed");throw e.name="Svelte error",e}throw new Error("https://svelte.dev/e/hydration_failed")}(),ut(),gt(n),j(!1),Er(t,r)}finally{j(i),H(a),dr=void 0}}const Pr=new Map;function Ur(e,{target:t,anchor:r,props:n={},events:i,context:s,intro:a=!0}){ut();var o=new Set,u=e=>{for(var r=0;r<e.length;r++){var n=e[r];if(!o.has(n)){o.add(n);var i=Ar(n);t.addEventListener(n,gr,{passive:i});var s=Pr.get(n);void 0===s?(document.addEventListener(n,gr,{passive:i}),Pr.set(n,1)):Pr.set(n,s+1)}}};u(c(yr)),pr.add(u);var l=void 0,h=function(){$e.ensure();const c=At(524352,()=>{var c=r??t.appendChild(lt());return Pt(()=>{s&&(se({}),J.c=s),i&&(n.$$events=i),z&&wr(c,null),Sr=a,l=e(c,n)||{},Sr=!0,z&&(jt.nodes_end=O),s&&ae()}),()=>{for(var e of o){t.removeEventListener(e,gr);var n=Pr.get(e);0===--n?(document.removeEventListener(e,gr),Pr.delete(e)):Pr.set(e,n)}pr.delete(u),c!==r&&c.parentNode?.removeChild(c)}},!0);return(e={})=>new Promise(t=>{e.outro?Ct(c,()=>{xt(c),t(void 0)}):(xt(c),t(void 0))})}();return Dr.set(l,h),l}let Dr=new WeakMap;if(s){function Al(e){if(!(e in globalThis)){let t;Object.defineProperty(globalThis,e,{configurable:!0,get:()=>{if(void 0!==t)return t;!function(e){if(s){const t=new Error(`rune_outside_svelte\nThe \`${e}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);throw t.name="Svelte error",t}throw new Error("https://svelte.dev/e/rune_outside_svelte")}(e)},set:e=>{t=e}})}}Al("$state"),Al("$effect"),Al("$derived"),Al("$inspect"),Al("$props"),Al("$bindable")}function xr(r,n,i=!1){z&&G();var a=r,o=null,c=null,u=t,l=!1;const h=(e,t=!0)=>{l=!0,d(t,e)};var y=null;function p(){null!==y&&(y.lastChild.remove(),a.before(y),y=null);var e=u?o:c,t=u?c:o;e&&Tt(e),t&&Ct(t,()=>{u?c=null:o=null})}const d=(t,r)=>{if(u===(u=t))return;let n=!1;if(z){const t="[!"===function(t){if(!t||8!==t.nodeType)throw R(),e;return t.data}(a);!!u===t&&(a=function(){for(var e=0,t=O;;){if(8===t.nodeType){var r=t.data;if("]"===r){if(0===e)return t;e-=1}else"["!==r&&"[!"!==r||(e+=1)}var n=yt(t);t.remove(),t=n}}(),H(a),j(!1),n=!0)}var i=a;u?o??=r&&Pt(()=>r(i)):c??=r&&Pt(()=>r(i)),p(),n&&j(!0)};!function(e,t=0){var r=At(16|t,e,!0);s&&(r.dev_stack=te)}(()=>{l=!1,n(h),l||d(null,null)},i?K:0),z&&(a=O)}function _r(e,t,r=!1){if(e.multiple){if(null==t)return;if(!a(t))return void(s?console.warn("%c[svelte] select_multiple_invalid_value\n%cThe `value` property of a `<select multiple>` element should be an array, but it received a non-array value. The selection will be kept as is.\nhttps://svelte.dev/e/select_multiple_invalid_value",N,M):console.warn("https://svelte.dev/e/select_multiple_invalid_value"));for(var n of e.options)n.selected=t.includes(Tr(n))}else{for(n of e.options)if(nt(Tr(n),t))return void(n.selected=!0);r&&void 0===t||(e.selectedIndex=-1)}}function Cr(e){var t=new MutationObserver(()=>{_r(e,e.__value)});t.observe(e,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["value"]}),function(){const e=At(8,null,!1);hr(e,b),e.teardown=()=>{t.disconnect()}}()}function Ir(e,t,r=t){var n=!0;kt(e,"change",t=>{var n,i=t?"[selected]":":checked";if(e.multiple)n=[].map.call(e.querySelectorAll(i),Tr);else{var s=e.querySelector(i)??e.querySelector("option:not([disabled])");n=s&&Tr(s)}r(n)}),At(4,()=>{var i=t();if(_r(e,i,n),n&&void 0===i){var s=e.querySelector(":checked");null!==s&&(i=Tr(s),r(i))}e.__value=i,n=!1},!1),Cr(e)}function Tr(e){return"__value"in e?e.__value:e.value}new Map,i(508),new Map([[!0,"yes"],[!1,"no"]]),Symbol("class"),Symbol("style");const Br=Symbol("is custom element"),$r=Symbol("is html");function Lr(e){if(z){var t=!1,r=()=>{if(!t){if(t=!0,e.hasAttribute("value")){var r=e.value;Nr(e,"value",null),e.value=r}if(e.hasAttribute("checked")){var n=e.checked;Nr(e,"checked",null),e.checked=n}}};e.__on_r=r,function(e){0===ye.length&&le(de),ye.push(e)}(r),bt()}}function Nr(e,t,r,n){var i=Mr(e);z&&(i[t]=e.getAttribute(t),"src"===t||"srcset"===t||"href"===t&&"LINK"===e.nodeName)?n||function(e,t,r){s&&("srcset"===t&&function(e,t){var r=Or(e.srcset),n=Or(t);return n.length===r.length&&n.every(([e,t],n)=>t===r[n][1]&&(Fr(r[n][0],e)||Fr(e,r[n][0])))}(e,r)||Fr(e.getAttribute(t)??"",r)||function(e,t,r){s?console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${e}\` attribute on \`${t}\` changed its value between server and client renders. The client value, \`${r}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`,N,M):console.warn("https://svelte.dev/e/hydration_attribute_changed")}(t,e.outerHTML.replace(e.innerHTML,e.innerHTML&&"..."),String(r)))}(e,t,r??""):i[t]!==(i[t]=r)&&("loading"===t&&(e[T]=r),null==r?e.removeAttribute(t):"string"!=typeof r&&function(e){var t,r=e.getAttribute("is")||e.nodeName,n=Rr.get(r);if(n)return n;Rr.set(r,n=[]);for(var i=e,s=Element.prototype;s!==i;){for(var a in t=y(i))t[a].set&&n.push(a);i=f(i)}return n}(e).includes(t)?e[t]=r:e.setAttribute(t,r))}function Mr(e){return e.__attributes??={[Br]:e.nodeName.includes("-"),[$r]:"http://www.w3.org/1999/xhtml"===e.namespaceURI}}var Rr=new Map;function Fr(e,t){return e===t||new URL(e,document.baseURI).href===new URL(t,document.baseURI).href}function Or(e){return e.split(",").map(e=>e.trim().split(" ").filter(Boolean))}function zr(e,t,r=t){var n=new WeakSet;kt(e,"input",async i=>{s&&"checkbox"===e.type&&L();var a=i?e.defaultValue:e.value;if(a=Hr(e)?Gr(a):a,r(a),null!==Ue&&n.add(Ue),await async function(){await Promise.resolve(),Le()}(),a!==(a=t())){var o=e.selectionStart,c=e.selectionEnd;e.value=a??"",null!==c&&(e.selectionStart=o,e.selectionEnd=Math.min(c,e.value.length))}}),(z&&e.defaultValue!==e.value||null==ur(t)&&e.value)&&(r(Hr(e)?Gr(e.value):e.value),null!==Ue&&n.add(Ue)),Et(()=>{s&&"checkbox"===e.type&&L();var r=t();if(e===document.activeElement){var i=De??Ue;if(n.has(i))return}Hr(e)&&r===Gr(e.value)||("date"!==e.type||r||e.value)&&r!==e.value&&(e.value=r??"")})}function jr(e,t,r=t){kt(e,"change",t=>{var n=t?e.defaultChecked:e.checked;r(n)}),(z&&e.defaultChecked!==e.checked||null==ur(t))&&r(e.checked),Et(()=>{var r=t();e.checked=Boolean(r)})}function Hr(e){var t=e.type;return"number"===t||"range"===t}function Gr(e){return""===e?null:+e}new Set,new Set,new WeakMap,Symbol();class qr{#f;#g;constructor(e){var t=new Map,r=(e,r)=>{var n=function(e,t=!1){const r=qe(e);return t||(r.equals=X),r}(r,!1,!1);return t.set(e,n),n};const n=new Proxy({...e.props||{},$$events:{}},{get:(e,n)=>or(t.get(n)??r(n,Reflect.get(e,n))),has:(e,n)=>n===I||(or(t.get(n)??r(n,Reflect.get(e,n))),Reflect.has(e,n)),set:(e,n,i)=>(Ve(t.get(n)??r(n,i),i),Reflect.set(e,n,i))});this.#g=(e.hydrate?Kr:Er)(e.component,{target:e.target,anchor:e.anchor,props:n,context:e.context,intro:e.intro??!1,recover:e.recover}),e?.props?.$$host&&!1!==e.sync||Le(),this.#f=n.$$events;for(const e of Object.keys(this.#g))"$set"!==e&&"$destroy"!==e&&"$on"!==e&&l(this,e,{get(){return this.#g[e]},set(t){this.#g[e]=t},enumerable:!0});this.#g.$set=e=>{Object.assign(n,e)},this.#g.$destroy=()=>{!function(e,t){const r=Dr.get(e);r?(Dr.delete(e),r(t)):(s&&(s?console.warn("%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount",N,M):console.warn("https://svelte.dev/e/lifecycle_double_unmount")),Promise.resolve())}(this.#g)}}$set(e){this.#g.$set(e)}$on(e,t){this.#f[e]=this.#f[e]||[];const r=(...e)=>t.call(this,...e);return this.#f[e].push(r),()=>{this.#f[e]=this.#f[e].filter(e=>e!==r)}}$destroy(){this.#g.$destroy()}}let Wr,Vr;function Xr(e,t,r,n){const i=r[e]?.type;if(t="Boolean"===i&&"boolean"!=typeof t?null!=t:t,!n||!r[e])return t;if("toAttribute"===n)switch(i){case"Object":case"Array":return null==t?null:JSON.stringify(t);case"Boolean":return t?"":null;case"Number":return null==t?null:t;default:return t}else switch(i){case"Object":case"Array":return t&&JSON.parse(t);case"Boolean":default:return t;case"Number":return null!=t?+t:t}}"function"==typeof HTMLElement&&(Wr=class extends HTMLElement{$$ctor;$$s;$$c;$$cn=!1;$$d={};$$r=!1;$$p_d={};$$l={};$$l_u=new Map;$$me;constructor(e,t,r){super(),this.$$ctor=e,this.$$s=t,r&&this.attachShadow({mode:"open"})}addEventListener(e,t,r){if(this.$$l[e]=this.$$l[e]||[],this.$$l[e].push(t),this.$$c){const r=this.$$c.$on(e,t);this.$$l_u.set(t,r)}super.addEventListener(e,t,r)}removeEventListener(e,t,r){if(super.removeEventListener(e,t,r),this.$$c){const e=this.$$l_u.get(t);e&&(e(),this.$$l_u.delete(t))}}async connectedCallback(){if(this.$$cn=!0,!this.$$c){if(await Promise.resolve(),!this.$$cn||this.$$c)return;function t(e){return t=>{const r=document.createElement("slot");"default"!==e&&(r.name=e),vr(t,r)}}const r={},n=function(e){const t={};return e.childNodes.forEach(e=>{t[e.slot||"default"]=!0}),t}(this);for(const i of this.$$s)i in n&&("default"!==i||this.$$d.children?r[i]=t(i):(this.$$d.children=t(i),r.default=!0));for(const s of this.attributes){const a=this.$$g_p(s.name);a in this.$$d||(this.$$d[a]=Xr(a,s.value,this.$$p_d,"toProp"))}for(const o in this.$$p_d)o in this.$$d||void 0===this[o]||(this.$$d[o]=this[o],delete this[o]);this.$$c=(e={component:this.$$ctor,target:this.shadowRoot||this,props:{...this.$$d,$$slots:r,$$host:this}},new qr(e)),this.$$me=function(e){$e.ensure();const t=At(524352,e,!0);return()=>{xt(t)}}(()=>{Et(()=>{this.$$r=!0;for(const e of u(this.$$c)){if(!this.$$p_d[e]?.reflect)continue;this.$$d[e]=this.$$c[e];const t=Xr(e,this.$$d[e],this.$$p_d,"toAttribute");null==t?this.removeAttribute(this.$$p_d[e].attribute||e):this.setAttribute(this.$$p_d[e].attribute||e,t)}this.$$r=!1})});for(const c in this.$$l)for(const l of this.$$l[c]){const h=this.$$c.$on(c,l);this.$$l_u.set(l,h)}this.$$l={}}var e}attributeChangedCallback(e,t,r){this.$$r||(e=this.$$g_p(e),this.$$d[e]=Xr(e,r,this.$$p_d,"toProp"),this.$$c?.$set({[e]:this.$$d[e]}))}disconnectedCallback(){this.$$cn=!1,Promise.resolve().then(()=>{!this.$$cn&&this.$$c&&(this.$$c.$destroy(),this.$$me(),this.$$c=void 0)})}$$g_p(e){return u(this.$$p_d).find(t=>this.$$p_d[t].attribute===e||!this.$$p_d[t].attribute&&t.toLowerCase()===e)||e}});let Qr=null;function Yr(){return null!==Qr&&0!==Qr.byteLength||(Qr=new Uint8Array(Vr.memory.buffer)),Qr}let Zr="undefined"!=typeof TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};"undefined"!=typeof TextDecoder&&Zr.decode();let Jr=0;function en(e,t){return function(e,t){return Jr+=t,Jr>=2146435072&&(Zr="undefined"!=typeof TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}},Zr.decode(),Jr=t),Zr.decode(Yr().subarray(e,e+t))}(e>>>=0,t)}let tn=0;const rn="undefined"!=typeof TextEncoder?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},nn="function"==typeof rn.encodeInto?function(e,t){return rn.encodeInto(e,t)}:function(e,t){const r=rn.encode(e);return t.set(r),{read:e.length,written:r.length}};function sn(e,t,r){if(void 0===r){const r=rn.encode(e),n=t(r.length,1)>>>0;return Yr().subarray(n,n+r.length).set(r),tn=r.length,n}let n=e.length,i=t(n,1)>>>0;const s=Yr();let a=0;for(;a<n;a++){const t=e.charCodeAt(a);if(t>127)break;s[i+a]=t}if(a!==n){0!==a&&(e=e.slice(a)),i=r(i,n,n=a+3*e.length,1)>>>0;const t=Yr().subarray(i+a,i+n);a+=nn(e,t).written,i=r(i,n,a,1)>>>0}return tn=a,i}function an(e){let t,r;try{const n=sn(e,Vr.__wbindgen_malloc,Vr.__wbindgen_realloc),i=tn,s=Vr.inv_encode(n,i);return t=s[0],r=s[1],en(s[0],s[1])}finally{Vr.__wbindgen_free(t,r,1)}}function on(e){let t,r;try{const n=sn(e,Vr.__wbindgen_malloc,Vr.__wbindgen_realloc),i=tn,s=Vr.inv_decode(n,i);return t=s[0],r=s[1],en(s[0],s[1])}finally{Vr.__wbindgen_free(t,r,1)}}function cn(e){let t,r;try{const n=sn(e,Vr.__wbindgen_malloc,Vr.__wbindgen_realloc),i=tn,s=Vr.to_base64(n,i);return t=s[0],r=s[1],en(s[0],s[1])}finally{Vr.__wbindgen_free(t,r,1)}}function un(e){let t,r;try{const s=sn(e,Vr.__wbindgen_malloc,Vr.__wbindgen_realloc),a=tn,o=Vr.from_base64(s,a);var n=o[0],i=o[1];if(o[3])throw n=0,i=0,function(e){const t=Vr.__wbindgen_export_0.get(e);return Vr.__externref_table_dealloc(e),t}(o[2]);return t=n,r=i,en(n,i)}finally{Vr.__wbindgen_free(t,r,1)}}const ln=new Set(["basic","cors","default"]);async function hn(e){if(void 0!==Vr)return Vr;void 0!==e&&(Object.getPrototypeOf(e)===Object.prototype?({module_or_path:e}=e):console.warn("using deprecated parameters for the initialization function; pass a single object instead")),void 0===e&&(e=new URL(i(84),i.b));const t=function(){const e={wbg:{}};return e.wbg.__wbindgen_init_externref_table=function(){const e=Vr.__wbindgen_export_0,t=e.grow(4);e.set(0,void 0),e.set(t+0,void 0),e.set(t+1,null),e.set(t+2,!0),e.set(t+3,!1)},e.wbg.__wbindgen_string_new=function(e,t){return en(e,t)},e}();("string"==typeof e||"function"==typeof Request&&e instanceof Request||"function"==typeof URL&&e instanceof URL)&&(e=fetch(e));const{instance:r,module:n}=await async function(e,t){if("function"==typeof Response&&e instanceof Response){if("function"==typeof WebAssembly.instantiateStreaming)try{return await WebAssembly.instantiateStreaming(e,t)}catch(t){if(!e.ok||!ln.has(e.type)||"application/wasm"===e.headers.get("Content-Type"))throw t;console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",t)}const r=await e.arrayBuffer();return await WebAssembly.instantiate(r,t)}{const r=await WebAssembly.instantiate(e,t);return r instanceof WebAssembly.Instance?{instance:r,module:e}:r}}(await e,t);return function(e,t){return Vr=e.exports,hn.__wbindgen_wasm_module=t,Qr=null,Vr.__wbindgen_start(),Vr}(r,n)}const yn=hn,pn="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},dn=Symbol("doneWritingPromise"),fn=Symbol("doneWritingResolve"),gn=Symbol("doneWritingReject"),wn=Symbol("readingIndex");class mn extends Array{constructor(){super(),Object.setPrototypeOf(this,mn.prototype),this[dn]=new Promise((e,t)=>{this[fn]=e,this[gn]=t}),this[dn].catch(()=>{})}}function bn(e){return e&&e.getReader&&Array.isArray(e)}function vn(e){if(!bn(e)){const t=e.getWriter(),r=t.releaseLock;return t.releaseLock=()=>{t.closed.catch(function(){}),r.call(t)},t}this.stream=e}function kn(e){if(bn(e))return"array";if(pn.ReadableStream&&pn.ReadableStream.prototype.isPrototypeOf(e))return"web";if(e&&!(pn.ReadableStream&&e instanceof pn.ReadableStream)&&"function"==typeof e._read&&"object"==typeof e._readableState)throw Error("Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`");return!(!e||!e.getReader)&&"web-like"}function An(e){return Uint8Array.prototype.isPrototypeOf(e)}function Sn(e){if(1===e.length)return e[0];let t=0;for(let r=0;r<e.length;r++){if(!An(e[r]))throw Error("concatUint8Array: Data must be in the form of a Uint8Array");t+=e[r].length}const r=new Uint8Array(t);let n=0;return e.forEach(function(e){r.set(e,n),n+=e.length}),r}mn.prototype.getReader=function(){return void 0===this[wn]&&(this[wn]=0),{read:async()=>(await this[dn],this[wn]===this.length?{value:void 0,done:!0}:{value:this[this[wn]++],done:!1})}},mn.prototype.readToEnd=async function(e){await this[dn];const t=e(this.slice(this[wn]));return this.length=0,t},mn.prototype.clone=function(){const e=new mn;return e[dn]=this[dn].then(()=>{e.push(...this)}),e},vn.prototype.write=async function(e){this.stream.push(e)},vn.prototype.close=async function(){this.stream[fn]()},vn.prototype.abort=async function(e){return this.stream[gn](e),e},vn.prototype.releaseLock=function(){},"object"==typeof pn.process&&pn.process.versions;const En=new WeakSet,Kn=Symbol("externalBuffer");function Pn(e){if(this.stream=e,e[Kn]&&(this[Kn]=e[Kn].slice()),bn(e)){const t=e.getReader();return this._read=t.read.bind(t),this._releaseLock=()=>{},void(this._cancel=()=>{})}if(kn(e)){const t=e.getReader();return this._read=t.read.bind(t),this._releaseLock=()=>{t.closed.catch(function(){}),t.releaseLock()},void(this._cancel=t.cancel.bind(t))}let t=!1;this._read=async()=>t||En.has(e)?{value:void 0,done:!0}:(t=!0,{value:e,done:!1}),this._releaseLock=()=>{if(t)try{En.add(e)}catch(e){}}}function Un(e){return kn(e)?e:new ReadableStream({start(t){t.enqueue(e),t.close()}})}function Dn(e){if(kn(e))return e;const t=new mn;return(async()=>{const r=Hn(t);await r.write(e),await r.close()})(),t}function xn(e){return e.some(e=>kn(e)&&!bn(e))?function(e){e=e.map(Un);const t=In(async function(e){await Promise.all(n.map(t=>On(t,e)))});let r=Promise.resolve();const n=e.map((n,i)=>Bn(n,(n,s)=>(r=r.then(()=>_n(n,t.writable,{preventClose:i!==e.length-1})),r)));return t.readable}(e):e.some(e=>bn(e))?function(e){const t=new mn;let r=Promise.resolve();return e.forEach((n,i)=>(r=r.then(()=>_n(n,t,{preventClose:i!==e.length-1})),r)),t}(e):"string"==typeof e[0]?e.join(""):Sn(e)}async function _n(e,t,{preventClose:r=!1,preventAbort:n=!1,preventCancel:i=!1}={}){if(kn(e)&&!bn(e)){e=Un(e);try{if(e[Kn]){const r=Hn(t);for(let t=0;t<e[Kn].length;t++)await r.ready,await r.write(e[Kn][t]);r.releaseLock()}await e.pipeTo(t,{preventClose:r,preventAbort:n,preventCancel:i})}catch(e){}return}const s=jn(e=Dn(e)),a=Hn(t);try{for(;;){await a.ready;const{done:e,value:t}=await s.read();if(e){r||await a.close();break}await a.write(t)}}catch(e){n||await a.abort(e)}finally{s.releaseLock(),a.releaseLock()}}function Cn(e,t){const r=new TransformStream(t);return _n(e,r.writable),r.readable}function In(e){let t,r,n,i=!1,s=!1;return{readable:new ReadableStream({start(e){n=e},pull(){t?t():i=!0},async cancel(t){s=!0,e&&await e(t),r&&r(t)}},{highWaterMark:0}),writable:new WritableStream({write:async function(e){if(s)throw Error("Stream is cancelled");n.enqueue(e),i?i=!1:(await new Promise((e,n)=>{t=e,r=n}),t=null,r=null)},close:n.close.bind(n),abort:n.error.bind(n)})}}function Tn(e,t=()=>{},r=()=>{}){if(bn(e)){const n=new mn;return(async()=>{const i=Hn(n);try{const n=await Fn(e),s=t(n),a=r();let o;o=void 0!==s&&void 0!==a?xn([s,a]):void 0!==s?s:a,await i.write(o),await i.close()}catch(e){await i.abort(e)}})(),n}if(kn(e))return Cn(e,{async transform(e,r){try{const n=await t(e);void 0!==n&&r.enqueue(n)}catch(e){r.error(e)}},async flush(e){try{const t=await r();void 0!==t&&e.enqueue(t)}catch(t){e.error(t)}}});const n=t(e),i=r();return void 0!==n&&void 0!==i?xn([n,i]):void 0!==n?n:i}function Bn(e,t){if(kn(e)&&!bn(e)){let r;const n=new TransformStream({start(e){r=e}}),i=_n(e,n.writable),s=In(async function(e){r.error(e),await i,await new Promise(setTimeout)});return t(n.readable,s.writable),s.readable}e=Dn(e);const r=new mn;return t(e,r),r}function $n(e,t){let r;const n=Bn(e,(e,i)=>{const s=jn(e);s.remainder=()=>(s.releaseLock(),_n(e,i),n),r=t(s)});return r}function Ln(e){if(bn(e))return e.clone();if(kn(e)){const t=function(e){if(bn(e))throw Error("ArrayStream cannot be tee()d, use clone() instead");if(kn(e)){const t=Un(e).tee();return t[0][Kn]=t[1][Kn]=e[Kn],t}return[Rn(e),Rn(e)]}(e);return Mn(e,t[0]),t[1]}return Rn(e)}function Nn(e){return bn(e)?Ln(e):kn(e)?new ReadableStream({start(t){const r=Bn(e,async(e,r)=>{const n=jn(e),i=Hn(r);try{for(;;){await i.ready;const{done:r,value:s}=await n.read();if(r){try{t.close()}catch(e){}return void await i.close()}try{t.enqueue(s)}catch(e){}await i.write(s)}}catch(e){t.error(e),await i.abort(e)}});Mn(e,r)}}):Rn(e)}function Mn(e,t){Object.entries(Object.getOwnPropertyDescriptors(e.constructor.prototype)).forEach(([r,n])=>{"constructor"!==r&&(n.value?n.value=n.value.bind(t):n.get=n.get.bind(t),Object.defineProperty(e,r,n))})}function Rn(e,t=0,r=1/0){if(bn(e))throw Error("Not implemented");if(kn(e)){if(t>=0&&r>=0){let n=0;return Cn(e,{transform(e,i){n<r?(n+e.length>=t&&i.enqueue(Rn(e,Math.max(t-n,0),r-n)),n+=e.length):i.terminate()}})}if(t<0&&(r<0||r===1/0)){let n=[];return Tn(e,e=>{e.length>=-t?n=[e]:n.push(e)},()=>Rn(xn(n),t,r))}if(0===t&&r<0){let n;return Tn(e,e=>{const i=n?xn([n,e]):e;if(i.length>=-r)return n=Rn(i,r),Rn(i,t,r);n=i})}return console.warn(`stream.slice(input, ${t}, ${r}) not implemented efficiently.`),zn(async()=>Rn(await Fn(e),t,r))}return e[Kn]&&(e=xn(e[Kn].concat([e]))),An(e)?e.subarray(t,r===1/0?e.length:r):e.slice(t,r)}async function Fn(e,t=xn){return bn(e)?e.readToEnd(t):kn(e)?jn(e).readToEnd(t):e}async function On(e,t){if(kn(e)){if(e.cancel){const r=await e.cancel(t);return await new Promise(setTimeout),r}if(e.destroy)return e.destroy(t),await new Promise(setTimeout),t}}function zn(e){const t=new mn;return(async()=>{const r=Hn(t);try{await r.write(await e()),await r.close()}catch(e){await r.abort(e)}})(),t}function jn(e){return new Pn(e)}function Hn(e){return new vn(e)}Pn.prototype.read=async function(){return this[Kn]&&this[Kn].length?{done:!1,value:this[Kn].shift()}:this._read()},Pn.prototype.releaseLock=function(){this[Kn]&&(this.stream[Kn]=this[Kn]),this._releaseLock()},Pn.prototype.cancel=function(e){return this._cancel(e)},Pn.prototype.readLine=async function(){let e,t=[];for(;!e;){let{done:r,value:n}=await this.read();if(n+="",r)return t.length?xn(t):void 0;const i=n.indexOf("\n")+1;i&&(e=xn(t.concat(n.substr(0,i))),t=[]),i!==n.length&&t.push(n.substr(i))}return this.unshift(...t),e},Pn.prototype.readByte=async function(){const{done:e,value:t}=await this.read();if(e)return;const r=t[0];return this.unshift(Rn(t,1)),r},Pn.prototype.readBytes=async function(e){const t=[];let r=0;for(;;){const{done:n,value:i}=await this.read();if(n)return t.length?xn(t):void 0;if(t.push(i),r+=i.length,r>=e){const r=xn(t);return this.unshift(Rn(r,e)),Rn(r,0,e)}}},Pn.prototype.peekBytes=async function(e){const t=await this.readBytes(e);return this.unshift(t),t},Pn.prototype.unshift=function(...e){this[Kn]||(this[Kn]=[]),1===e.length&&An(e[0])&&this[Kn].length&&e[0].length&&this[Kn][0].byteOffset>=e[0].length?this[Kn][0]=new Uint8Array(this[Kn][0].buffer,this[Kn][0].byteOffset-e[0].length,this[Kn][0].byteLength+e[0].length):this[Kn].unshift(...e.filter(e=>e&&e.length))},Pn.prototype.readToEnd=async function(e=xn){const t=[];for(;;){const{done:e,value:r}=await this.read();if(e)break;t.push(r)}return e(t)};const Gn=Symbol("byValue");var qn={curve:{nistP256:"nistP256",p256:"nistP256",nistP384:"nistP384",p384:"nistP384",nistP521:"nistP521",p521:"nistP521",secp256k1:"secp256k1",ed25519Legacy:"ed25519Legacy",ed25519:"ed25519Legacy",curve25519Legacy:"curve25519Legacy",curve25519:"curve25519Legacy",brainpoolP256r1:"brainpoolP256r1",brainpoolP384r1:"brainpoolP384r1",brainpoolP512r1:"brainpoolP512r1"},s2k:{simple:0,salted:1,iterated:3,argon2:4,gnu:101},publicKey:{rsaEncryptSign:1,rsaEncrypt:2,rsaSign:3,elgamal:16,dsa:17,ecdh:18,ecdsa:19,eddsaLegacy:22,aedh:23,aedsa:24,x25519:25,x448:26,ed25519:27,ed448:28},symmetric:{idea:1,tripledes:2,cast5:3,blowfish:4,aes128:7,aes192:8,aes256:9,twofish:10},compression:{uncompressed:0,zip:1,zlib:2,bzip2:3},hash:{md5:1,sha1:2,ripemd:3,sha256:8,sha384:9,sha512:10,sha224:11,sha3_256:12,sha3_512:14},webHash:{"SHA-1":2,"SHA-256":8,"SHA-384":9,"SHA-512":10},aead:{eax:1,ocb:2,gcm:3,experimentalGCM:100},packet:{publicKeyEncryptedSessionKey:1,signature:2,symEncryptedSessionKey:3,onePassSignature:4,secretKey:5,publicKey:6,secretSubkey:7,compressedData:8,symmetricallyEncryptedData:9,marker:10,literalData:11,trust:12,userID:13,publicSubkey:14,userAttribute:17,symEncryptedIntegrityProtectedData:18,modificationDetectionCode:19,aeadEncryptedData:20,padding:21},literal:{binary:98,text:116,utf8:117,mime:109},signature:{binary:0,text:1,standalone:2,certGeneric:16,certPersona:17,certCasual:18,certPositive:19,certRevocation:48,subkeyBinding:24,keyBinding:25,key:31,keyRevocation:32,subkeyRevocation:40,timestamp:64,thirdParty:80},signatureSubpacket:{signatureCreationTime:2,signatureExpirationTime:3,exportableCertification:4,trustSignature:5,regularExpression:6,revocable:7,keyExpirationTime:9,placeholderBackwardsCompatibility:10,preferredSymmetricAlgorithms:11,revocationKey:12,issuerKeyID:16,notationData:20,preferredHashAlgorithms:21,preferredCompressionAlgorithms:22,keyServerPreferences:23,preferredKeyServer:24,primaryUserID:25,policyURI:26,keyFlags:27,signersUserID:28,reasonForRevocation:29,features:30,signatureTarget:31,embeddedSignature:32,issuerFingerprint:33,preferredAEADAlgorithms:34,preferredCipherSuites:39},keyFlags:{certifyKeys:1,signData:2,encryptCommunication:4,encryptStorage:8,splitPrivateKey:16,authentication:32,sharedPrivateKey:128},armor:{multipartSection:0,multipartLast:1,signed:2,message:3,publicKey:4,privateKey:5,signature:6},reasonForRevocation:{noReason:0,keySuperseded:1,keyCompromised:2,keyRetired:3,userIDInvalid:32},features:{modificationDetection:1,aead:2,v5Keys:4,seipdv2:8},write:function(e,t){if("number"==typeof t&&(t=this.read(e,t)),void 0!==e[t])return e[t];throw Error("Invalid enum value.")},read:function(e,t){if(e[Gn]||(e[Gn]=[],Object.entries(e).forEach(([t,r])=>{e[Gn][r]=t})),void 0!==e[Gn][t])return e[Gn][t];throw Error("Invalid enum value.")}},Wn={preferredHashAlgorithm:qn.hash.sha512,preferredSymmetricAlgorithm:qn.symmetric.aes256,preferredCompressionAlgorithm:qn.compression.uncompressed,aeadProtect:!1,parseAEADEncryptedV4KeysAsLegacy:!1,preferredAEADAlgorithm:qn.aead.gcm,aeadChunkSizeByte:12,v6Keys:!1,enableParsingV5Entities:!1,s2kType:qn.s2k.iterated,s2kIterationCountByte:224,s2kArgon2Params:{passes:3,parallelism:4,memoryExponent:16},allowUnauthenticatedMessages:!1,allowUnauthenticatedStream:!1,minRSABits:2047,passwordCollisionCheck:!1,allowInsecureDecryptionWithSigningKeys:!1,allowInsecureVerificationWithReformattedKeys:!1,allowMissingKeyFlags:!1,constantTimePKCS1Decryption:!1,constantTimePKCS1DecryptionSupportedSymmetricAlgorithms:new Set([qn.symmetric.aes128,qn.symmetric.aes192,qn.symmetric.aes256]),ignoreUnsupportedPackets:!0,ignoreMalformedPackets:!1,enforceGrammar:!0,additionalAllowedPackets:[],showVersion:!1,showComment:!1,versionString:"OpenPGP.js 6.2.2",commentString:"https://openpgpjs.org",maxUserIDLength:5120,knownNotations:[],nonDeterministicSignaturesViaNotation:!0,useEllipticFallback:!0,rejectHashAlgorithms:new Set([qn.hash.md5,qn.hash.ripemd]),rejectMessageHashAlgorithms:new Set([qn.hash.md5,qn.hash.ripemd,qn.hash.sha1]),rejectPublicKeyAlgorithms:new Set([qn.publicKey.elgamal,qn.publicKey.dsa]),rejectCurves:new Set([qn.curve.secp256k1])};const Vn=(()=>{try{return!1}catch(e){}return!1})(),Xn={isString:function(e){return"string"==typeof e||e instanceof String},nodeRequire:()=>{},isArray:function(e){return e instanceof Array},isUint8Array:An,isStream:kn,getNobleCurve:async(e,t)=>{if(!Wn.useEllipticFallback)throw Error("This curve is only supported in the full build of OpenPGP.js");const{nobleCurves:r}=await i.e(523).then(i.bind(i,523));switch(e){case qn.publicKey.ecdh:case qn.publicKey.ecdsa:{const e=r.get(t);if(!e)throw Error("Unsupported curve");return e}case qn.publicKey.x448:return r.get("x448");case qn.publicKey.ed448:return r.get("ed448");default:throw Error("Unsupported curve")}},readNumber:function(e){let t=0;for(let r=0;r<e.length;r++)t+=256**r*e[e.length-1-r];return t},writeNumber:function(e,t){const r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e>>8*(t-n-1)&255;return r},readDate:function(e){const t=Xn.readNumber(e);return new Date(1e3*t)},writeDate:function(e){const t=Math.floor(e.getTime()/1e3);return Xn.writeNumber(t,4)},normalizeDate:function(e=Date.now()){return null===e||e===1/0?e:new Date(1e3*Math.floor(+e/1e3))},readMPI:function(e){const t=7+(e[0]<<8|e[1])>>>3;return Xn.readExactSubarray(e,2,2+t)},readExactSubarray:function(e,t,r){if(e.length<r-t)throw Error("Input array too short");return e.subarray(t,r)},leftPad(e,t){if(e.length>t)throw Error("Input array too long");const r=new Uint8Array(t),n=t-e.length;return r.set(e,n),r},uint8ArrayToMPI:function(e){const t=Xn.uint8ArrayBitLength(e);if(0===t)throw Error("Zero MPI");const r=e.subarray(e.length-Math.ceil(t/8)),n=new Uint8Array([(65280&t)>>8,255&t]);return Xn.concatUint8Array([n,r])},uint8ArrayBitLength:function(e){let t;for(t=0;t<e.length&&0===e[t];t++);if(t===e.length)return 0;const r=e.subarray(t);return 8*(r.length-1)+Xn.nbits(r[0])},hexToUint8Array:function(e){const t=new Uint8Array(e.length>>1);for(let r=0;r<e.length>>1;r++)t[r]=parseInt(e.substr(r<<1,2),16);return t},uint8ArrayToHex:function(e){const t="0123456789abcdef";let r="";return e.forEach(e=>{r+=t[e>>4]+t[15&e]}),r},stringToUint8Array:function(e){return Tn(e,e=>{if(!Xn.isString(e))throw Error("stringToUint8Array: Data must be in the form of a string");const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t})},uint8ArrayToString:function(e){const t=[],r=16384,n=(e=new Uint8Array(e)).length;for(let i=0;i<n;i+=r)t.push(String.fromCharCode.apply(String,e.subarray(i,i+r<n?i+r:n)));return t.join("")},encodeUTF8:function(e){const t=new TextEncoder("utf-8");function r(e,r=!1){return t.encode(e,{stream:!r})}return Tn(e,r,()=>r("",!0))},decodeUTF8:function(e){const t=new TextDecoder("utf-8");function r(e,r=!1){return t.decode(e,{stream:!r})}return Tn(e,r,()=>r(new Uint8Array,!0))},concat:xn,concatUint8Array:Sn,equalsUint8Array:function(e,t){if(!Xn.isUint8Array(e)||!Xn.isUint8Array(t))throw Error("Data must be in the form of a Uint8Array");if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0},findLastIndex:function(e,t){for(let r=e.length;r>=0;r--)if(t(e[r],r,e))return r;return-1},writeChecksum:function(e){let t=0;for(let r=0;r<e.length;r++)t=t+e[r]&65535;return Xn.writeNumber(t,2)},printDebug:function(e){Vn&&console.log("[OpenPGP.js debug]",e)},printDebugError:function(e){Vn&&console.error("[OpenPGP.js debug]",e)},nbits:function(e){let t=1,r=e>>>16;return 0!==r&&(e=r,t+=16),r=e>>8,0!==r&&(e=r,t+=8),r=e>>4,0!==r&&(e=r,t+=4),r=e>>2,0!==r&&(e=r,t+=2),r=e>>1,0!==r&&(e=r,t+=1),t},double:function(e){const t=new Uint8Array(e.length),r=e.length-1;for(let n=0;n<r;n++)t[n]=e[n]<<1^e[n+1]>>7;return t[r]=e[r]<<1^135*(e[0]>>7),t},shiftRight:function(e,t){if(t)for(let r=e.length-1;r>=0;r--)e[r]>>=t,r>0&&(e[r]|=e[r-1]<<8-t);return e},getWebCrypto:function(){const e=void 0!==pn&&pn.crypto&&pn.crypto.subtle||this.getNodeCrypto()?.webcrypto.subtle;if(!e)throw Error("The WebCrypto API is not available");return e},getNodeCrypto:function(){return this.nodeRequire("crypto")},getNodeZlib:function(){return this.nodeRequire("zlib")},getNodeBuffer:function(){return(this.nodeRequire("buffer")||{}).Buffer},getHardwareConcurrency:function(){return"undefined"!=typeof navigator?navigator.hardwareConcurrency||1:this.nodeRequire("os").cpus().length},isEmailAddress:function(e){return!!Xn.isString(e)&&/^[^\p{C}\p{Z}@<>\\]+@[^\p{C}\p{Z}@<>\\]+[^\p{C}\p{Z}\p{P}]$/u.test(e)},canonicalizeEOL:function(e){let t=!1;return Tn(e,e=>{let r;t&&(e=Xn.concatUint8Array([new Uint8Array([13]),e])),13===e[e.length-1]?(t=!0,e=e.subarray(0,-1)):t=!1;const n=[];for(let t=0;r=e.indexOf(10,t)+1,r;t=r)13!==e[r-2]&&n.push(r);if(!n.length)return e;const i=new Uint8Array(e.length+n.length);let s=0;for(let t=0;t<n.length;t++){const r=e.subarray(n[t-1]||0,n[t]);i.set(r,s),s+=r.length,i[s-1]=13,i[s]=10,s++}return i.set(e.subarray(n[n.length-1]||0),s),i},()=>t?new Uint8Array([13]):void 0)},nativeEOL:function(e){let t=!1;return Tn(e,e=>{let r;13===(e=t&&10!==e[0]?Xn.concatUint8Array([new Uint8Array([13]),e]):new Uint8Array(e))[e.length-1]?(t=!0,e=e.subarray(0,-1)):t=!1;let n=0;for(let t=0;t!==e.length;t=r){r=e.indexOf(13,t)+1,r||(r=e.length);const i=r-(10===e[r]?1:0);t&&e.copyWithin(n,t,i),n+=i-t}return e.subarray(0,n)},()=>t?new Uint8Array([13]):void 0)},removeTrailingSpaces:function(e){return e.split("\n").map(e=>{let t=e.length-1;for(;t>=0&&(" "===e[t]||"\t"===e[t]||"\r"===e[t]);t--);return e.substr(0,t+1)}).join("\n")},wrapError:function(e,t){if(!t)return e instanceof Error?e:Error(e);if(e instanceof Error){try{e.message+=": "+t.message,e.cause=t}catch(e){}return e}return Error(e+": "+t.message,{cause:t})},constructAllowedPackets:function(e){const t={};return e.forEach(e=>{if(!e.tag)throw Error("Invalid input: expected a packet class");t[e.tag]=e}),t},anyPromise:function(e){return new Promise(async(t,r)=>{let n;await Promise.all(e.map(async e=>{try{t(await e)}catch(e){n=e}})),r(n)})},selectUint8Array:function(e,t,r){const n=Math.max(t.length,r.length),i=new Uint8Array(n);let s=0;for(let n=0;n<i.length;n++)i[n]=t[n]&256-e|r[n]&255+e,s+=e&n<t.length|1-e&n<r.length;return i.subarray(0,s)},selectUint8:function(e,t,r){return t&256-e|r&255+e},isAES:function(e){return e===qn.symmetric.aes128||e===qn.symmetric.aes192||e===qn.symmetric.aes256}},Qn=Xn.getNodeBuffer();let Yn,Zn;function Jn(e){let t=new Uint8Array;return Tn(e,e=>{t=Xn.concatUint8Array([t,e]);const r=[],n=Math.floor(t.length/45),i=45*n,s=Yn(t.subarray(0,i));for(let e=0;e<n;e++)r.push(s.substr(60*e,60)),r.push("\n");return t=t.subarray(i),r.join("")},()=>t.length?Yn(t)+"\n":"")}function ei(e){let t="";return Tn(e,e=>{t+=e;let r=0;const n=[" ","\t","\r","\n"];for(let e=0;e<n.length;e++){const i=n[e];for(let e=t.indexOf(i);-1!==e;e=t.indexOf(i,e+1))r++}let i=t.length;for(;i>0&&(i-r)%4!=0;i--)n.includes(t[i])&&r--;const s=Zn(t.substr(0,i));return t=t.substr(i),s},()=>Zn(t))}function ti(e){return ei(e.replace(/-/g,"+").replace(/_/g,"/"))}function ri(e,t){let r=Jn(e).replace(/[\r\n]/g,"");return r=r.replace(/[+]/g,"-").replace(/[/]/g,"_").replace(/[=]/g,""),r}function ni(e){const t=e.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);if(!t)throw Error("Unknown ASCII armor type");return/MESSAGE, PART \d+\/\d+/.test(t[1])?qn.armor.multipartSection:/MESSAGE, PART \d+/.test(t[1])?qn.armor.multipartLast:/SIGNED MESSAGE/.test(t[1])?qn.armor.signed:/MESSAGE/.test(t[1])?qn.armor.message:/PUBLIC KEY BLOCK/.test(t[1])?qn.armor.publicKey:/PRIVATE KEY BLOCK/.test(t[1])?qn.armor.privateKey:/SIGNATURE/.test(t[1])?qn.armor.signature:void 0}function ii(e,t){let r="";return t.showVersion&&(r+="Version: "+t.versionString+"\n"),t.showComment&&(r+="Comment: "+t.commentString+"\n"),e&&(r+="Comment: "+e+"\n"),r+="\n",r}function si(e){const t=function(e){let t=13501623;return Tn(e,e=>{const r=oi?Math.floor(e.length/4):0,n=new Uint32Array(e.buffer,e.byteOffset,r);for(let e=0;e<r;e++)t^=n[e],t=ai[0][t>>24&255]^ai[1][t>>16&255]^ai[2][t>>8&255]^ai[3][255&t];for(let n=4*r;n<e.length;n++)t=t>>8^ai[0][255&t^e[n]]},()=>new Uint8Array([t,t>>8,t>>16]))}(e);return Jn(t)}Qn?(Yn=e=>Qn.from(e).toString("base64"),Zn=e=>{const t=Qn.from(e,"base64");return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}):(Yn=e=>btoa(Xn.uint8ArrayToString(e)),Zn=e=>Xn.stringToUint8Array(atob(e)));const ai=[Array(255),Array(255),Array(255),Array(255)];for(let Sl=0;Sl<=255;Sl++){let El=Sl<<16;for(let Kl=0;Kl<8;Kl++)El=El<<1^(8388608&El?8801531:0);ai[0][Sl]=(16711680&El)>>16|65280&El|(255&El)<<16}for(let Pl=0;Pl<=255;Pl++)ai[1][Pl]=ai[0][Pl]>>8^ai[0][255&ai[0][Pl]];for(let Ul=0;Ul<=255;Ul++)ai[2][Ul]=ai[1][Ul]>>8^ai[0][255&ai[1][Ul]];for(let Dl=0;Dl<=255;Dl++)ai[3][Dl]=ai[2][Dl]>>8^ai[0][255&ai[2][Dl]];const oi=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,255,!0),255===new Int16Array(e)[0]}();function ci(e){for(let t=0;t<e.length;t++)/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(e[t])||Xn.printDebugError(Error("Improperly formatted armor header: "+e[t])),/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(e[t])||Xn.printDebugError(Error("Unknown header: "+e[t]))}function ui(e){let t=e;const r=e.lastIndexOf("=");return r>=0&&r!==e.length-1&&(t=e.slice(0,r)),t}function li(e){return new Promise(async(t,r)=>{try{const n=/^-----[^-]+-----$/m,i=/^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;let s;const a=[];let o,c,u=a,l=[];const h=ei(Bn(e,async(e,y)=>{const p=jn(e);try{for(;;){let e=await p.readLine();if(void 0===e)throw Error("Misformed armored text");if(e=Xn.removeTrailingSpaces(e.replace(/[\r\n]/g,"")),s)if(o)c||s!==qn.armor.signed||(n.test(e)?(l=l.join("\r\n"),c=!0,ci(u),u=[],o=!1):l.push(e.replace(/^- /,"")));else if(n.test(e)&&r(Error("Mandatory blank line missing between armor headers and armor data")),i.test(e)){if(ci(u),o=!0,c||s!==qn.armor.signed){t({text:l,data:h,headers:a,type:s});break}}else u.push(e);else n.test(e)&&(s=ni(e))}}catch(e){return void r(e)}const d=Hn(y);try{for(;;){await d.ready;const{done:e,value:t}=await p.read();if(e)throw Error("Misformed armored text");const r=t+"";if(-1!==r.indexOf("=")||-1!==r.indexOf("-")){let e=await p.readToEnd();e.length||(e=""),e=r+e,e=Xn.removeTrailingSpaces(e.replace(/\r/g,""));const t=e.split(n);if(1===t.length)throw Error("Misformed armored text");const i=ui(t[0].slice(0,-1));await d.write(i);break}await d.write(r)}await d.ready,await d.close()}catch(e){await d.abort(e)}}))}catch(e){r(e)}}).then(async e=>(bn(e.data)&&(e.data=await Fn(e.data)),e))}function hi(e,t,r,n,i,s=!1,a=Wn){let o,c;e===qn.armor.signed&&(o=t.text,c=t.hash,t=t.data);const u=s&&Nn(t),l=[];switch(e){case qn.armor.multipartSection:l.push("-----BEGIN PGP MESSAGE, PART "+r+"/"+n+"-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP MESSAGE, PART "+r+"/"+n+"-----\n");break;case qn.armor.multipartLast:l.push("-----BEGIN PGP MESSAGE, PART "+r+"-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP MESSAGE, PART "+r+"-----\n");break;case qn.armor.signed:l.push("-----BEGIN PGP SIGNED MESSAGE-----\n"),l.push(c?`Hash: ${c}\n\n`:"\n"),l.push(o.replace(/^-/gm,"- -")),l.push("\n-----BEGIN PGP SIGNATURE-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP SIGNATURE-----\n");break;case qn.armor.message:l.push("-----BEGIN PGP MESSAGE-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP MESSAGE-----\n");break;case qn.armor.publicKey:l.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP PUBLIC KEY BLOCK-----\n");break;case qn.armor.privateKey:l.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP PRIVATE KEY BLOCK-----\n");break;case qn.armor.signature:l.push("-----BEGIN PGP SIGNATURE-----\n"),l.push(ii(i,a)),l.push(Jn(t)),u&&l.push("=",si(u)),l.push("-----END PGP SIGNATURE-----\n")}return Xn.concat(l)}const yi=BigInt(0),pi=BigInt(1);function di(e){const t="0123456789ABCDEF";let r="";return e.forEach(e=>{r+=t[e>>4]+t[15&e]}),BigInt("0x0"+r)}function fi(e,t){const r=e%t;return r<yi?r+t:r}function gi(e,t,r){if(r===yi)throw Error("Modulo cannot be zero");if(r===pi)return BigInt(0);if(t<yi)throw Error("Unsopported negative exponent");let n=t,i=e;i%=r;let s=BigInt(1);for(;n>yi;){const e=n&pi;n>>=pi,s=e?s*i%r:s,i=i*i%r}return s}function wi(e){return e>=yi?e:-e}function mi(e,t){const{gcd:r,x:n}=function(e,t){let r=BigInt(0),n=BigInt(1),i=BigInt(1),s=BigInt(0),a=wi(e),o=wi(t);const c=e<yi,u=t<yi;for(;o!==yi;){const e=a/o;let t=r;r=i-e*r,i=t,t=n,n=s-e*n,s=t,t=o,o=a%o,a=t}return{x:c?-i:i,y:u?-s:s,gcd:a}}(e,t);if(r!==pi)throw Error("Inverse does not exist");return fi(n+t,t)}function bi(e){const t=e<yi?BigInt(-1):yi,r=BigInt(8);let n=1,i=e;for(;(i>>=r)!==t;)n++;return n}function vi(e,t="be",r){let n=e.toString(16);n.length%2==1&&(n="0"+n);const i=n.length/2,s=new Uint8Array(r||i),a=r?r-i:0;let o=0;for(;o<i;)s[o+a]=parseInt(n.slice(2*o,2*o+2),16),o++;return"be"!==t&&s.reverse(),s}const ki=Xn.getNodeCrypto();function Ai(e){const t="undefined"!=typeof crypto?crypto:ki?.webcrypto;if(t?.getRandomValues){const r=new Uint8Array(e);return t.getRandomValues(r)}throw Error("No secure random number generator available.")}function Si(e,t){if(t<e)throw Error("Illegal parameter value: max <= min");const r=t-e;return fi(di(Ai(bi(r)+8)),r)+e}BigInt(1),[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999].map(e=>BigInt(e));const Ei=Xn.getWebCrypto(),Ki=Xn.getNodeCrypto(),Pi=Ki&&Ki.getHashes();function Ui(e){if(Ki&&Pi.includes(e))return async function(t){const r=Ki.createHash(e);return Tn(t,e=>{r.update(e)},()=>new Uint8Array(r.digest()))}}function Di(e,t){const r=async()=>{const{nobleHashes:t}=await i.e(291).then(i.bind(i,291)),r=t.get(e);if(!r)throw Error("Unsupported hash");return r};return async function(e){if(bn(e)&&(e=await Fn(e)),Xn.isStream(e)){const t=(await r()).create();return Tn(e,e=>{t.update(e)},()=>t.digest())}return Ei&&t?new Uint8Array(await Ei.digest(t,e)):(await r())(e)}}const xi=Ui("md5")||Di("md5"),_i=Ui("sha1")||Di("sha1","SHA-1"),Ci=Ui("sha224")||Di("sha224"),Ii=Ui("sha256")||Di("sha256","SHA-256"),Ti=Ui("sha384")||Di("sha384","SHA-384"),Bi=Ui("sha512")||Di("sha512","SHA-512"),$i=Ui("ripemd160")||Di("ripemd160"),Li=Ui("sha3-256")||Di("sha3_256"),Ni=Ui("sha3-512")||Di("sha3_512");function Mi(e,t){switch(e){case qn.hash.md5:return xi(t);case qn.hash.sha1:return _i(t);case qn.hash.ripemd:return $i(t);case qn.hash.sha256:return Ii(t);case qn.hash.sha384:return Ti(t);case qn.hash.sha512:return Bi(t);case qn.hash.sha224:return Ci(t);case qn.hash.sha3_256:return Li(t);case qn.hash.sha3_512:return Ni(t);default:throw Error("Unsupported hash function")}}function Ri(e){switch(e){case qn.hash.md5:return 16;case qn.hash.sha1:case qn.hash.ripemd:return 20;case qn.hash.sha256:return 32;case qn.hash.sha384:return 48;case qn.hash.sha512:return 64;case qn.hash.sha224:return 28;case qn.hash.sha3_256:return 32;case qn.hash.sha3_512:return 64;default:throw Error("Invalid hash algorithm.")}}const Fi=[];function Oi(e,t){const r=e.length;if(r>t-11)throw Error("Message too long");const n=function(e){const t=new Uint8Array(e);let r=0;for(;r<e;){const n=Ai(e-r);for(let e=0;e<n.length;e++)0!==n[e]&&(t[r++]=n[e])}return t}(t-r-3),i=new Uint8Array(t);return i[1]=2,i.set(n,2),i.set(e,t-r),i}function zi(e,t){let r=2,n=1;for(let t=r;t<e.length;t++)n&=0!==e[t],r+=n;const i=r-2,s=e.subarray(r+1),a=0===e[0]&2===e[1]&i>=8&!n;if(t)return Xn.selectUint8Array(a,s,t);if(a)return s;throw Error("Decryption error")}function ji(e,t,r){let n;if(t.length!==Ri(e))throw Error("Invalid hash length");const i=new Uint8Array(Fi[e].length);for(n=0;n<Fi[e].length;n++)i[n]=Fi[e][n];const s=i.length+t.length;if(r<s+11)throw Error("Intended encoded message length too short");const a=new Uint8Array(r-s-3).fill(255),o=new Uint8Array(r);return o[1]=1,o.set(a,2),o.set(i,r-s),o.set(t,r-t.length),o}Fi[1]=[48,32,48,12,6,8,42,134,72,134,247,13,2,5,5,0,4,16],Fi[2]=[48,33,48,9,6,5,43,14,3,2,26,5,0,4,20],Fi[3]=[48,33,48,9,6,5,43,36,3,2,1,5,0,4,20],Fi[8]=[48,49,48,13,6,9,96,134,72,1,101,3,4,2,1,5,0,4,32],Fi[9]=[48,65,48,13,6,9,96,134,72,1,101,3,4,2,2,5,0,4,48],Fi[10]=[48,81,48,13,6,9,96,134,72,1,101,3,4,2,3,5,0,4,64],Fi[11]=[48,45,48,13,6,9,96,134,72,1,101,3,4,2,4,5,0,4,28];const Hi=Xn.getWebCrypto(),Gi=Xn.getNodeCrypto(),qi=BigInt(1);async function Wi(e,t,r,n,i,s,a,o,c){if(Ri(e)>=r.length)throw Error("Digest size cannot exceed key modulus size");if(t&&!Xn.isStream(t))if(Xn.getWebCrypto())try{return await async function(e,t,r,n,i,s,a,o){const c=await Xi(r,n,i,s,a,o),u={name:"RSASSA-PKCS1-v1_5",hash:{name:e}},l=await Hi.importKey("jwk",c,u,!1,["sign"]);return new Uint8Array(await Hi.sign("RSASSA-PKCS1-v1_5",l,t))}(qn.read(qn.webHash,e),t,r,n,i,s,a,o)}catch(e){Xn.printDebugError(e)}else if(Xn.getNodeCrypto())return async function(e,t,r,n,i,s,a,o){const c=Gi.createSign(qn.read(qn.hash,e));c.write(t),c.end();const u=await Xi(r,n,i,s,a,o);return new Uint8Array(c.sign({key:u,format:"jwk",type:"pkcs1"}))}(e,t,r,n,i,s,a,o);return async function(e,t,r,n){return t=di(t),vi(gi(di(ji(e,n,bi(t))),r=di(r),t),"be",bi(t))}(e,r,i,c)}async function Vi(e,t,r){return Xn.getNodeCrypto()?async function(e,t,r){const n={key:Qi(t,r),format:"jwk",type:"pkcs1",padding:Gi.constants.RSA_PKCS1_PADDING};return new Uint8Array(Gi.publicEncrypt(n,e))}(e,t,r):async function(e,t,r){if(t=di(t),e=di(Oi(e,bi(t))),r=di(r),e>=t)throw Error("Message size cannot exceed modulus size");return vi(gi(e,r,t),"be",bi(t))}(e,t,r)}async function Xi(e,t,r,n,i,s){const a=di(n),o=di(i),c=di(r);let u=fi(c,o-qi),l=fi(c,a-qi);return l=vi(l),u=vi(u),{kty:"RSA",n:ri(e),e:ri(t),d:ri(r),p:ri(i),q:ri(n),dp:ri(u),dq:ri(l),qi:ri(s),ext:!0}}function Qi(e,t){return{kty:"RSA",n:ri(e),e:ri(t),ext:!0}}const Yi=BigInt(1),Zi={"2a8648ce3d030107":qn.curve.nistP256,"2b81040022":qn.curve.nistP384,"2b81040023":qn.curve.nistP521,"2b8104000a":qn.curve.secp256k1,"2b06010401da470f01":qn.curve.ed25519Legacy,"2b060104019755010501":qn.curve.curve25519Legacy,"2b2403030208010107":qn.curve.brainpoolP256r1,"2b240303020801010b":qn.curve.brainpoolP384r1,"2b240303020801010d":qn.curve.brainpoolP512r1};class Ji{constructor(e){if(e instanceof Ji)this.oid=e.oid;else if(Xn.isArray(e)||Xn.isUint8Array(e)){if(6===(e=new Uint8Array(e))[0]){if(e[1]!==e.length-2)throw Error("Length mismatch in DER encoded oid");e=e.subarray(2)}this.oid=e}else this.oid=""}read(e){if(e.length>=1){const t=e[0];if(e.length>=1+t)return this.oid=e.subarray(1,1+t),1+this.oid.length}throw Error("Invalid oid")}write(){return Xn.concatUint8Array([new Uint8Array([this.oid.length]),this.oid])}toHex(){return Xn.uint8ArrayToHex(this.oid)}getName(){const e=Zi[this.toHex()];if(!e)throw Error("Unknown curve object identifier.");return e}}function es(e){let t,r=0;const n=e[0];return n<192?([r]=e,t=1):n<255?(r=(e[0]-192<<8)+e[1]+192,t=2):255===n&&(r=Xn.readNumber(e.subarray(1,5)),t=5),{len:r,offset:t}}function ts(e){return e<192?new Uint8Array([e]):e>191&&e<8384?new Uint8Array([192+(e-192>>8),e-192&255]):Xn.concatUint8Array([new Uint8Array([255]),Xn.writeNumber(e,4)])}function rs(e){if(e<0||e>30)throw Error("Partial Length power must be between 1 and 30");return new Uint8Array([224+e])}function ns(e){return new Uint8Array([192|e])}function is(e,t){return Xn.concatUint8Array([ns(e),ts(t)])}function ss(e){return[qn.packet.literalData,qn.packet.compressedData,qn.packet.symmetricallyEncryptedData,qn.packet.symEncryptedIntegrityProtectedData,qn.packet.aeadEncryptedData].includes(e)}async function as(e,t,r){let n,i;try{const s=await e.peekBytes(2);if(!s||s.length<2||!(128&s[0]))throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");const a=await e.readByte();let o,c,u=-1,l=-1;l=0,64&a&&(l=1),l?u=63&a:(u=(63&a)>>2,c=3&a);const h=ss(u);let y,p=null;if(t&&h){if("array"===t){const e=new mn;n=Hn(e),p=e}else{const e=new TransformStream;n=Hn(e.writable),p=e.readable}i=r({tag:u,packet:p})}else p=[];do{if(l){const t=await e.readByte();if(y=!1,t<192)o=t;else if(t>=192&&t<224)o=(t-192<<8)+await e.readByte()+192;else if(t>223&&t<255){if(o=1<<(31&t),y=!0,!h)throw new TypeError("This packet type does not support partial lengths.")}else o=await e.readByte()<<24|await e.readByte()<<16|await e.readByte()<<8|await e.readByte()}else switch(c){case 0:o=await e.readByte();break;case 1:o=await e.readByte()<<8|await e.readByte();break;case 2:o=await e.readByte()<<24|await e.readByte()<<16|await e.readByte()<<8|await e.readByte();break;default:o=1/0}if(o>0){let t=0;for(;;){n&&await n.ready;const{done:r,value:i}=await e.read();if(r){if(o===1/0)break;throw Error("Unexpected end of packet")}const s=o===1/0?i:i.subarray(0,o-t);if(n?await n.write(s):p.push(s),t+=i.length,t>=o){e.unshift(i.subarray(o-t+i.length));break}}}}while(y);n?(await n.ready,await n.close()):(p=Xn.concatUint8Array(p),await r({tag:u,packet:p}))}catch(e){if(n)return await n.abort(e),!0;throw e}finally{n&&await i}}class os extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,os),this.name="UnsupportedError"}}class cs extends os{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,os),this.name="UnknownPacketError"}}class us extends os{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,os),this.name="MalformedPacketError"}}class ls{constructor(e,t){this.tag=e,this.rawContent=t}write(){return this.rawContent}}async function hs(e,t,r,n,s,a){if(Ri(t)<Ri(ds(e)))throw Error("Hash algorithm too weak for EdDSA.");switch(e){case qn.publicKey.ed25519:try{const t=Xn.getWebCrypto(),r=gs(e,n,s),i=await t.importKey("jwk",r,"Ed25519",!1,["sign"]);return{RS:new Uint8Array(await t.sign("Ed25519",i,a))}}catch(e){if("NotSupportedError"!==e.name)throw e;const{default:t}=await i.e(837).then(i.bind(i,837)),r=Xn.concatUint8Array([s,n]);return{RS:t.sign.detached(a,r)}}case qn.publicKey.ed448:return{RS:(await Xn.getNobleCurve(qn.publicKey.ed448)).sign(a,s)};default:throw Error("Unsupported EdDSA algorithm")}}async function ys(e,t,{RS:r},n,s,a){if(Ri(t)<Ri(ds(e)))throw Error("Hash algorithm too weak for EdDSA.");switch(e){case qn.publicKey.ed25519:try{const t=Xn.getWebCrypto(),n=fs(e,s),i=await t.importKey("jwk",n,"Ed25519",!1,["verify"]);return await t.verify("Ed25519",i,r,a)}catch(e){if("NotSupportedError"!==e.name)throw e;const{default:t}=await i.e(837).then(i.bind(i,837));return t.sign.detached.verify(a,r,s)}case qn.publicKey.ed448:return(await Xn.getNobleCurve(qn.publicKey.ed448)).verify(r,a,s);default:throw Error("Unsupported EdDSA algorithm")}}function ps(e){switch(e){case qn.publicKey.ed25519:return 32;case qn.publicKey.ed448:return 57;default:throw Error("Unsupported EdDSA algorithm")}}function ds(e){switch(e){case qn.publicKey.ed25519:return qn.hash.sha256;case qn.publicKey.ed448:return qn.hash.sha512;default:throw Error("Unknown EdDSA algo")}}const fs=(e,t)=>{if(e===qn.publicKey.ed25519)return{kty:"OKP",crv:"Ed25519",x:ri(t),ext:!0};throw Error("Unsupported EdDSA algorithm")},gs=(e,t,r)=>{if(e===qn.publicKey.ed25519){const n=fs(e,t);return n.d=ri(r),n}throw Error("Unsupported EdDSA algorithm")};function ws(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function ms(e,...t){if(!ws(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function bs(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function vs(e,t){ms(e);const r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}function ks(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}function As(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function Ss(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Es(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}const Ks=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function Ps(e){if("string"==typeof e)e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e);else{if(!ws(e))throw Error("Uint8Array expected, got "+typeof e);e=Bs(e)}return e}function Us(e,t){return e.buffer===t.buffer&&e.byteOffset<t.byteOffset+t.byteLength&&t.byteOffset<e.byteOffset+e.byteLength}function Ds(e,t){if(Us(e,t)&&e.byteOffset<t.byteOffset)throw Error("complex overlap of input and output is not supported")}function xs(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r}const _s=(e,t)=>{function r(r,...n){if(ms(r),!Ks)throw Error("Non little-endian hardware is not yet supported");if(void 0!==e.nonceLength){const t=n[0];if(!t)throw Error("nonce / iv required");e.varSizeNonce?ms(t):ms(t,e.nonceLength)}const i=e.tagLength;i&&void 0!==n[1]&&ms(n[1]);const s=t(r,...n),a=(e,t)=>{if(void 0!==t){if(2!==e)throw Error("cipher output not supported");ms(t)}};let o=!1;return{encrypt(e,t){if(o)throw Error("cannot encrypt() twice with same key + nonce");return o=!0,ms(e),a(s.encrypt.length,t),s.encrypt(e,t)},decrypt(e,t){if(ms(e),i&&e.length<i)throw Error("invalid ciphertext length: smaller than tagLength="+i);return a(s.decrypt.length,t),s.decrypt(e,t)}}}return Object.assign(r,e),r};function Cs(e,t,r=!0){if(void 0===t)return new Uint8Array(e);if(t.length!==e)throw Error("invalid output length, expected "+e+", got: "+t.length);if(r&&!Ts(t))throw Error("invalid output, must be aligned");return t}function Is(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),a=Number(r>>i&s),o=Number(r&s);e.setUint32(t+0,a,n),e.setUint32(t+4,o,n)}function Ts(e){return e.byteOffset%4==0}function Bs(e){return Uint8Array.from(e)}const $s=16,Ls=new Uint8Array(16),Ns=As(Ls),Ms=e=>(e>>>0&255)<<24|(e>>>8&255)<<16|(e>>>16&255)<<8|e>>>24&255;class Rs{constructor(e,t){this.blockLen=$s,this.outputLen=$s,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,ms(e=Ps(e),16);const r=Es(e);let n=r.getUint32(0,!1),i=r.getUint32(4,!1),s=r.getUint32(8,!1),a=r.getUint32(12,!1);const o=[];for(let e=0;e<128;e++)o.push({s0:Ms(n),s1:Ms(i),s2:Ms(s),s3:Ms(a)}),({s0:n,s1:i,s2:s,s3:a}={s3:(l=s)<<31|(h=a)>>>1,s2:(u=i)<<31|l>>>1,s1:(c=n)<<31|u>>>1,s0:c>>>1^225<<24&-(1&h)});var c,u,l,h;const y=(p=t||1024)>65536?8:p>1024?4:2;var p;if(![1,2,4,8].includes(y))throw Error("ghash: invalid window size, expected 2, 4 or 8");this.W=y;const d=128/y,f=this.windowSize=2**y,g=[];for(let e=0;e<d;e++)for(let t=0;t<f;t++){let r=0,n=0,i=0,s=0;for(let a=0;a<y;a++){if(!(t>>>y-a-1&1))continue;const{s0:c,s1:u,s2:l,s3:h}=o[y*e+a];r^=c,n^=u,i^=l,s^=h}g.push({s0:r,s1:n,s2:i,s3:s})}this.t=g}_updateBlock(e,t,r,n){e^=this.s0,t^=this.s1,r^=this.s2,n^=this.s3;const{W:i,t:s,windowSize:a}=this;let o=0,c=0,u=0,l=0;const h=(1<<i)-1;let y=0;for(const p of[e,t,r,n])for(let e=0;e<4;e++){const t=p>>>8*e&255;for(let e=8/i-1;e>=0;e--){const r=t>>>i*e&h,{s0:n,s1:p,s2:d,s3:f}=s[y*a+r];o^=n,c^=p,u^=d,l^=f,y+=1}}this.s0=o,this.s1=c,this.s2=u,this.s3=l}update(e){bs(this),ms(e=Ps(e));const t=As(e),r=Math.floor(e.length/$s),n=e.length%$s;for(let e=0;e<r;e++)this._updateBlock(t[4*e+0],t[4*e+1],t[4*e+2],t[4*e+3]);return n&&(Ls.set(e.subarray(r*$s)),this._updateBlock(Ns[0],Ns[1],Ns[2],Ns[3]),Ss(Ns)),this}destroy(){const{t:e}=this;for(const t of e)t.s0=0,t.s1=0,t.s2=0,t.s3=0}digestInto(e){bs(this),vs(e,this),this.finished=!0;const{s0:t,s1:r,s2:n,s3:i}=this,s=As(e);return s[0]=t,s[1]=r,s[2]=n,s[3]=i,e}digest(){const e=new Uint8Array($s);return this.digestInto(e),this.destroy(),e}}class Fs extends Rs{constructor(e,t){ms(e=Ps(e));const r=function(e){e.reverse();const t=1&e[15];let r=0;for(let t=0;t<e.length;t++){const n=e[t];e[t]=n>>>1|r,r=(1&n)<<7}return e[0]^=225&-t,e}(Bs(e));super(r,t),Ss(r)}update(e){e=Ps(e),bs(this);const t=As(e),r=e.length%$s,n=Math.floor(e.length/$s);for(let e=0;e<n;e++)this._updateBlock(Ms(t[4*e+3]),Ms(t[4*e+2]),Ms(t[4*e+1]),Ms(t[4*e+0]));return r&&(Ls.set(e.subarray(n*$s)),this._updateBlock(Ms(Ns[3]),Ms(Ns[2]),Ms(Ns[1]),Ms(Ns[0])),Ss(Ns)),this}digestInto(e){bs(this),vs(e,this),this.finished=!0;const{s0:t,s1:r,s2:n,s3:i}=this,s=As(e);return s[0]=t,s[1]=r,s[2]=n,s[3]=i,e.reverse()}}function Os(e){const t=(t,r)=>e(r,t.length).update(Ps(t)).digest(),r=e(new Uint8Array(16),0);return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=(t,r)=>e(t,r),t}const zs=Os((e,t)=>new Rs(e,t));Os((e,t)=>new Fs(e,t));const js=16,Hs=new Uint8Array(js);function Gs(e){return e<<1^283&-(e>>7)}function qs(e,t){let r=0;for(;t>0;t>>=1)r^=e&-(1&t),e=Gs(e);return r}const Ws=(()=>{const e=new Uint8Array(256);for(let t=0,r=1;t<256;t++,r^=Gs(r))e[t]=r;const t=new Uint8Array(256);t[0]=99;for(let r=0;r<255;r++){let n=e[255-r];n|=n<<8,t[e[r]]=255&(n^n>>4^n>>5^n>>6^n>>7^99)}return Ss(e),t})(),Vs=Ws.map((e,t)=>Ws.indexOf(t)),Xs=e=>e<<8|e>>>24,Qs=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function Ys(e,t){if(256!==e.length)throw Error("Wrong sbox length");const r=new Uint32Array(256).map((r,n)=>t(e[n])),n=r.map(Xs),i=n.map(Xs),s=i.map(Xs),a=new Uint32Array(65536),o=new Uint32Array(65536),c=new Uint16Array(65536);for(let t=0;t<256;t++)for(let u=0;u<256;u++){const l=256*t+u;a[l]=r[t]^n[u],o[l]=i[t]^s[u],c[l]=e[t]<<8|e[u]}return{sbox:e,sbox2:c,T0:r,T1:n,T2:i,T3:s,T01:a,T23:o}}const Zs=Ys(Ws,e=>qs(e,3)<<24|e<<16|e<<8|qs(e,2)),Js=Ys(Vs,e=>qs(e,11)<<24|qs(e,13)<<16|qs(e,9)<<8|qs(e,14)),ea=(()=>{const e=new Uint8Array(16);for(let t=0,r=1;t<16;t++,r=Gs(r))e[t]=r;return e})();function ta(e){ms(e);const t=e.length;if(![16,24,32].includes(t))throw Error("aes: invalid key size, should be 16, 24 or 32, got "+t);const{sbox2:r}=Zs,n=[];Ts(e)||n.push(e=Bs(e));const i=As(e),s=i.length,a=e=>ia(r,e,e,e,e),o=new Uint32Array(t+28);o.set(i);for(let e=s;e<o.length;e++){let t=o[e-1];e%s==0?t=a((c=t)<<24|c>>>8)^ea[e/s-1]:s>6&&e%s==4&&(t=a(t)),o[e]=o[e-s]^t}var c;return Ss(...n),o}function ra(e){const t=ta(e),r=t.slice(),n=t.length,{sbox2:i}=Zs,{T0:s,T1:a,T2:o,T3:c}=Js;for(let e=0;e<n;e+=4)for(let i=0;i<4;i++)r[e+i]=t[n-e-4+i];Ss(t);for(let e=4;e<n-4;e++){const t=r[e],n=ia(i,t,t,t,t);r[e]=s[255&n]^a[n>>>8&255]^o[n>>>16&255]^c[n>>>24]}return r}function na(e,t,r,n,i,s){return e[r<<8&65280|n>>>8&255]^t[i>>>8&65280|s>>>24&255]}function ia(e,t,r,n,i){return e[255&t|65280&r]|e[n>>>16&255|i>>>16&65280]<<16}function sa(e,t,r,n,i){const{sbox2:s,T01:a,T23:o}=Zs;let c=0;t^=e[c++],r^=e[c++],n^=e[c++],i^=e[c++];const u=e.length/4-2;for(let s=0;s<u;s++){const s=e[c++]^na(a,o,t,r,n,i),u=e[c++]^na(a,o,r,n,i,t),l=e[c++]^na(a,o,n,i,t,r),h=e[c++]^na(a,o,i,t,r,n);t=s,r=u,n=l,i=h}return{s0:e[c++]^ia(s,t,r,n,i),s1:e[c++]^ia(s,r,n,i,t),s2:e[c++]^ia(s,n,i,t,r),s3:e[c++]^ia(s,i,t,r,n)}}function aa(e,t,r,n,i){const{sbox2:s,T01:a,T23:o}=Js;let c=0;t^=e[c++],r^=e[c++],n^=e[c++],i^=e[c++];const u=e.length/4-2;for(let s=0;s<u;s++){const s=e[c++]^na(a,o,t,i,n,r),u=e[c++]^na(a,o,r,t,i,n),l=e[c++]^na(a,o,n,r,t,i),h=e[c++]^na(a,o,i,n,r,t);t=s,r=u,n=l,i=h}return{s0:e[c++]^ia(s,t,i,n,r),s1:e[c++]^ia(s,r,t,i,n),s2:e[c++]^ia(s,n,r,t,i),s3:e[c++]^ia(s,i,n,r,t)}}function oa(e,t,r,n){ms(t,js),ms(r);const i=r.length;Ds(r,n=Cs(i,n));const s=t,a=As(s);let{s0:o,s1:c,s2:u,s3:l}=sa(e,a[0],a[1],a[2],a[3]);const h=As(r),y=As(n);for(let t=0;t+4<=h.length;t+=4){y[t+0]=h[t+0]^o,y[t+1]=h[t+1]^c,y[t+2]=h[t+2]^u,y[t+3]=h[t+3]^l;let r=1;for(let e=s.length-1;e>=0;e--)r=r+(255&s[e])|0,s[e]=255&r,r>>>=8;({s0:o,s1:c,s2:u,s3:l}=sa(e,a[0],a[1],a[2],a[3]))}const p=js*Math.floor(h.length/4);if(p<i){const e=new Uint32Array([o,c,u,l]),t=ks(e);for(let e=p,s=0;e<i;e++,s++)n[e]=r[e]^t[s];Ss(e)}return n}function ca(e,t,r,n,i){ms(r,js),ms(n),i=Cs(n.length,i);const s=r,a=As(s),o=Es(s),c=As(n),u=As(i),l=t?0:12,h=n.length;let y=o.getUint32(l,t),{s0:p,s1:d,s2:f,s3:g}=sa(e,a[0],a[1],a[2],a[3]);for(let r=0;r+4<=c.length;r+=4)u[r+0]=c[r+0]^p,u[r+1]=c[r+1]^d,u[r+2]=c[r+2]^f,u[r+3]=c[r+3]^g,y=y+1>>>0,o.setUint32(l,y,t),({s0:p,s1:d,s2:f,s3:g}=sa(e,a[0],a[1],a[2],a[3]));const w=js*Math.floor(c.length/4);if(w<h){const e=new Uint32Array([p,d,f,g]),t=ks(e);for(let e=w,r=0;e<h;e++,r++)i[e]=n[e]^t[r];Ss(e)}return i}const ua=_s({blockSize:16,nonceLength:16},function(e,t){function r(r,n){if(ms(r),void 0!==n&&(ms(n),!Ts(n)))throw Error("unaligned destination");const i=ta(e),s=Bs(t),a=[i,s];Ts(r)||a.push(r=Bs(r));const o=oa(i,s,r,n);return Ss(...a),o}return{encrypt:(e,t)=>r(e,t),decrypt:(e,t)=>r(e,t)}}),la=_s({blockSize:16,nonceLength:16},function(e,t,r={}){const n=!r.disablePadding;return{encrypt(r,i){const s=ta(e),{b:a,o,out:c}=function(e,t,r){ms(e);let n=e.length;const i=n%js;if(!t&&0!==i)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");Ts(e)||(e=Bs(e));const s=As(e);if(t){let e=js-i;e||(e=js),n+=e}return Ds(e,r=Cs(n,r)),{b:s,o:As(r),out:r}}(r,n,i);let u=t;const l=[s];Ts(u)||l.push(u=Bs(u));const h=As(u);let y=h[0],p=h[1],d=h[2],f=h[3],g=0;for(;g+4<=a.length;)y^=a[g+0],p^=a[g+1],d^=a[g+2],f^=a[g+3],({s0:y,s1:p,s2:d,s3:f}=sa(s,y,p,d,f)),o[g++]=y,o[g++]=p,o[g++]=d,o[g++]=f;if(n){const e=function(e){const t=new Uint8Array(16),r=As(t);t.set(e);const n=js-e.length;for(let e=js-n;e<js;e++)t[e]=n;return r}(r.subarray(4*g));y^=e[0],p^=e[1],d^=e[2],f^=e[3],({s0:y,s1:p,s2:d,s3:f}=sa(s,y,p,d,f)),o[g++]=y,o[g++]=p,o[g++]=d,o[g++]=f}return Ss(...l),c},decrypt(r,i){!function(e){if(ms(e),e.length%js!=0)throw Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size 16")}(r);const s=ra(e);let a=t;const o=[s];Ts(a)||o.push(a=Bs(a));const c=As(a);i=Cs(r.length,i),Ts(r)||o.push(r=Bs(r)),Ds(r,i);const u=As(r),l=As(i);let h=c[0],y=c[1],p=c[2],d=c[3];for(let e=0;e+4<=u.length;){const t=h,r=y,n=p,i=d;h=u[e+0],y=u[e+1],p=u[e+2],d=u[e+3];const{s0:a,s1:o,s2:c,s3:f}=aa(s,h,y,p,d);l[e++]=a^t,l[e++]=o^r,l[e++]=c^n,l[e++]=f^i}return Ss(...o),function(e,t){if(!t)return e;const r=e.length;if(!r)throw Error("aes/pcks5: empty ciphertext not allowed");const n=e[r-1];if(n<=0||n>16)throw Error("aes/pcks5: wrong padding");const i=e.subarray(0,-n);for(let t=0;t<n;t++)if(e[r-t-1]!==n)throw Error("aes/pcks5: wrong padding");return i}(i,n)}}}),ha=_s({blockSize:16,nonceLength:16},function(e,t){function r(r,n,i){ms(r);const s=r.length;if(Us(r,i=Cs(s,i)))throw Error("overlapping src and dst not supported.");const a=ta(e);let o=t;const c=[a];Ts(o)||c.push(o=Bs(o)),Ts(r)||c.push(r=Bs(r));const u=As(r),l=As(i),h=n?l:u,y=As(o);let p=y[0],d=y[1],f=y[2],g=y[3];for(let e=0;e+4<=u.length;){const{s0:t,s1:r,s2:n,s3:i}=sa(a,p,d,f,g);l[e+0]=u[e+0]^t,l[e+1]=u[e+1]^r,l[e+2]=u[e+2]^n,l[e+3]=u[e+3]^i,p=h[e++],d=h[e++],f=h[e++],g=h[e++]}const w=js*Math.floor(u.length/4);if(w<s){({s0:p,s1:d,s2:f,s3:g}=sa(a,p,d,f,g));const e=ks(new Uint32Array([p,d,f,g]));for(let t=w,n=0;t<s;t++,n++)i[t]=r[t]^e[n];Ss(e)}return Ss(...c),i}return{encrypt:(e,t)=>r(e,!0,t),decrypt:(e,t)=>r(e,!1,t)}}),ya=_s({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},function(e,t,r){if(t.length<8)throw Error("aes/gcm: invalid nonce length");function n(e,t,n){const i=function(e,t,r,n,i){const s=i?i.length:0,a=e.create(r,n.length+s);i&&a.update(i);const o=function(e,t,r){const n=new Uint8Array(16),i=Es(n);return Is(i,0,BigInt(t),r),Is(i,8,BigInt(e),r),n}(8*n.length,8*s,!1);a.update(n),a.update(o);const c=a.digest();return Ss(o),c}(zs,0,e,n,r);for(let e=0;e<t.length;e++)i[e]^=t[e];return i}function i(){const r=ta(e),n=Hs.slice(),i=Hs.slice();if(ca(r,!1,i,i,n),12===t.length)i.set(t);else{const e=Hs.slice();Is(Es(e),8,BigInt(8*t.length),!1);const r=zs.create(n).update(t).update(e);r.digestInto(i),r.destroy()}return{xk:r,authKey:n,counter:i,tagMask:ca(r,!1,i,Hs)}}return{encrypt(e){const{xk:t,authKey:r,counter:s,tagMask:a}=i(),o=new Uint8Array(e.length+16),c=[t,r,s,a];Ts(e)||c.push(e=Bs(e)),ca(t,!1,s,e,o.subarray(0,e.length));const u=n(r,a,o.subarray(0,o.length-16));return c.push(u),o.set(u,e.length),Ss(...c),o},decrypt(e){const{xk:t,authKey:r,counter:s,tagMask:a}=i(),o=[t,r,a,s];Ts(e)||o.push(e=Bs(e));const c=e.subarray(0,-16),u=e.subarray(-16),l=n(r,a,c);if(o.push(l),!xs(l,u))throw Error("aes/gcm: invalid ghash tag");const h=ca(t,!1,s,c);return Ss(...o),h}}});function pa(e){return e instanceof Uint32Array||ArrayBuffer.isView(e)&&"Uint32Array"===e.constructor.name}function da(e,t){if(ms(t,16),!pa(e))throw Error("_encryptBlock accepts result of expandKeyLE");const r=As(t);let{s0:n,s1:i,s2:s,s3:a}=sa(e,r[0],r[1],r[2],r[3]);return r[0]=n,r[1]=i,r[2]=s,r[3]=a,t}function fa(e,t){if(ms(t,16),!pa(e))throw Error("_decryptBlock accepts result of expandKeyLE");const r=As(t);let{s0:n,s1:i,s2:s,s3:a}=aa(e,r[0],r[1],r[2],r[3]);return r[0]=n,r[1]=i,r[2]=s,r[3]=a,t}const ga={encrypt(e,t){if(t.length>=2**32)throw Error("plaintext should be less than 4gb");const r=ta(e);if(16===t.length)da(r,t);else{const e=As(t);let n=e[0],i=e[1];for(let t=0,s=1;t<6;t++)for(let t=2;t<e.length;t+=2,s++){const{s0:a,s1:o,s2:c,s3:u}=sa(r,n,i,e[t],e[t+1]);n=a,i=o^Qs(s),e[t]=c,e[t+1]=u}e[0]=n,e[1]=i}r.fill(0)},decrypt(e,t){if(t.length-8>=2**32)throw Error("ciphertext should be less than 4gb");const r=ra(e),n=t.length/8-1;if(1===n)fa(r,t);else{const e=As(t);let i=e[0],s=e[1];for(let t=0,a=6*n;t<6;t++)for(let t=2*n;t>=1;t-=2,a--){s^=Qs(a);const{s0:n,s1:o,s2:c,s3:u}=aa(r,i,s,e[t],e[t+1]);i=n,s=o,e[t]=c,e[t+1]=u}e[0]=i,e[1]=s}r.fill(0)}},wa=new Uint8Array(8).fill(166),ma=_s({blockSize:8},e=>({encrypt(t){if(!t.length||t.length%8!=0)throw Error("invalid plaintext length");if(8===t.length)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");const r=function(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];ms(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const i=e[t];r.set(i,n),n+=i.length}return r}(wa,t);return ga.encrypt(e,r),r},decrypt(t){if(t.length%8!=0||t.length<24)throw Error("invalid ciphertext length");const r=Bs(t);if(ga.decrypt(e,r),!xs(r.subarray(0,8),wa))throw Error("integrity check failed");return r.subarray(0,8).fill(0),r.subarray(8)}})),ba={expandKeyLE:ta,expandKeyDecLE:ra,encrypt:sa,decrypt:aa,encryptBlock:da,decryptBlock:fa,ctrCounter:oa,ctr32:ca};async function va(e){switch(e){case qn.symmetric.aes128:case qn.symmetric.aes192:case qn.symmetric.aes256:throw Error("Not a legacy cipher");case qn.symmetric.cast5:case qn.symmetric.blowfish:case qn.symmetric.twofish:case qn.symmetric.tripledes:{const{legacyCiphers:t}=await i.e(464).then(i.bind(i,464)),r=qn.read(qn.symmetric,e),n=t.get(r);if(!n)throw Error("Unsupported cipher algorithm");return n}default:throw Error("Unsupported cipher algorithm")}}function ka(e){switch(e){case qn.symmetric.aes128:case qn.symmetric.aes192:case qn.symmetric.aes256:case qn.symmetric.twofish:return 16;case qn.symmetric.blowfish:case qn.symmetric.cast5:case qn.symmetric.tripledes:return 8;default:throw Error("Unsupported cipher")}}function Aa(e){switch(e){case qn.symmetric.aes128:case qn.symmetric.blowfish:case qn.symmetric.cast5:return 16;case qn.symmetric.aes192:case qn.symmetric.tripledes:return 24;case qn.symmetric.aes256:case qn.symmetric.twofish:return 32;default:throw Error("Unsupported cipher")}}function Sa(e){return{keySize:Aa(e),blockSize:ka(e)}}const Ea=Xn.getWebCrypto();async function Ka(e,t,r){const{keySize:n}=Sa(e);if(!Xn.isAES(e)||t.length!==n)throw Error("Unexpected algorithm or key size");try{const e=await Ea.importKey("raw",t,{name:"AES-KW"},!1,["wrapKey"]),n=await Ea.importKey("raw",r,{name:"HMAC",hash:"SHA-256"},!0,["sign"]),i=await Ea.wrapKey("raw",n,e,{name:"AES-KW"});return new Uint8Array(i)}catch(e){if("NotSupportedError"!==e.name&&(24!==t.length||"OperationError"!==e.name))throw e;Xn.printDebugError("Browser did not support operation: "+e.message)}return ma(t).encrypt(r)}async function Pa(e,t,r){const{keySize:n}=Sa(e);if(!Xn.isAES(e)||t.length!==n)throw Error("Unexpected algorithm or key size");let i;try{i=await Ea.importKey("raw",t,{name:"AES-KW"},!1,["unwrapKey"])}catch(e){if("NotSupportedError"!==e.name&&(24!==t.length||"OperationError"!==e.name))throw e;return Xn.printDebugError("Browser did not support operation: "+e.message),ma(t).decrypt(r)}try{const e=await Ea.unwrapKey("raw",r,i,{name:"AES-KW"},{name:"HMAC",hash:"SHA-256"},!0,["sign"]);return new Uint8Array(await Ea.exportKey("raw",e))}catch(e){if("OperationError"===e.name)throw Error("Key Data Integrity failed");throw e}}async function Ua(e,t,r,n,i){const s=Xn.getWebCrypto(),a=qn.read(qn.webHash,e);if(!a)throw Error("Hash algo not supported with HKDF");const o=await s.importKey("raw",t,"HKDF",!1,["deriveBits"]),c=await s.deriveBits({name:"HKDF",hash:a,salt:r,info:n},o,8*i);return new Uint8Array(c)}const Da={x25519:Xn.encodeUTF8("OpenPGP X25519"),x448:Xn.encodeUTF8("OpenPGP X448")};function xa(e){switch(e){case qn.publicKey.x25519:return 32;case qn.publicKey.x448:return 56;default:throw Error("Unsupported ECDH algorithm")}}async function _a(e,t){switch(e){case qn.publicKey.x25519:try{const r=Xn.getWebCrypto(),n=await r.generateKey("X25519",!0,["deriveKey","deriveBits"]).catch(e=>{if("OperationError"===e.name){const e=Error("Unexpected key generation issue");throw e.name="NotSupportedError",e}throw e}),i=await r.exportKey("jwk",n.publicKey);if((await r.exportKey("jwk",n.privateKey)).x!==i.x){const e=Error("Unexpected mismatching public point");throw e.name="NotSupportedError",e}const s=Ta(e,t),a=await r.importKey("jwk",s,"X25519",!1,[]),o=await r.deriveBits({name:"X25519",public:a},n.privateKey,8*xa(e));return{sharedSecret:new Uint8Array(o),ephemeralPublicKey:new Uint8Array(ti(i.x))}}catch(e){if("NotSupportedError"!==e.name)throw e;const{default:r}=await i.e(837).then(i.bind(i,837)),{secretKey:n,publicKey:s}=r.box.keyPair(),a=r.scalarMult(n,t);return Ia(a),{ephemeralPublicKey:s,sharedSecret:a}}case qn.publicKey.x448:{const e=await Xn.getNobleCurve(qn.publicKey.x448),{secretKey:r,publicKey:n}=e.keygen(),i=e.getSharedSecret(r,t);return Ia(i),{ephemeralPublicKey:n,sharedSecret:i}}default:throw Error("Unsupported ECDH algorithm")}}async function Ca(e,t,r,n){switch(e){case qn.publicKey.x25519:try{const i=Xn.getWebCrypto(),s=function(e,t,r){if(e===qn.publicKey.x25519){const n=Ta(e,t);return n.d=ri(r),n}throw Error("Unsupported ECDH algorithm")}(e,r,n),a=Ta(e,t),o=await i.importKey("jwk",s,"X25519",!1,["deriveKey","deriveBits"]),c=await i.importKey("jwk",a,"X25519",!1,[]),u=await i.deriveBits({name:"X25519",public:c},o,8*xa(e));return new Uint8Array(u)}catch(e){if("NotSupportedError"!==e.name)throw e;const{default:r}=await i.e(837).then(i.bind(i,837)),s=r.scalarMult(n,t);return Ia(s),s}case qn.publicKey.x448:{const e=(await Xn.getNobleCurve(qn.publicKey.x448)).getSharedSecret(n,t);return Ia(e),e}default:throw Error("Unsupported ECDH algorithm")}}function Ia(e){let t=0;for(let r=0;r<e.length;r++)t|=e[r];if(0===t)throw Error("Unexpected low order point")}function Ta(e,t){if(e===qn.publicKey.x25519)return{kty:"OKP",crv:"X25519",x:ri(t),ext:!0};throw Error("Unsupported ECDH algorithm")}const Ba=Xn.getWebCrypto(),$a=Xn.getNodeCrypto(),La={[qn.curve.nistP256]:"P-256",[qn.curve.nistP384]:"P-384",[qn.curve.nistP521]:"P-521"},Na=$a?$a.getCurves():[],Ma=$a?{[qn.curve.secp256k1]:Na.includes("secp256k1")?"secp256k1":void 0,[qn.curve.nistP256]:Na.includes("prime256v1")?"prime256v1":void 0,[qn.curve.nistP384]:Na.includes("secp384r1")?"secp384r1":void 0,[qn.curve.nistP521]:Na.includes("secp521r1")?"secp521r1":void 0,[qn.curve.ed25519Legacy]:Na.includes("ED25519")?"ED25519":void 0,[qn.curve.curve25519Legacy]:Na.includes("X25519")?"X25519":void 0,[qn.curve.brainpoolP256r1]:Na.includes("brainpoolP256r1")?"brainpoolP256r1":void 0,[qn.curve.brainpoolP384r1]:Na.includes("brainpoolP384r1")?"brainpoolP384r1":void 0,[qn.curve.brainpoolP512r1]:Na.includes("brainpoolP512r1")?"brainpoolP512r1":void 0}:{},Ra={[qn.curve.nistP256]:{oid:[6,8,42,134,72,206,61,3,1,7],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha256,cipher:qn.symmetric.aes128,node:Ma[qn.curve.nistP256],web:La[qn.curve.nistP256],payloadSize:32,sharedSize:256,wireFormatLeadingByte:4},[qn.curve.nistP384]:{oid:[6,5,43,129,4,0,34],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha384,cipher:qn.symmetric.aes192,node:Ma[qn.curve.nistP384],web:La[qn.curve.nistP384],payloadSize:48,sharedSize:384,wireFormatLeadingByte:4},[qn.curve.nistP521]:{oid:[6,5,43,129,4,0,35],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha512,cipher:qn.symmetric.aes256,node:Ma[qn.curve.nistP521],web:La[qn.curve.nistP521],payloadSize:66,sharedSize:528,wireFormatLeadingByte:4},[qn.curve.secp256k1]:{oid:[6,5,43,129,4,0,10],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha256,cipher:qn.symmetric.aes128,node:Ma[qn.curve.secp256k1],payloadSize:32,wireFormatLeadingByte:4},[qn.curve.ed25519Legacy]:{oid:[6,9,43,6,1,4,1,218,71,15,1],keyType:qn.publicKey.eddsaLegacy,hash:qn.hash.sha512,node:!1,payloadSize:32,wireFormatLeadingByte:64},[qn.curve.curve25519Legacy]:{oid:[6,10,43,6,1,4,1,151,85,1,5,1],keyType:qn.publicKey.ecdh,hash:qn.hash.sha256,cipher:qn.symmetric.aes128,node:!1,payloadSize:32,wireFormatLeadingByte:64},[qn.curve.brainpoolP256r1]:{oid:[6,9,43,36,3,3,2,8,1,1,7],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha256,cipher:qn.symmetric.aes128,node:Ma[qn.curve.brainpoolP256r1],payloadSize:32,wireFormatLeadingByte:4},[qn.curve.brainpoolP384r1]:{oid:[6,9,43,36,3,3,2,8,1,1,11],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha384,cipher:qn.symmetric.aes192,node:Ma[qn.curve.brainpoolP384r1],payloadSize:48,wireFormatLeadingByte:4},[qn.curve.brainpoolP512r1]:{oid:[6,9,43,36,3,3,2,8,1,1,13],keyType:qn.publicKey.ecdsa,hash:qn.hash.sha512,cipher:qn.symmetric.aes256,node:Ma[qn.curve.brainpoolP512r1],payloadSize:64,wireFormatLeadingByte:4}};class Fa{constructor(e){try{this.name=e instanceof Ji?e.getName():qn.write(qn.curve,e)}catch(e){throw new os("Unknown curve")}const t=Ra[this.name];this.keyType=t.keyType,this.oid=t.oid,this.hash=t.hash,this.cipher=t.cipher,this.node=t.node,this.web=t.web,this.payloadSize=t.payloadSize,this.sharedSize=t.sharedSize,this.wireFormatLeadingByte=t.wireFormatLeadingByte,this.web&&Xn.getWebCrypto()?this.type="web":this.node&&Xn.getNodeCrypto()?this.type="node":this.name===qn.curve.curve25519Legacy?this.type="curve25519Legacy":this.name===qn.curve.ed25519Legacy&&(this.type="ed25519Legacy")}async genKeyPair(){switch(this.type){case"web":try{return await async function(e,t){const r=await Ba.generateKey({name:"ECDSA",namedCurve:La[e]},!0,["sign","verify"]),n=await Ba.exportKey("jwk",r.privateKey);return{publicKey:ja(await Ba.exportKey("jwk",r.publicKey),t),privateKey:ti(n.d)}}(this.name,this.wireFormatLeadingByte)}catch(e){return Xn.printDebugError("Browser did not support generating ec key "+e.message),za(this.name)}case"node":return async function(e){const t=$a.createECDH(Ma[e]);return await t.generateKeys(),{publicKey:new Uint8Array(t.getPublicKey()),privateKey:new Uint8Array(t.getPrivateKey())}}(this.name);case"curve25519Legacy":{const{k:e,A:t}=await async function(e){switch(e){case qn.publicKey.x25519:try{const e=Xn.getWebCrypto(),t=await e.generateKey("X25519",!0,["deriveKey","deriveBits"]).catch(e=>{if("OperationError"===e.name){const e=Error("Unexpected key generation issue");throw e.name="NotSupportedError",e}throw e}),r=await e.exportKey("jwk",t.privateKey),n=await e.exportKey("jwk",t.publicKey);if(r.x!==n.x){const e=Error("Unexpected mismatching public point");throw e.name="NotSupportedError",e}return{A:new Uint8Array(ti(n.x)),k:ti(r.d)}}catch(e){if("NotSupportedError"!==e.name)throw e;const{default:t}=await i.e(837).then(i.bind(i,837)),{secretKey:r,publicKey:n}=t.box.keyPair();return{A:n,k:r}}case qn.publicKey.x448:{const e=await Xn.getNobleCurve(qn.publicKey.x448),{secretKey:t,publicKey:r}=e.keygen();return{A:r,k:t}}default:throw Error("Unsupported ECDH algorithm")}}(qn.publicKey.x25519),r=e.slice().reverse();return r[0]=127&r[0]|64,r[31]&=248,{publicKey:Xn.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),t]),privateKey:r}}case"ed25519Legacy":{const{seed:e,A:t}=await async function(e){switch(e){case qn.publicKey.ed25519:try{const e=Xn.getWebCrypto(),t=await e.generateKey("Ed25519",!0,["sign","verify"]).catch(e=>{if("OperationError"===e.name){const e=Error("Unexpected key generation issue");throw e.name="NotSupportedError",e}throw e}),r=await e.exportKey("jwk",t.privateKey),n=await e.exportKey("jwk",t.publicKey);return{A:new Uint8Array(ti(n.x)),seed:ti(r.d)}}catch(t){if("NotSupportedError"!==t.name)throw t;const{default:r}=await i.e(837).then(i.bind(i,837)),n=Ai(ps(e)),{publicKey:s}=r.sign.keyPair.fromSeed(n);return{A:s,seed:n}}case qn.publicKey.ed448:{const e=await Xn.getNobleCurve(qn.publicKey.ed448),{secretKey:t,publicKey:r}=e.keygen();return{A:r,seed:t}}default:throw Error("Unsupported EdDSA algorithm")}}(qn.publicKey.ed25519);return{publicKey:Xn.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),t]),privateKey:e}}default:return za(this.name)}}}function Oa(e,t){const{payloadSize:r,wireFormatLeadingByte:n,name:i}=e,s=i===qn.curve.curve25519Legacy||i===qn.curve.ed25519Legacy?r:2*r;if(t[0]!==n||t.length!==s+1)throw Error("Invalid point encoding")}async function za(e){const t=await Xn.getNobleCurve(qn.publicKey.ecdsa,e),{secretKey:r}=t.keygen();return{publicKey:t.getPublicKey(r,!1),privateKey:r}}function ja(e,t){const r=ti(e.x),n=ti(e.y),i=new Uint8Array(r.length+n.length+1);return i[0]=t,i.set(r,1),i.set(n,r.length+1),i}function Ha(e,t,r){const n=e,i=r.slice(1,n+1),s=r.slice(n+1,2*n+1);return{kty:"EC",crv:t,x:ri(i),y:ri(s),ext:!0}}function Ga(e,t,r,n){const i=Ha(e,t,r);return i.d=ri(n),i}const qa=Xn.getWebCrypto(),Wa=Xn.getNodeCrypto();async function Va(e,t,r,n){return(await Xn.getNobleCurve(qn.publicKey.ecdsa,e.name)).verify(Xn.concatUint8Array([t.r,t.s]),r,n,{lowS:!1})}function Xa(e){const t=e.length;if(t>0){const r=e[t-1];if(r>=1){const n=e.subarray(t-r),i=new Uint8Array(r).fill(r);if(Xn.equalsUint8Array(n,i))return e.subarray(0,t-r)}}throw Error("Invalid padding")}function Qa(e,t,r,n){return Xn.concatUint8Array([t.write(),new Uint8Array([e]),r.write(),Xn.stringToUint8Array("Anonymous Sender    "),n])}async function Ya(e,t,r,n,i=!1,s=!1){let a;if(i){for(a=0;a<t.length&&0===t[a];a++);t=t.subarray(a)}if(s){for(a=t.length-1;a>=0&&0===t[a];a--);t=t.subarray(0,a+1)}return(await Mi(e,Xn.concatUint8Array([new Uint8Array([0,0,0,1]),t,n]))).subarray(0,r)}async function Za(e,t,r){return{secretKey:r,sharedKey:(await Xn.getNobleCurve(qn.publicKey.ecdh,e.name)).getSharedSecret(r,t).subarray(1)}}async function Ja(e,t){const r=await Xn.getNobleCurve(qn.publicKey.ecdh,e.name),{publicKey:n,privateKey:i}=await e.genKeyPair();return{publicKey:n,sharedKey:r.getSharedSecret(i,t).subarray(1)}}const eo=BigInt(0),to=BigInt(1);class ro{constructor(e){e&&(this.data=e)}read(e){if(e.length>=1){const t=e[0];if(e.length>=1+t)return this.data=e.subarray(1,1+t),1+this.data.length}throw Error("Invalid symmetric key")}write(){return Xn.concatUint8Array([new Uint8Array([this.data.length]),this.data])}}class no{constructor(e){if(e){const{hash:t,cipher:r}=e;this.hash=t,this.cipher=r}else this.hash=null,this.cipher=null}read(e){if(e.length<4||3!==e[0]||1!==e[1])throw new os("Cannot read KDFParams");return this.hash=e[2],this.cipher=e[3],4}write(){return new Uint8Array([3,1,this.hash,this.cipher])}}class io{static fromObject({wrappedKey:e,algorithm:t}){const r=new io;return r.wrappedKey=e,r.algorithm=t,r}read(e){let t=0,r=e[t++];this.algorithm=r%2?e[t++]:null,r-=r%2,this.wrappedKey=Xn.readExactSubarray(e,t,t+r),t+=r}write(){return Xn.concatUint8Array([this.algorithm?new Uint8Array([this.wrappedKey.length+1,this.algorithm]):new Uint8Array([this.wrappedKey.length]),this.wrappedKey])}}async function so(e,t,r,n,i,s){switch(e){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaEncrypt:{const{c:e}=n,{n:i,e:a}=t,{d:o,p:c,q:u,u:l}=r;return async function(e,t,r,n,i,s,a,o){if(Xn.getNodeCrypto()&&!o)try{return await async function(e,t,r,n,i,s,a){const o={key:await Xi(t,r,n,i,s,a),format:"jwk",type:"pkcs1",padding:Gi.constants.RSA_PKCS1_PADDING};try{return new Uint8Array(Gi.privateDecrypt(o,e))}catch(e){throw Error("Decryption error")}}(e,t,r,n,i,s,a)}catch(e){Xn.printDebugError(e)}return async function(e,t,r,n,i,s,a,o){if(e=di(e),t=di(t),r=di(r),n=di(n),i=di(i),s=di(s),a=di(a),e>=t)throw Error("Data too large.");const c=fi(n,s-qi),u=fi(n,i-qi),l=Si(BigInt(2),t),h=gi(mi(l,t),r,t),y=gi(e=fi(e*h,t),u,i);let p=fi(a*(gi(e,c,s)-y),s)*i+y;return p=fi(p*l,t),zi(vi(p,"be",bi(t)),o)}(e,t,r,n,i,s,a,o)}(e,i,a,o,c,u,l,s)}case qn.publicKey.elgamal:{const{c1:e,c2:i}=n;return async function(e,t,r,n,i){return e=di(e),t=di(t),r=di(r),zi(vi(fi(mi(gi(e,n=di(n),r),r)*t,r),"be",bi(r)),i)}(e,i,t.p,r.x,s)}case qn.publicKey.ecdh:{const{oid:e,Q:s,kdfParams:a}=t,{d:o}=r,{V:c,C:u}=n;return async function(e,t,r,n,i,s,a){const o=new Fa(e);Oa(o,i),Oa(o,r);const{sharedKey:c}=await async function(e,t,r,n){if(n.length!==e.payloadSize){const t=new Uint8Array(e.payloadSize);t.set(n,e.payloadSize-n.length),n=t}switch(e.type){case"curve25519Legacy":{const e=n.slice().reverse();return{secretKey:e,sharedKey:await Ca(qn.publicKey.x25519,t.subarray(1),r.subarray(1),e)}}case"web":if(e.web&&Xn.getWebCrypto())try{return await async function(e,t,r,n){const i=Xn.getWebCrypto(),s=Ga(e.payloadSize,e.web,r,n);let a=i.importKey("jwk",s,{name:"ECDH",namedCurve:e.web},!0,["deriveKey","deriveBits"]);const o=Ha(e.payloadSize,e.web,t);let c=i.importKey("jwk",o,{name:"ECDH",namedCurve:e.web},!0,[]);[a,c]=await Promise.all([a,c]);let u=i.deriveBits({name:"ECDH",namedCurve:e.web,public:c},a,e.sharedSize),l=i.exportKey("jwk",a);[u,l]=await Promise.all([u,l]);const h=new Uint8Array(u);return{secretKey:ti(l.d),sharedKey:h}}(e,t,r,n)}catch(r){return Xn.printDebugError(r),Za(e,t,n)}break;case"node":return async function(e,t,r){const n=Xn.getNodeCrypto().createECDH(e.node);n.setPrivateKey(r);const i=new Uint8Array(n.computeSecret(t));return{secretKey:new Uint8Array(n.getPrivateKey()),sharedKey:i}}(e,t,n);default:return Za(e,t,n)}}(o,r,i,s),u=Qa(qn.publicKey.ecdh,e,t,a),{keySize:l}=Sa(t.cipher);let h;for(let r=0;r<3;r++)try{const e=await Ya(t.hash,c,l,u,1===r,2===r);return Xa(await Pa(t.cipher,e,n))}catch(e){h=e}throw h}(e,a,c,u.data,s,o,i)}case qn.publicKey.x25519:case qn.publicKey.x448:{const{A:i}=t,{k:s}=r,{ephemeralPublicKey:a,C:o}=n;if(null!==o.algorithm&&!Xn.isAES(o.algorithm))throw Error("AES session key expected");return async function(e,t,r,n,i){const s=await Ca(e,t,n,i),a=Xn.concatUint8Array([t,n,s]);switch(e){case qn.publicKey.x25519:{const e=qn.symmetric.aes128,{keySize:t}=Sa(e);return Pa(e,await Ua(qn.hash.sha256,a,new Uint8Array,Da.x25519,t),r)}case qn.publicKey.x448:{const e=qn.symmetric.aes256,{keySize:t}=Sa(qn.symmetric.aes256);return Pa(e,await Ua(qn.hash.sha512,a,new Uint8Array,Da.x448,t),r)}default:throw Error("Unsupported ECDH algorithm")}}(e,a,o.wrappedKey,i,s)}default:throw Error("Unknown public key encryption algorithm.")}}function ao(e,t){const r=new Set([qn.publicKey.ed25519,qn.publicKey.x25519,qn.publicKey.ed448,qn.publicKey.x448]),n=Object.keys(t).map(n=>{const i=t[n];return Xn.isUint8Array(i)?r.has(e)?i:Xn.uint8ArrayToMPI(i):i.write()});return Xn.concatUint8Array(n)}function oo(e){const{keySize:t}=Sa(e);return Ai(t)}function co(e){try{e.getName()}catch(e){throw new os("Unknown curve OID")}}function uo(e,t){switch(e){case qn.publicKey.ecdsa:case qn.publicKey.ecdh:case qn.publicKey.eddsaLegacy:return new Fa(t).payloadSize;case qn.publicKey.ed25519:case qn.publicKey.ed448:return ps(e);case qn.publicKey.x25519:case qn.publicKey.x448:return xa(e);default:throw Error("Unknown elliptic algo")}}const lo=Xn.getWebCrypto(),ho=Xn.getNodeCrypto(),yo=ho?ho.getCiphers():[],po={idea:yo.includes("idea-cfb")?"idea-cfb":void 0,tripledes:yo.includes("des-ede3-cfb")?"des-ede3-cfb":void 0,cast5:yo.includes("cast5-cfb")?"cast5-cfb":void 0,blowfish:yo.includes("bf-cfb")?"bf-cfb":void 0,aes128:yo.includes("aes-128-cfb")?"aes-128-cfb":void 0,aes192:yo.includes("aes-192-cfb")?"aes-192-cfb":void 0,aes256:yo.includes("aes-256-cfb")?"aes-256-cfb":void 0};async function fo(e){const{blockSize:t}=Sa(e),r=await Ai(t),n=new Uint8Array([r[r.length-2],r[r.length-1]]);return Xn.concat([r,n])}async function go(e,t,r,n,i){const s=qn.read(qn.symmetric,e);if(Xn.getNodeCrypto()&&po[s])return function(e,t,r,n){const i=qn.read(qn.symmetric,e),s=new ho.createCipheriv(po[i],t,n);return Tn(r,e=>new Uint8Array(s.update(e)))}(e,t,r,n);if(Xn.isAES(e))return async function(e,t,r,n){if(lo&&await mo.isSupported(e)){const i=new mo(e,t,n);return Xn.isStream(r)?Tn(r,e=>i.encryptChunk(e),()=>i.finish()):i.encrypt(r)}if(Xn.isStream(r)){const i=new bo(!0,e,t,n);return Tn(r,e=>i.processChunk(e),()=>i.finish())}return ha(t,n).encrypt(r)}(e,t,r,n);const a=new(await va(e))(t),o=a.blockSize,c=n.slice();let u=new Uint8Array;const l=e=>{e&&(u=Xn.concatUint8Array([u,e]));const t=new Uint8Array(u.length);let r,n=0;for(;e?u.length>=o:u.length;){const e=a.encrypt(c);for(r=0;r<o;r++)c[r]=u[r]^e[r],t[n++]=c[r];u=u.subarray(o)}return t.subarray(0,n)};return Tn(r,l,l)}async function wo(e,t,r,n){const i=qn.read(qn.symmetric,e);if(ho&&po[i])return function(e,t,r,n){const i=qn.read(qn.symmetric,e),s=new ho.createDecipheriv(po[i],t,n);return Tn(r,e=>new Uint8Array(s.update(e)))}(e,t,r,n);if(Xn.isAES(e))return async function(e,t,r,n){if(Xn.isStream(r)){const i=new bo(!1,e,t,n);return Tn(r,e=>i.processChunk(e),()=>i.finish())}return ha(t,n).decrypt(r)}(e,t,r,n);const s=new(await va(e))(t),a=s.blockSize;let o=n,c=new Uint8Array;const u=e=>{e&&(c=Xn.concatUint8Array([c,e]));const t=new Uint8Array(c.length);let r,n=0;for(;e?c.length>=a:c.length;){const e=s.encrypt(o);for(o=c.subarray(0,a),r=0;r<a;r++)t[n++]=o[r]^e[r];c=c.subarray(a)}return t.subarray(0,n)};return Tn(r,u,u)}class mo{constructor(e,t,r){const{blockSize:n}=Sa(e);this.key=t,this.prevBlock=r,this.nextBlock=new Uint8Array(n),this.i=0,this.blockSize=n,this.zeroBlock=new Uint8Array(this.blockSize)}static async isSupported(e){const{keySize:t}=Sa(e);return lo.importKey("raw",new Uint8Array(t),"aes-cbc",!1,["encrypt"]).then(()=>!0,()=>!1)}async _runCBC(e,t){const r="AES-CBC";this.keyRef=this.keyRef||await lo.importKey("raw",this.key,r,!1,["encrypt"]);const n=await lo.encrypt({name:r,iv:t||this.zeroBlock},this.keyRef,e);return new Uint8Array(n).subarray(0,e.length)}async encryptChunk(e){const t=this.nextBlock.length-this.i,r=e.subarray(0,t);if(this.nextBlock.set(r,this.i),this.i+e.length>=2*this.blockSize){const r=(e.length-t)%this.blockSize,n=Xn.concatUint8Array([this.nextBlock,e.subarray(t,e.length-r)]),i=Xn.concatUint8Array([this.prevBlock,n.subarray(0,n.length-this.blockSize)]),s=await this._runCBC(i);return vo(s,n),this.prevBlock=s.slice(-this.blockSize),r>0&&this.nextBlock.set(e.subarray(-r)),this.i=r,s}let n;if(this.i+=r.length,this.i===this.nextBlock.length){const t=this.nextBlock;n=await this._runCBC(this.prevBlock),vo(n,t),this.prevBlock=n.slice(),this.i=0;const i=e.subarray(r.length);this.nextBlock.set(i,this.i),this.i+=i.length}else n=new Uint8Array;return n}async finish(){let e;if(0===this.i)e=new Uint8Array;else{this.nextBlock=this.nextBlock.subarray(0,this.i);const t=this.nextBlock,r=await this._runCBC(this.prevBlock);vo(r,t),e=r.subarray(0,t.length)}return this.clearSensitiveData(),e}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.keyRef=null,this.key=null}async encrypt(e){const t=(await this._runCBC(Xn.concatUint8Array([new Uint8Array(this.blockSize),e]),this.iv)).subarray(0,e.length);return vo(t,e),this.clearSensitiveData(),t}}class bo{constructor(e,t,r,n){this.forEncryption=e;const{blockSize:i}=Sa(t);this.key=ba.expandKeyLE(r),n.byteOffset%4!=0&&(n=n.slice()),this.prevBlock=ko(n),this.nextBlock=new Uint8Array(i),this.i=0,this.blockSize=i}_runCFB(e){const t=ko(e),r=new Uint8Array(e.length),n=ko(r);for(let e=0;e+4<=n.length;e+=4){const{s0:r,s1:i,s2:s,s3:a}=ba.encrypt(this.key,this.prevBlock[0],this.prevBlock[1],this.prevBlock[2],this.prevBlock[3]);n[e+0]=t[e+0]^r,n[e+1]=t[e+1]^i,n[e+2]=t[e+2]^s,n[e+3]=t[e+3]^a,this.prevBlock=(this.forEncryption?n:t).slice(e,e+4)}return r}async processChunk(e){const t=this.nextBlock.length-this.i,r=e.subarray(0,t);if(this.nextBlock.set(r,this.i),this.i+e.length>=2*this.blockSize){const r=(e.length-t)%this.blockSize,n=Xn.concatUint8Array([this.nextBlock,e.subarray(t,e.length-r)]),i=this._runCFB(n);return r>0&&this.nextBlock.set(e.subarray(-r)),this.i=r,i}let n;if(this.i+=r.length,this.i===this.nextBlock.length){n=this._runCFB(this.nextBlock),this.i=0;const t=e.subarray(r.length);this.nextBlock.set(t,this.i),this.i+=t.length}else n=new Uint8Array;return n}async finish(){let e;return e=0===this.i?new Uint8Array:this._runCFB(this.nextBlock).subarray(0,this.i),this.clearSensitiveData(),e}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.key.fill(0)}}function vo(e,t){const r=Math.min(e.length,t.length);for(let n=0;n<r;n++)e[n]=e[n]^t[n]}const ko=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Ao=Xn.getWebCrypto(),So=Xn.getNodeCrypto(),Eo=16;function Ko(e,t){const r=e.length-Eo;for(let n=0;n<Eo;n++)e[n+r]^=t[n];return e}const Po=new Uint8Array(Eo);const Uo=Xn.getWebCrypto(),Do=Xn.getNodeCrypto(),xo=Xn.getNodeBuffer(),_o=new Uint8Array(16),Co=new Uint8Array(16);Co[15]=1;const Io=new Uint8Array(16);async function To(e){const t=await async function(e){const t=await async function(e){if(Xn.getNodeCrypto())return async function(t){const r=new So.createCipheriv("aes-"+8*e.length+"-cbc",e,Po).update(t);return new Uint8Array(r)};if(Xn.getWebCrypto())try{return e=await Ao.importKey("raw",e,{name:"AES-CBC",length:8*e.length},!1,["encrypt"]),async function(t){const r=await Ao.encrypt({name:"AES-CBC",iv:Po,length:128},e,t);return new Uint8Array(r).subarray(0,r.byteLength-Eo)}}catch(t){if("NotSupportedError"!==t.name&&(24!==e.length||"OperationError"!==t.name))throw t;Xn.printDebugError("Browser did not support operation: "+t.message)}return async function(t){return la(e,Po,{disablePadding:!0}).encrypt(t)}}(e),r=Xn.double(await t(Po)),n=Xn.double(r);return async function(e){return(await t(function(e,t,r){if(e.length&&e.length%Eo==0)return Ko(e,t);const n=new Uint8Array(e.length+(Eo-e.length%Eo));return n.set(e),n[e.length]=128,Ko(n,r)}(e,r,n))).subarray(-16)}}(e);return function(e,r){return t(Xn.concatUint8Array([e,r]))}}async function Bo(e){if(Xn.getNodeCrypto())return async function(t,r){const n=new Do.createCipheriv("aes-"+8*e.length+"-ctr",e,r),i=xo.concat([n.update(t),n.final()]);return new Uint8Array(i)};if(Xn.getWebCrypto())try{const t=await Uo.importKey("raw",e,{name:"AES-CTR",length:8*e.length},!1,["encrypt"]);return async function(e,r){const n=await Uo.encrypt({name:"AES-CTR",counter:r,length:128},t,e);return new Uint8Array(n)}}catch(t){if("NotSupportedError"!==t.name&&(24!==e.length||"OperationError"!==t.name))throw t;Xn.printDebugError("Browser did not support operation: "+t.message)}return async function(t,r){return ua(e,r).encrypt(t)}}async function $o(e,t){if(e!==qn.symmetric.aes128&&e!==qn.symmetric.aes192&&e!==qn.symmetric.aes256)throw Error("EAX mode supports only AES cipher");const[r,n]=await Promise.all([To(t),Bo(t)]);return{encrypt:async function(e,t,i){const[s,a]=await Promise.all([r(_o,t),r(Co,i)]),o=await n(e,s),c=await r(Io,o);for(let e=0;e<16;e++)c[e]^=a[e]^s[e];return Xn.concatUint8Array([o,c])},decrypt:async function(e,t,i){if(e.length<16)throw Error("Invalid EAX ciphertext");const s=e.subarray(0,-16),a=e.subarray(-16),[o,c,u]=await Promise.all([r(_o,t),r(Co,i),r(Io,s)]),l=u;for(let e=0;e<16;e++)l[e]^=c[e]^o[e];if(!Xn.equalsUint8Array(a,l))throw Error("Authentication tag mismatch");return await n(s,o)}}}Io[15]=2,$o.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[8+e]^=t[e];return r},$o.blockLength=16,$o.ivLength=16,$o.tagLength=16;const Lo=16;function No(e){let t=0;for(let r=1;!(e&r);r<<=1)t++;return t}function Mo(e,t){for(let r=0;r<e.length;r++)e[r]^=t[r];return e}function Ro(e,t){return Mo(e.slice(),t)}const Fo=new Uint8Array(Lo),Oo=new Uint8Array([1]);async function zo(e,t){const{keySize:r}=Sa(e);if(!Xn.isAES(e)||t.length!==r)throw Error("Unexpected algorithm or key size");let n=0;const i=e=>la(t,Fo,{disablePadding:!0}).encrypt(e),s=e=>la(t,Fo,{disablePadding:!0}).decrypt(e);let a;function o(e,t,r,s){const o=t.length/Lo|0;!function(e,t){const r=Xn.nbits(Math.max(e.length,t.length)/Lo|0)-1;for(let e=n+1;e<=r;e++)a[e]=Xn.double(a[e-1]);n=r}(t,s);const c=Xn.concatUint8Array([Fo.subarray(0,15-r.length),Oo,r]),u=63&c[15];c[15]&=192;const l=i(c),h=Xn.concatUint8Array([l,Ro(l.subarray(0,8),l.subarray(1,9))]),y=Xn.shiftRight(h.subarray(0+(u>>3),17+(u>>3)),8-(7&u)).subarray(1),p=new Uint8Array(Lo),d=new Uint8Array(t.length+16);let f,g=0;for(f=0;f<o;f++)Mo(y,a[No(f+1)]),d.set(Mo(e(Ro(y,t)),y),g),Mo(p,e===i?t:d.subarray(g)),t=t.subarray(Lo),g+=Lo;if(t.length){Mo(y,a.x);const r=i(y);d.set(Ro(t,r),g);const n=new Uint8Array(Lo);n.set(e===i?t:d.subarray(g,-16),0),n[t.length]=128,Mo(p,n),g+=t.length}const w=Mo(i(Mo(Mo(p,y),a.$)),function(e){if(!e.length)return Fo;const t=e.length/Lo|0,r=new Uint8Array(Lo),n=new Uint8Array(Lo);for(let s=0;s<t;s++)Mo(r,a[No(s+1)]),Mo(n,i(Ro(r,e))),e=e.subarray(Lo);if(e.length){Mo(r,a.x);const t=new Uint8Array(Lo);t.set(e,0),t[e.length]=128,Mo(t,r),Mo(n,i(t))}return n}(s));return d.set(w,g),d}return function(){const e=i(Fo),t=Xn.double(e);a=[],a[0]=Xn.double(t),a.x=e,a.$=t}(),{encrypt:async function(e,t,r){return o(i,e,t,r)},decrypt:async function(e,t,r){if(e.length<16)throw Error("Invalid OCB ciphertext");const n=e.subarray(-16);e=e.subarray(0,-16);const i=o(s,e,t,r);if(Xn.equalsUint8Array(n,i.subarray(-16)))return i.subarray(0,-16);throw Error("Authentication tag mismatch")}}}zo.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[7+e]^=t[e];return r},zo.blockLength=Lo,zo.ivLength=15,zo.tagLength=16;const jo=Xn.getWebCrypto(),Ho=Xn.getNodeCrypto(),Go=Xn.getNodeBuffer(),qo="AES-GCM";async function Wo(e,t){if(e!==qn.symmetric.aes128&&e!==qn.symmetric.aes192&&e!==qn.symmetric.aes256)throw Error("GCM mode supports only AES cipher");if(Xn.getNodeCrypto())return{encrypt:async function(e,r,n=new Uint8Array){const i=new Ho.createCipheriv("aes-"+8*t.length+"-gcm",t,r);i.setAAD(n);const s=Go.concat([i.update(e),i.final(),i.getAuthTag()]);return new Uint8Array(s)},decrypt:async function(e,r,n=new Uint8Array){const i=new Ho.createDecipheriv("aes-"+8*t.length+"-gcm",t,r);i.setAAD(n),i.setAuthTag(e.slice(e.length-16,e.length));const s=Go.concat([i.update(e.slice(0,e.length-16)),i.final()]);return new Uint8Array(s)}};if(Xn.getWebCrypto())try{const e=await jo.importKey("raw",t,{name:qo},!1,["encrypt","decrypt"]),r=navigator.userAgent.match(/Version\/13\.\d(\.\d)* Safari/)||navigator.userAgent.match(/Version\/(13|14)\.\d(\.\d)* Mobile\/\S* Safari/);return{encrypt:async function(n,i,s=new Uint8Array){if(r&&!n.length)return ya(t,i,s).encrypt(n);const a=await jo.encrypt({name:qo,iv:i,additionalData:s,tagLength:128},e,n);return new Uint8Array(a)},decrypt:async function(n,i,s=new Uint8Array){if(r&&16===n.length)return ya(t,i,s).decrypt(n);try{const t=await jo.decrypt({name:qo,iv:i,additionalData:s,tagLength:128},e,n);return new Uint8Array(t)}catch(e){if("OperationError"===e.name)throw Error("Authentication tag mismatch")}}}}catch(e){if("NotSupportedError"!==e.name&&(24!==t.length||"OperationError"!==e.name))throw e;Xn.printDebugError("Browser did not support operation: "+e.message)}return{encrypt:async function(e,r,n){return ya(t,r,n).encrypt(e)},decrypt:async function(e,r,n){return ya(t,r,n).decrypt(e)}}}function Vo(e,t=!1){switch(e){case qn.aead.eax:return $o;case qn.aead.ocb:return zo;case qn.aead.gcm:return Wo;case qn.aead.experimentalGCM:if(!t)throw Error("Unexpected non-standard `experimentalGCM` AEAD algorithm provided in `config.preferredAEADAlgorithm`: use `gcm` instead");return Wo;default:throw Error("Unsupported AEAD mode")}}async function Xo(e,t,r,n,i,s){switch(e){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaSign:{const{n:e,e:a}=n;return async function(e,t,r,n,i,s){if(t&&!Xn.isStream(t))if(Xn.getWebCrypto())try{return await async function(e,t,r,n,i){const s=Qi(n,i),a=await Hi.importKey("jwk",s,{name:"RSASSA-PKCS1-v1_5",hash:{name:e}},!1,["verify"]);return Hi.verify("RSASSA-PKCS1-v1_5",a,r,t)}(qn.read(qn.webHash,e),t,r,n,i)}catch(e){Xn.printDebugError(e)}else if(Xn.getNodeCrypto())return async function(e,t,r,n,i){const s={key:Qi(n,i),format:"jwk",type:"pkcs1"},a=Gi.createVerify(qn.read(qn.hash,e));a.write(t),a.end();try{return a.verify(s,r)}catch(e){return!1}}(e,t,r,n,i);return async function(e,t,r,n,i){if(r=di(r),t=di(t),n=di(n),t>=r)throw Error("Signature size cannot exceed modulus size");const s=vi(gi(t,n,r),"be",bi(r)),a=ji(e,i,bi(r));return Xn.equalsUint8Array(s,a)}(e,r,n,i,s)}(t,i,Xn.leftPad(r.s,e.length),e,a,s)}case qn.publicKey.dsa:{const{g:e,p:t,q:i,y:a}=n,{r:o,s:c}=r;return async function(e,t,r,n,i,s,a,o){if(t=di(t),r=di(r),s=di(s),a=di(a),i=di(i),o=di(o),t<=eo||t>=a||r<=eo||r>=a)return Xn.printDebug("invalid DSA Signature"),!1;const c=fi(di(n.subarray(0,bi(a))),a),u=mi(r,a);if(u===eo)return Xn.printDebug("invalid DSA Signature"),!1;i=fi(i,s),o=fi(o,s);const l=fi(c*u,a),h=fi(t*u,a);return fi(fi(gi(i,l,s)*gi(o,h,s),s),a)===t}(0,o,c,s,e,t,i,a)}case qn.publicKey.ecdsa:{const{oid:e,Q:a}=n,o=new Fa(e).payloadSize;return async function(e,t,r,n,i,s){const a=new Fa(e);Oa(a,i);const o=async()=>0===s[0]&&Va(a,r,s.subarray(1),i);if(n&&!Xn.isStream(n))switch(a.type){case"web":try{const e=await async function(e,t,{r,s:n},i,s){const a=Ha(e.payloadSize,La[e.name],s),o=await qa.importKey("jwk",a,{name:"ECDSA",namedCurve:La[e.name],hash:{name:qn.read(qn.webHash,e.hash)}},!1,["verify"]),c=Xn.concatUint8Array([r,n]).buffer;return qa.verify({name:"ECDSA",namedCurve:La[e.name],hash:{name:qn.read(qn.webHash,t)}},o,c,i)}(a,t,r,n,i);return e||o()}catch(e){if("nistP521"!==a.name&&("DataError"===e.name||"OperationError"===e.name))throw e;Xn.printDebugError("Browser did not support verifying: "+e.message)}break;case"node":{const e=await async function(e,t,{r,s:n},i,s){const a=Xn.nodeRequire("eckey-utils"),o=Xn.getNodeBuffer(),{publicKey:c}=a.generateDer({curveName:Ma[e.name],publicKey:o.from(s)}),u=Wa.createVerify(qn.read(qn.hash,t));u.write(i),u.end();const l=Xn.concatUint8Array([r,n]);try{return u.verify({key:c,format:"der",type:"spki",dsaEncoding:"ieee-p1363"},l)}catch(e){return!1}}(a,t,r,n,i);return e||o()}}return await Va(a,r,s,i)||o()}(e,t,{r:Xn.leftPad(r.r,o),s:Xn.leftPad(r.s,o)},i,a,s)}case qn.publicKey.eddsaLegacy:{const{oid:e,Q:i}=n,a=new Fa(e).payloadSize;return async function(e,t,{r,s:n},i,s,a){if(Oa(new Fa(e),s),Ri(t)<Ri(qn.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const o=Xn.concatUint8Array([r,n]);return ys(qn.publicKey.ed25519,t,{RS:o},0,s.subarray(1),a)}(e,t,{r:Xn.leftPad(r.r,a),s:Xn.leftPad(r.s,a)},0,i,s)}case qn.publicKey.ed25519:case qn.publicKey.ed448:{const{A:i}=n;return ys(e,t,r,0,i,s)}default:throw Error("Unknown signature algorithm.")}}Wo.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[4+e]^=t[e];return r},Wo.blockLength=16,Wo.ivLength=12,Wo.tagLength=16;class Qo extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,Qo),this.name="Argon2OutOfMemoryError"}}let Yo,Zo;class Jo{constructor(e=Wn){const{passes:t,parallelism:r,memoryExponent:n}=e.s2kArgon2Params;this.type="argon2",this.salt=null,this.t=t,this.p=r,this.encodedM=n}generateSalt(){this.salt=Ai(16)}read(e){let t=0;return this.salt=e.subarray(t,t+16),t+=16,this.t=e[t++],this.p=e[t++],this.encodedM=e[t++],t}write(){const e=[new Uint8Array([qn.write(qn.s2k,this.type)]),this.salt,new Uint8Array([this.t,this.p,this.encodedM])];return Xn.concatUint8Array(e)}async produceKey(e,t){const r=2<<this.encodedM-1;try{Yo=Yo||(await i.e(28).then(i.bind(i,28))).default,Zo=Zo||Yo();const n=(await Zo)({version:19,type:2,password:Xn.encodeUTF8(e),salt:this.salt,tagLength:t,memorySize:r,parallelism:this.p,passes:this.t});return r>1048576&&(Zo=Yo(),Zo.catch(()=>{})),n}catch(e){throw e.message&&(e.message.includes("Unable to grow instance memory")||e.message.includes("failed to grow memory")||e.message.includes("WebAssembly.Memory.grow")||e.message.includes("Out of memory"))?new Qo("Could not allocate required memory for Argon2"):e}}}class ec{constructor(e,t=Wn){this.algorithm=qn.hash.sha256,this.type=qn.read(qn.s2k,e),this.c=t.s2kIterationCountByte,this.salt=null}generateSalt(){switch(this.type){case"salted":case"iterated":this.salt=Ai(8)}}getCount(){return 16+(15&this.c)<<6+(this.c>>4)}read(e){let t=0;switch(this.algorithm=e[t++],this.type){case"simple":break;case"salted":this.salt=e.subarray(t,t+8),t+=8;break;case"iterated":this.salt=e.subarray(t,t+8),t+=8,this.c=e[t++];break;case"gnu":if("GNU"!==Xn.uint8ArrayToString(e.subarray(t,t+3)))throw new os("Unknown s2k type.");if(t+=3,1001!==1e3+e[t++])throw new os("Unknown s2k gnu protection mode.");this.type="gnu-dummy";break;default:throw new os("Unknown s2k type.")}return t}write(){if("gnu-dummy"===this.type)return new Uint8Array([101,0,...Xn.stringToUint8Array("GNU"),1]);const e=[new Uint8Array([qn.write(qn.s2k,this.type),this.algorithm])];switch(this.type){case"simple":break;case"salted":e.push(this.salt);break;case"iterated":e.push(this.salt),e.push(new Uint8Array([this.c]));break;case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}return Xn.concatUint8Array(e)}async produceKey(e,t){e=Xn.encodeUTF8(e);const r=[];let n=0,i=0;for(;n<t;){let t;switch(this.type){case"simple":t=Xn.concatUint8Array([new Uint8Array(i),e]);break;case"salted":t=Xn.concatUint8Array([new Uint8Array(i),this.salt,e]);break;case"iterated":{const r=Xn.concatUint8Array([this.salt,e]);let n=r.length;const s=Math.max(this.getCount(),n);t=new Uint8Array(i+s),t.set(r,i);for(let e=i+n;e<s;e+=n,n*=2)t.copyWithin(e,i,e);break}case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}const s=await Mi(this.algorithm,t);r.push(s),n+=s.length,i++}return Xn.concatUint8Array(r).subarray(0,t)}}const tc=new Set([qn.s2k.argon2,qn.s2k.iterated]);function rc(e,t=Wn){switch(e){case qn.s2k.argon2:return new Jo(t);case qn.s2k.iterated:case qn.s2k.gnu:case qn.s2k.salted:case qn.s2k.simple:return new ec(e,t);default:throw new os("Unsupported S2K type")}}var nc=Uint8Array,ic=Uint16Array,sc=Int32Array,ac=new nc([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),oc=new nc([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),cc=new nc([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),uc=function(e,t){for(var r=new ic(31),n=0;n<31;++n)r[n]=t+=1<<e[n-1];var i=new sc(r[30]);for(n=1;n<30;++n)for(var s=r[n];s<r[n+1];++s)i[s]=s-r[n]<<5|n;return{b:r,r:i}},lc=uc(ac,2),hc=lc.b,yc=lc.r;hc[28]=258,yc[258]=28;for(var pc=uc(oc,0),dc=pc.b,fc=pc.r,gc=new ic(32768),wc=0;wc<32768;++wc){var mc=(43690&wc)>>1|(21845&wc)<<1;mc=(61680&(mc=(52428&mc)>>2|(13107&mc)<<2))>>4|(3855&mc)<<4,gc[wc]=((65280&mc)>>8|(255&mc)<<8)>>1}var bc=function(e,t,r){for(var n=e.length,i=0,s=new ic(t);i<n;++i)e[i]&&++s[e[i]-1];var a,o=new ic(t);for(i=1;i<t;++i)o[i]=o[i-1]+s[i-1]<<1;if(r){a=new ic(1<<t);var c=15-t;for(i=0;i<n;++i)if(e[i])for(var u=i<<4|e[i],l=t-e[i],h=o[e[i]-1]++<<l,y=h|(1<<l)-1;h<=y;++h)a[gc[h]>>c]=u}else for(a=new ic(n),i=0;i<n;++i)e[i]&&(a[i]=gc[o[e[i]-1]++]>>15-e[i]);return a},vc=new nc(288);for(wc=0;wc<144;++wc)vc[wc]=8;for(wc=144;wc<256;++wc)vc[wc]=9;for(wc=256;wc<280;++wc)vc[wc]=7;for(wc=280;wc<288;++wc)vc[wc]=8;var kc=new nc(32);for(wc=0;wc<32;++wc)kc[wc]=5;var Ac=bc(vc,9,0),Sc=bc(vc,9,1),Ec=bc(kc,5,0),Kc=bc(kc,5,1),Pc=function(e){for(var t=e[0],r=1;r<e.length;++r)e[r]>t&&(t=e[r]);return t},Uc=function(e,t,r){var n=t/8|0;return(e[n]|e[n+1]<<8)>>(7&t)&r},Dc=function(e,t){var r=t/8|0;return(e[r]|e[r+1]<<8|e[r+2]<<16)>>(7&t)},xc=function(e){return(e+7)/8|0},_c=function(e,t,r){return(null==t||t<0)&&(t=0),(null==r||r>e.length)&&(r=e.length),new nc(e.subarray(t,r))},Cc=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Ic=function(e,t,r){var n=Error(t||Cc[e]);if(n.code=e,Error.captureStackTrace&&Error.captureStackTrace(n,Ic),!r)throw n;return n},Tc=function(e,t,r){r<<=7&t;var n=t/8|0;e[n]|=r,e[n+1]|=r>>8},Bc=function(e,t,r){r<<=7&t;var n=t/8|0;e[n]|=r,e[n+1]|=r>>8,e[n+2]|=r>>16},$c=function(e,t){for(var r=[],n=0;n<e.length;++n)e[n]&&r.push({s:n,f:e[n]});var i=r.length,s=r.slice();if(!i)return{t:zc,l:0};if(1==i){var a=new nc(r[0].s+1);return a[r[0].s]=1,{t:a,l:1}}r.sort(function(e,t){return e.f-t.f}),r.push({s:-1,f:25001});var o=r[0],c=r[1],u=0,l=1,h=2;for(r[0]={s:-1,f:o.f+c.f,l:o,r:c};l!=i-1;)o=r[r[u].f<r[h].f?u++:h++],c=r[u!=l&&r[u].f<r[h].f?u++:h++],r[l++]={s:-1,f:o.f+c.f,l:o,r:c};var y=s[0].s;for(n=1;n<i;++n)s[n].s>y&&(y=s[n].s);var p=new ic(y+1),d=Lc(r[l-1],p,0);if(d>t){n=0;var f=0,g=d-t,w=1<<g;for(s.sort(function(e,t){return p[t.s]-p[e.s]||e.f-t.f});n<i;++n){var m=s[n].s;if(!(p[m]>t))break;f+=w-(1<<d-p[m]),p[m]=t}for(f>>=g;f>0;){var b=s[n].s;p[b]<t?f-=1<<t-p[b]++-1:++n}for(;n>=0&&f;--n){var v=s[n].s;p[v]==t&&(--p[v],++f)}d=t}return{t:new nc(p),l:d}},Lc=function(e,t,r){return-1==e.s?Math.max(Lc(e.l,t,r+1),Lc(e.r,t,r+1)):t[e.s]=r},Nc=function(e){for(var t=e.length;t&&!e[--t];);for(var r=new ic(++t),n=0,i=e[0],s=1,a=function(e){r[n++]=e},o=1;o<=t;++o)if(e[o]==i&&o!=t)++s;else{if(!i&&s>2){for(;s>138;s-=138)a(32754);s>2&&(a(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(a(i),--s;s>6;s-=6)a(8304);s>2&&(a(s-3<<5|8208),s=0)}for(;s--;)a(i);s=1,i=e[o]}return{c:r.subarray(0,n),n:t}},Mc=function(e,t){for(var r=0,n=0;n<t.length;++n)r+=e[n]*t[n];return r},Rc=function(e,t,r){var n=r.length,i=xc(t+2);e[i]=255&n,e[i+1]=n>>8,e[i+2]=255^e[i],e[i+3]=255^e[i+1];for(var s=0;s<n;++s)e[i+s+4]=r[s];return 8*(i+4+n)},Fc=function(e,t,r,n,i,s,a,o,c,u,l){Tc(t,l++,r),++i[256];for(var h=$c(i,15),y=h.t,p=h.l,d=$c(s,15),f=d.t,g=d.l,w=Nc(y),m=w.c,b=w.n,v=Nc(f),k=v.c,A=v.n,S=new ic(19),E=0;E<m.length;++E)++S[31&m[E]];for(E=0;E<k.length;++E)++S[31&k[E]];for(var K=$c(S,7),P=K.t,U=K.l,D=19;D>4&&!P[cc[D-1]];--D);var x,_,C,I,T=u+5<<3,B=Mc(i,vc)+Mc(s,kc)+a,$=Mc(i,y)+Mc(s,f)+a+14+3*D+Mc(S,P)+2*S[16]+3*S[17]+7*S[18];if(c>=0&&T<=B&&T<=$)return Rc(t,l,e.subarray(c,c+u));if(Tc(t,l,1+($<B)),l+=2,$<B){x=bc(y,p,0),_=y,C=bc(f,g,0),I=f;var L=bc(P,U,0);for(Tc(t,l,b-257),Tc(t,l+5,A-1),Tc(t,l+10,D-4),l+=14,E=0;E<D;++E)Tc(t,l+3*E,P[cc[E]]);l+=3*D;for(var N=[m,k],M=0;M<2;++M){var R=N[M];for(E=0;E<R.length;++E){var F=31&R[E];Tc(t,l,L[F]),l+=P[F],F>15&&(Tc(t,l,R[E]>>5&127),l+=R[E]>>12)}}}else x=Ac,_=vc,C=Ec,I=kc;for(E=0;E<o;++E){var O=n[E];if(O>255){Bc(t,l,x[257+(F=O>>18&31)]),l+=_[F+257],F>7&&(Tc(t,l,O>>23&31),l+=ac[F]);var z=31&O;Bc(t,l,C[z]),l+=I[z],z>3&&(Bc(t,l,O>>5&8191),l+=oc[z])}else Bc(t,l,x[O]),l+=_[O]}return Bc(t,l,x[256]),l+_[256]},Oc=new sc([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),zc=new nc(0),jc=function(){var e=1,t=0;return{p:function(r){for(var n=e,i=t,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=n+=r[a];n=(65535&n)+15*(n>>16),i=(65535&i)+15*(i>>16)}e=n,t=i},d:function(){return(255&(e%=65521))<<24|(65280&e)<<8|(255&(t%=65521))<<8|t>>8}}},Hc=function(e,t,r,n,i){if(!i&&(i={l:1},t.dictionary)){var s=t.dictionary.subarray(-32768),a=new nc(s.length+e.length);a.set(s),a.set(e,s.length),e=a,i.w=s.length}return function(e,t,r,n,i,s){var a=s.z||e.length,o=new nc(n+a+5*(1+Math.ceil(a/7e3))+i),c=o.subarray(n,o.length-i),u=s.l,l=7&(s.r||0);if(t){l&&(c[0]=s.r>>3);for(var h=Oc[t-1],y=h>>13,p=8191&h,d=(1<<r)-1,f=s.p||new ic(32768),g=s.h||new ic(d+1),w=Math.ceil(r/3),m=2*w,b=function(t){return(e[t]^e[t+1]<<w^e[t+2]<<m)&d},v=new sc(25e3),k=new ic(288),A=new ic(32),S=0,E=0,K=s.i||0,P=0,U=s.w||0,D=0;K+2<a;++K){var x=b(K),_=32767&K,C=g[x];if(f[_]=C,g[x]=_,U<=K){var I=a-K;if((S>7e3||P>24576)&&(I>423||!u)){l=Fc(e,c,0,v,k,A,E,P,D,K-D,l),P=S=E=0,D=K;for(var T=0;T<286;++T)k[T]=0;for(T=0;T<30;++T)A[T]=0}var B=2,$=0,L=p,N=_-C&32767;if(I>2&&x==b(K-N))for(var M=Math.min(y,I)-1,R=Math.min(32767,K),F=Math.min(258,I);N<=R&&--L&&_!=C;){if(e[K+B]==e[K+B-N]){for(var O=0;O<F&&e[K+O]==e[K+O-N];++O);if(O>B){if(B=O,$=N,O>M)break;var z=Math.min(N,O-2),j=0;for(T=0;T<z;++T){var H=K-N+T&32767,G=H-f[H]&32767;G>j&&(j=G,C=H)}}}N+=(_=C)-(C=f[_])&32767}if($){v[P++]=268435456|yc[B]<<18|fc[$];var q=31&yc[B],W=31&fc[$];E+=ac[q]+oc[W],++k[257+q],++A[W],U=K+B,++S}else v[P++]=e[K],++k[e[K]]}}for(K=Math.max(K,U);K<a;++K)v[P++]=e[K],++k[e[K]];l=Fc(e,c,u,v,k,A,E,P,D,K-D,l),u||(s.r=7&l|c[l/8|0]<<3,l-=7,s.h=g,s.p=f,s.i=K,s.w=U)}else{for(K=s.w||0;K<a+u;K+=65535){var V=K+65535;V>=a&&(c[l/8|0]=u,V=a),l=Rc(c,l+1,e.subarray(K,V))}s.i=a}return _c(o,0,n+xc(l)+i)}(e,null==t.level?6:t.level,null==t.mem?i.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(e.length)))):20:12+t.mem,r,n,i)},Gc=function(e,t,r){for(;r;++t)e[t]=r,r>>>=8},qc=function(){function e(e,t){if("function"==typeof e&&(t=e,e={}),this.ondata=t,this.o=e||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new nc(98304),this.o.dictionary){var r=this.o.dictionary.subarray(-32768);this.b.set(r,32768-r.length),this.s.i=32768-r.length}}return e.prototype.p=function(e,t){this.ondata(Hc(e,this.o,0,0,this.s),t)},e.prototype.push=function(e,t){this.ondata||Ic(5),this.s.l&&Ic(4);var r=e.length+this.s.z;if(r>this.b.length){if(r>2*this.b.length-32768){var n=new nc(-32768&r);n.set(this.b.subarray(0,this.s.z)),this.b=n}var i=this.b.length-this.s.z;this.b.set(e.subarray(0,i),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(e.subarray(i),32768),this.s.z=e.length-i+32768,this.s.i=32766,this.s.w=32768}else this.b.set(e,this.s.z),this.s.z+=e.length;this.s.l=1&t,(this.s.z>this.s.w+8191||t)&&(this.p(this.b,t||!1),this.s.w=this.s.i,this.s.i-=2)},e.prototype.flush=function(){this.ondata||Ic(5),this.s.l&&Ic(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},e}(),Wc=function(){function e(e,t){"function"==typeof e&&(t=e,e={}),this.ondata=t;var r=e&&e.dictionary&&e.dictionary.subarray(-32768);this.s={i:0,b:r?r.length:0},this.o=new nc(32768),this.p=new nc(0),r&&this.o.set(r)}return e.prototype.e=function(e){if(this.ondata||Ic(5),this.d&&Ic(4),this.p.length){if(e.length){var t=new nc(this.p.length+e.length);t.set(this.p),t.set(e,this.p.length),this.p=t}}else this.p=e},e.prototype.c=function(e){this.s.i=+(this.d=e||!1);var t=this.s.b,r=function(e,t,r){var n=e.length;if(!n||t.f&&!t.l)return r||new nc(0);var i=!r,s=i||2!=t.i,a=t.i;i&&(r=new nc(3*n));var o=function(e){var t=r.length;if(e>t){var n=new nc(Math.max(2*t,e));n.set(r),r=n}},c=t.f||0,u=t.p||0,l=t.b||0,h=t.l,y=t.d,p=t.m,d=t.n,f=8*n;do{if(!h){c=Uc(e,u,1);var g=Uc(e,u+1,3);if(u+=3,!g){var w=e[(D=xc(u)+4)-4]|e[D-3]<<8,m=D+w;if(m>n){a&&Ic(0);break}s&&o(l+w),r.set(e.subarray(D,m),l),t.b=l+=w,t.p=u=8*m,t.f=c;continue}if(1==g)h=Sc,y=Kc,p=9,d=5;else if(2==g){var b=Uc(e,u,31)+257,v=Uc(e,u+10,15)+4,k=b+Uc(e,u+5,31)+1;u+=14;for(var A=new nc(k),S=new nc(19),E=0;E<v;++E)S[cc[E]]=Uc(e,u+3*E,7);u+=3*v;var K=Pc(S),P=(1<<K)-1,U=bc(S,K,1);for(E=0;E<k;){var D,x=U[Uc(e,u,P)];if(u+=15&x,(D=x>>4)<16)A[E++]=D;else{var _=0,C=0;for(16==D?(C=3+Uc(e,u,3),u+=2,_=A[E-1]):17==D?(C=3+Uc(e,u,7),u+=3):18==D&&(C=11+Uc(e,u,127),u+=7);C--;)A[E++]=_}}var I=A.subarray(0,b),T=A.subarray(b);p=Pc(I),d=Pc(T),h=bc(I,p,1),y=bc(T,d,1)}else Ic(1);if(u>f){a&&Ic(0);break}}s&&o(l+131072);for(var B=(1<<p)-1,$=(1<<d)-1,L=u;;L=u){var N=(_=h[Dc(e,u)&B])>>4;if((u+=15&_)>f){a&&Ic(0);break}if(_||Ic(2),N<256)r[l++]=N;else{if(256==N){L=u,h=null;break}var M=N-254;if(N>264){var R=ac[E=N-257];M=Uc(e,u,(1<<R)-1)+hc[E],u+=R}var F=y[Dc(e,u)&$],O=F>>4;if(F||Ic(3),u+=15&F,T=dc[O],O>3&&(R=oc[O],T+=Dc(e,u)&(1<<R)-1,u+=R),u>f){a&&Ic(0);break}s&&o(l+131072);var z=l+M;if(l<T){var j=0-T,H=Math.min(T,z);for(j+l<0&&Ic(3);l<H;++l)r[l]=(void 0)[j+l]}for(;l<z;++l)r[l]=r[l-T]}}t.l=h,t.p=L,t.b=l,t.f=c,h&&(c=1,t.m=p,t.d=y,t.n=d)}while(!c);return l!=r.length&&i?_c(r,0,l):r.subarray(0,l)}(this.p,this.s,this.o);this.ondata(_c(r,t,this.s.b),this.d),this.o=_c(r,this.s.b-32768),this.s.b=this.o.length,this.p=_c(this.p,this.s.p/8|0),this.s.p&=7},e.prototype.push=function(e,t){this.e(e),this.c(t)},e}(),Vc=function(){function e(e,t){this.c=jc(),this.v=1,qc.call(this,e,t)}return e.prototype.push=function(e,t){this.c.p(e),qc.prototype.push.call(this,e,t)},e.prototype.p=function(e,t){var r=Hc(e,this.o,this.v&&(this.o.dictionary?6:2),t&&4,this.s);this.v&&(function(e,t){var r=t.level,n=0==r?0:r<6?1:9==r?3:2;if(e[0]=120,e[1]=n<<6|(t.dictionary&&32),e[1]|=31-(e[0]<<8|e[1])%31,t.dictionary){var i=jc();i.p(t.dictionary),Gc(e,2,i.d())}}(r,this.o),this.v=0),t&&Gc(r,r.length-4,this.c.d()),this.ondata(r,t)},e.prototype.flush=function(){qc.prototype.flush.call(this)},e}(),Xc=function(){function e(e,t){Wc.call(this,e,t),this.v=e&&e.dictionary?2:1}return e.prototype.push=function(e,t){if(Wc.prototype.e.call(this,e),this.v){if(this.p.length<6&&!t)return;this.p=this.p.subarray((r=this.p,n=this.v-1,(8!=(15&r[0])||r[0]>>4>7||(r[0]<<8|r[1])%31)&&Ic(6,"invalid zlib data"),(r[1]>>5&1)==+!n&&Ic(6,"invalid zlib data: "+(32&r[1]?"need":"unexpected")+" dictionary"),2+(r[1]>>3&4))),this.v=0}var r,n;t&&(this.p.length<4&&Ic(6,"invalid zlib data"),this.p=this.p.subarray(0,-4)),Wc.prototype.c.call(this,t)},e}(),Qc="undefined"!=typeof TextDecoder&&new TextDecoder;try{Qc.decode(zc,{stream:!0})}catch(lu){}class Yc{static get tag(){return qn.packet.literalData}constructor(e=new Date){this.format=qn.literal.utf8,this.date=Xn.normalizeDate(e),this.text=null,this.data=null,this.filename=""}setText(e,t=qn.literal.utf8){this.format=t,this.text=e,this.data=null}getText(e=!1){return(null===this.text||Xn.isStream(this.text))&&(this.text=Xn.decodeUTF8(Xn.nativeEOL(this.getBytes(e)))),this.text}setBytes(e,t){this.format=t,this.data=e,this.text=null}getBytes(e=!1){return null===this.data&&(this.data=Xn.canonicalizeEOL(Xn.encodeUTF8(this.text))),e?Nn(this.data):this.data}setFilename(e){this.filename=e}getFilename(){return this.filename}async read(e){await $n(e,async e=>{const t=await e.readByte(),r=await e.readByte();this.filename=Xn.decodeUTF8(await e.readBytes(r)),this.date=Xn.readDate(await e.readBytes(4));let n=e.remainder();bn(n)&&(n=await Fn(n)),this.setBytes(n,t)})}writeHeader(){const e=Xn.encodeUTF8(this.filename),t=new Uint8Array([e.length]),r=new Uint8Array([this.format]),n=Xn.writeDate(this.date);return Xn.concatUint8Array([r,t,e,n])}write(){const e=this.writeHeader(),t=this.getBytes();return Xn.concat([e,t])}}class Zc{constructor(){this.bytes=""}read(e){return this.bytes=Xn.uint8ArrayToString(e.subarray(0,8)),this.bytes.length}write(){return Xn.stringToUint8Array(this.bytes)}toHex(){return Xn.uint8ArrayToHex(Xn.stringToUint8Array(this.bytes))}equals(e,t=!1){return t&&(e.isWildcard()||this.isWildcard())||this.bytes===e.bytes}isNull(){return""===this.bytes}isWildcard(){return/^0+$/.test(this.toHex())}static mapToHex(e){return e.toHex()}static fromID(e){const t=new Zc;return t.read(Xn.hexToUint8Array(e)),t}static wildcard(){const e=new Zc;return e.read(new Uint8Array(8)),e}}const Jc=Symbol("verified"),eu="salt@notations.openpgpjs.org",tu=new Set([qn.signatureSubpacket.issuerKeyID,qn.signatureSubpacket.issuerFingerprint,qn.signatureSubpacket.embeddedSignature]);class ru{static get tag(){return qn.packet.signature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.signatureData=null,this.unhashedSubpackets=[],this.unknownSubpackets=[],this.signedHashValue=null,this.salt=null,this.created=null,this.signatureExpirationTime=null,this.signatureNeverExpires=!0,this.exportable=null,this.trustLevel=null,this.trustAmount=null,this.regularExpression=null,this.revocable=null,this.keyExpirationTime=null,this.keyNeverExpires=null,this.preferredSymmetricAlgorithms=null,this.revocationKeyClass=null,this.revocationKeyAlgorithm=null,this.revocationKeyFingerprint=null,this.issuerKeyID=new Zc,this.rawNotations=[],this.notations={},this.preferredHashAlgorithms=null,this.preferredCompressionAlgorithms=null,this.keyServerPreferences=null,this.preferredKeyServer=null,this.isPrimaryUserID=null,this.policyURI=null,this.keyFlags=null,this.signersUserID=null,this.reasonForRevocationFlag=null,this.reasonForRevocationString=null,this.features=null,this.signatureTargetPublicKeyAlgorithm=null,this.signatureTargetHashAlgorithm=null,this.signatureTargetHash=null,this.embeddedSignature=null,this.issuerKeyVersion=null,this.issuerFingerprint=null,this.preferredAEADAlgorithms=null,this.preferredCipherSuites=null,this.revoked=null,this[Jc]=null}read(e,t=Wn){let r=0;if(this.version=e[r++],5===this.version&&!t.enableParsingV5Entities)throw new os("Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(4!==this.version&&5!==this.version&&6!==this.version)throw new os(`Version ${this.version} of the signature packet is unsupported.`);if(this.signatureType=e[r++],this.publicKeyAlgorithm=e[r++],this.hashAlgorithm=e[r++],r+=this.readSubPackets(e.subarray(r,e.length),!0),!this.created)throw Error("Missing signature creation time subpacket.");if(this.signatureData=e.subarray(0,r),r+=this.readSubPackets(e.subarray(r,e.length),!1),this.signedHashValue=e.subarray(r,r+2),r+=2,6===this.version){const t=e[r++];this.salt=e.subarray(r,r+t),r+=t}const n=e.subarray(r,e.length),{read:i,signatureParams:s}=function(e,t){let r=0;switch(e){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaSign:{const e=Xn.readMPI(t.subarray(r));return r+=e.length+2,{read:r,signatureParams:{s:e}}}case qn.publicKey.dsa:case qn.publicKey.ecdsa:{const e=Xn.readMPI(t.subarray(r));r+=e.length+2;const n=Xn.readMPI(t.subarray(r));return r+=n.length+2,{read:r,signatureParams:{r:e,s:n}}}case qn.publicKey.eddsaLegacy:{const e=Xn.readMPI(t.subarray(r));r+=e.length+2;const n=Xn.readMPI(t.subarray(r));return r+=n.length+2,{read:r,signatureParams:{r:e,s:n}}}case qn.publicKey.ed25519:case qn.publicKey.ed448:{const n=2*ps(e),i=Xn.readExactSubarray(t,r,r+n);return r+=i.length,{read:r,signatureParams:{RS:i}}}default:throw new os("Unknown signature algorithm.")}}(this.publicKeyAlgorithm,n);if(i<n.length)throw Error("Error reading MPIs");this.params=s}writeParams(){return this.params instanceof Promise?zn(async()=>ao(this.publicKeyAlgorithm,await this.params)):ao(this.publicKeyAlgorithm,this.params)}write(){const e=[];return e.push(this.signatureData),e.push(this.writeUnhashedSubPackets()),e.push(this.signedHashValue),6===this.version&&(e.push(new Uint8Array([this.salt.length])),e.push(this.salt)),e.push(this.writeParams()),Xn.concat(e)}async sign(e,t,r=new Date,n=!1,i){this.version=e.version,this.created=Xn.normalizeDate(r),this.issuerKeyVersion=e.version,this.issuerFingerprint=e.getFingerprintBytes(),this.issuerKeyID=e.getKeyID();const s=[new Uint8Array([this.version,this.signatureType,this.publicKeyAlgorithm,this.hashAlgorithm])];if(6===this.version){const e=iu(this.hashAlgorithm);if(null===this.salt)this.salt=Ai(e);else if(e!==this.salt.length)throw Error("Provided salt does not have the required length")}else if(i.nonDeterministicSignaturesViaNotation){if(0!==this.rawNotations.filter(({name:e})=>e===eu).length)throw Error("Unexpected existing salt notation");{const e=Ai(iu(this.hashAlgorithm));this.rawNotations.push({name:eu,value:e,humanReadable:!1,critical:!1})}}s.push(this.writeHashedSubPackets()),this.unhashedSubpackets=[],this.signatureData=Xn.concat(s);const a=this.toHash(this.signatureType,t,n),o=await this.hash(this.signatureType,t,a,n);this.signedHashValue=Rn(Ln(o),0,2);const c=async()=>async function(e,t,r,n,i,s){if(!r||!n)throw Error("Missing key parameters");switch(e){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaSign:{const{n:e,e:a}=r,{d:o,p:c,q:u,u:l}=n;return{s:await Wi(t,i,e,a,o,c,u,l,s)}}case qn.publicKey.dsa:{const{g:e,p:t,q:i}=r,{x:a}=n;return async function(e,t,r,n,i,s){const a=BigInt(0);let o,c,u,l;n=di(n),i=di(i),r=di(r),s=di(s),r=fi(r,n),s=fi(s,i);const h=fi(di(t.subarray(0,bi(i))),i);for(;;){if(o=Si(to,i),c=fi(gi(r,o,n),i),c===a)continue;const e=fi(s*c,i);if(l=fi(h+e,i),u=fi(mi(o,i)*l,i),u!==a)break}return{r:vi(c,"be",bi(n)),s:vi(u,"be",bi(n))}}(0,s,e,t,i,a)}case qn.publicKey.elgamal:throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");case qn.publicKey.ecdsa:{const{oid:e,Q:a}=r,{d:o}=n;return async function(e,t,r,n,i,s){const a=new Fa(e);if(Oa(a,n),r&&!Xn.isStream(r)){const s={publicKey:n,privateKey:i};switch(a.type){case"web":try{return await async function(e,t,r,n){const i=e.payloadSize,s=Ga(e.payloadSize,La[e.name],n.publicKey,n.privateKey),a=await qa.importKey("jwk",s,{name:"ECDSA",namedCurve:La[e.name],hash:{name:qn.read(qn.webHash,e.hash)}},!1,["sign"]),o=new Uint8Array(await qa.sign({name:"ECDSA",namedCurve:La[e.name],hash:{name:qn.read(qn.webHash,t)}},a,r));return{r:o.slice(0,i),s:o.slice(i,i<<1)}}(a,t,r,s)}catch(e){if("nistP521"!==a.name&&("DataError"===e.name||"OperationError"===e.name))throw e;Xn.printDebugError("Browser did not support signing: "+e.message)}break;case"node":return async function(e,t,r,n){const i=Xn.nodeRequire("eckey-utils"),s=Xn.getNodeBuffer(),{privateKey:a}=i.generateDer({curveName:Ma[e.name],privateKey:s.from(n)}),o=Wa.createSign(qn.read(qn.hash,t));o.write(r),o.end();const c=new Uint8Array(o.sign({key:a,format:"der",type:"sec1",dsaEncoding:"ieee-p1363"})),u=e.payloadSize;return{r:c.subarray(0,u),s:c.subarray(u,u<<1)}}(a,t,r,i)}}const o=(await Xn.getNobleCurve(qn.publicKey.ecdsa,a.name)).sign(s,i,{lowS:!1});return{r:vi(o.r,"be",a.payloadSize),s:vi(o.s,"be",a.payloadSize)}}(e,t,i,a,o,s)}case qn.publicKey.eddsaLegacy:{const{oid:e,Q:i}=r,{seed:a}=n;return async function(e,t,r,n,i,s){if(Oa(new Fa(e),n),Ri(t)<Ri(qn.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const{RS:a}=await hs(qn.publicKey.ed25519,t,0,n.subarray(1),i,s);return{r:a.subarray(0,32),s:a.subarray(32)}}(e,t,0,i,a,s)}case qn.publicKey.ed25519:case qn.publicKey.ed448:{const{A:i}=r,{seed:a}=n;return hs(e,t,0,i,a,s)}default:throw Error("Unknown signature algorithm.")}}(this.publicKeyAlgorithm,this.hashAlgorithm,e.publicParams,e.privateParams,a,await Fn(o));Xn.isStream(o)?this.params=c():(this.params=await c(),this[Jc]=!0)}writeHashedSubPackets(){const e=qn.signatureSubpacket,t=[];let r;if(null===this.created)throw Error("Missing signature creation time");t.push(nu(e.signatureCreationTime,!0,Xn.writeDate(this.created))),null!==this.signatureExpirationTime&&t.push(nu(e.signatureExpirationTime,!0,Xn.writeNumber(this.signatureExpirationTime,4))),null!==this.exportable&&t.push(nu(e.exportableCertification,!0,new Uint8Array([this.exportable?1:0]))),null!==this.trustLevel&&(r=new Uint8Array([this.trustLevel,this.trustAmount]),t.push(nu(e.trustSignature,!0,r))),null!==this.regularExpression&&t.push(nu(e.regularExpression,!0,this.regularExpression)),null!==this.revocable&&t.push(nu(e.revocable,!0,new Uint8Array([this.revocable?1:0]))),null!==this.keyExpirationTime&&t.push(nu(e.keyExpirationTime,!0,Xn.writeNumber(this.keyExpirationTime,4))),null!==this.preferredSymmetricAlgorithms&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.preferredSymmetricAlgorithms)),t.push(nu(e.preferredSymmetricAlgorithms,!1,r))),null!==this.revocationKeyClass&&(r=new Uint8Array([this.revocationKeyClass,this.revocationKeyAlgorithm]),r=Xn.concat([r,this.revocationKeyFingerprint]),t.push(nu(e.revocationKey,!1,r))),!this.issuerKeyID.isNull()&&this.issuerKeyVersion<5&&t.push(nu(e.issuerKeyID,!1,this.issuerKeyID.write())),this.rawNotations.forEach(({name:n,value:i,humanReadable:s,critical:a})=>{r=[new Uint8Array([s?128:0,0,0,0])];const o=Xn.encodeUTF8(n);r.push(Xn.writeNumber(o.length,2)),r.push(Xn.writeNumber(i.length,2)),r.push(o),r.push(i),r=Xn.concat(r),t.push(nu(e.notationData,a,r))}),null!==this.preferredHashAlgorithms&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.preferredHashAlgorithms)),t.push(nu(e.preferredHashAlgorithms,!1,r))),null!==this.preferredCompressionAlgorithms&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.preferredCompressionAlgorithms)),t.push(nu(e.preferredCompressionAlgorithms,!1,r))),null!==this.keyServerPreferences&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.keyServerPreferences)),t.push(nu(e.keyServerPreferences,!1,r))),null!==this.preferredKeyServer&&t.push(nu(e.preferredKeyServer,!1,Xn.encodeUTF8(this.preferredKeyServer))),null!==this.isPrimaryUserID&&t.push(nu(e.primaryUserID,!1,new Uint8Array([this.isPrimaryUserID?1:0]))),null!==this.policyURI&&t.push(nu(e.policyURI,!1,Xn.encodeUTF8(this.policyURI))),null!==this.keyFlags&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.keyFlags)),t.push(nu(e.keyFlags,!0,r))),null!==this.signersUserID&&t.push(nu(e.signersUserID,!1,Xn.encodeUTF8(this.signersUserID))),null!==this.reasonForRevocationFlag&&(r=Xn.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag)+this.reasonForRevocationString),t.push(nu(e.reasonForRevocation,!0,r))),null!==this.features&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.features)),t.push(nu(e.features,!1,r))),null!==this.signatureTargetPublicKeyAlgorithm&&(r=[new Uint8Array([this.signatureTargetPublicKeyAlgorithm,this.signatureTargetHashAlgorithm])],r.push(Xn.stringToUint8Array(this.signatureTargetHash)),r=Xn.concat(r),t.push(nu(e.signatureTarget,!0,r))),null!==this.embeddedSignature&&t.push(nu(e.embeddedSignature,!0,this.embeddedSignature.write())),null!==this.issuerFingerprint&&(r=[new Uint8Array([this.issuerKeyVersion]),this.issuerFingerprint],r=Xn.concat(r),t.push(nu(e.issuerFingerprint,this.version>=5,r))),null!==this.preferredAEADAlgorithms&&(r=Xn.stringToUint8Array(Xn.uint8ArrayToString(this.preferredAEADAlgorithms)),t.push(nu(e.preferredAEADAlgorithms,!1,r))),null!==this.preferredCipherSuites&&(r=new Uint8Array([].concat(...this.preferredCipherSuites)),t.push(nu(e.preferredCipherSuites,!1,r)));const n=Xn.concat(t),i=Xn.writeNumber(n.length,6===this.version?4:2);return Xn.concat([i,n])}writeUnhashedSubPackets(){const e=this.unhashedSubpackets.map(({type:e,critical:t,body:r})=>nu(e,t,r)),t=Xn.concat(e),r=Xn.writeNumber(t.length,6===this.version?4:2);return Xn.concat([r,t])}readSubPacket(e,t=!0){let r=0;const n=!!(128&e[r]),i=127&e[r];if(r++,t||(this.unhashedSubpackets.push({type:i,critical:n,body:e.subarray(r,e.length)}),tu.has(i)))switch(i){case qn.signatureSubpacket.signatureCreationTime:this.created=Xn.readDate(e.subarray(r,e.length));break;case qn.signatureSubpacket.signatureExpirationTime:{const t=Xn.readNumber(e.subarray(r,e.length));this.signatureNeverExpires=0===t,this.signatureExpirationTime=t;break}case qn.signatureSubpacket.exportableCertification:this.exportable=1===e[r++];break;case qn.signatureSubpacket.trustSignature:this.trustLevel=e[r++],this.trustAmount=e[r++];break;case qn.signatureSubpacket.regularExpression:this.regularExpression=e[r];break;case qn.signatureSubpacket.revocable:this.revocable=1===e[r++];break;case qn.signatureSubpacket.keyExpirationTime:{const t=Xn.readNumber(e.subarray(r,e.length));this.keyExpirationTime=t,this.keyNeverExpires=0===t;break}case qn.signatureSubpacket.preferredSymmetricAlgorithms:this.preferredSymmetricAlgorithms=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.revocationKey:this.revocationKeyClass=e[r++],this.revocationKeyAlgorithm=e[r++],this.revocationKeyFingerprint=e.subarray(r,r+20);break;case qn.signatureSubpacket.issuerKeyID:if(4===this.version)this.issuerKeyID.read(e.subarray(r,e.length));else if(t)throw Error("Unexpected Issuer Key ID subpacket");break;case qn.signatureSubpacket.notationData:{const t=!!(128&e[r]);r+=4;const i=Xn.readNumber(e.subarray(r,r+2));r+=2;const s=Xn.readNumber(e.subarray(r,r+2));r+=2;const a=Xn.decodeUTF8(e.subarray(r,r+i)),o=e.subarray(r+i,r+i+s);this.rawNotations.push({name:a,humanReadable:t,value:o,critical:n}),t&&(this.notations[a]=Xn.decodeUTF8(o));break}case qn.signatureSubpacket.preferredHashAlgorithms:this.preferredHashAlgorithms=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.preferredCompressionAlgorithms:this.preferredCompressionAlgorithms=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.keyServerPreferences:this.keyServerPreferences=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.preferredKeyServer:this.preferredKeyServer=Xn.decodeUTF8(e.subarray(r,e.length));break;case qn.signatureSubpacket.primaryUserID:this.isPrimaryUserID=0!==e[r++];break;case qn.signatureSubpacket.policyURI:this.policyURI=Xn.decodeUTF8(e.subarray(r,e.length));break;case qn.signatureSubpacket.keyFlags:this.keyFlags=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.signersUserID:this.signersUserID=Xn.decodeUTF8(e.subarray(r,e.length));break;case qn.signatureSubpacket.reasonForRevocation:this.reasonForRevocationFlag=e[r++],this.reasonForRevocationString=Xn.decodeUTF8(e.subarray(r,e.length));break;case qn.signatureSubpacket.features:this.features=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.signatureTarget:{this.signatureTargetPublicKeyAlgorithm=e[r++],this.signatureTargetHashAlgorithm=e[r++];const t=Ri(this.signatureTargetHashAlgorithm);this.signatureTargetHash=Xn.uint8ArrayToString(e.subarray(r,r+t));break}case qn.signatureSubpacket.embeddedSignature:this.embeddedSignature=new ru,this.embeddedSignature.read(e.subarray(r,e.length));break;case qn.signatureSubpacket.issuerFingerprint:this.issuerKeyVersion=e[r++],this.issuerFingerprint=e.subarray(r,e.length),this.issuerKeyVersion>=5?this.issuerKeyID.read(this.issuerFingerprint):this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));break;case qn.signatureSubpacket.preferredAEADAlgorithms:this.preferredAEADAlgorithms=[...e.subarray(r,e.length)];break;case qn.signatureSubpacket.preferredCipherSuites:this.preferredCipherSuites=[];for(let t=r;t<e.length;t+=2)this.preferredCipherSuites.push([e[t],e[t+1]]);break;default:this.unknownSubpackets.push({type:i,critical:n,body:e.subarray(r,e.length)})}}readSubPackets(e,t=!0,r){const n=6===this.version?4:2,i=Xn.readNumber(e.subarray(0,n));let s=n;for(;s<2+i;){const n=es(e.subarray(s,e.length));s+=n.offset,this.readSubPacket(e.subarray(s,s+n.len),t,r),s+=n.len}return s}toSign(e,t){const r=qn.signature;switch(e){case r.binary:return null!==t.text?Xn.encodeUTF8(t.getText(!0)):t.getBytes(!0);case r.text:{const e=t.getBytes(!0);return Xn.canonicalizeEOL(e)}case r.standalone:return new Uint8Array(0);case r.certGeneric:case r.certPersona:case r.certCasual:case r.certPositive:case r.certRevocation:{let e,n;if(t.userID)n=180,e=t.userID;else{if(!t.userAttribute)throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");n=209,e=t.userAttribute}const i=e.write();return Xn.concat([this.toSign(r.key,t),new Uint8Array([n]),Xn.writeNumber(i.length,4),i])}case r.subkeyBinding:case r.subkeyRevocation:case r.keyBinding:return Xn.concat([this.toSign(r.key,t),this.toSign(r.key,{key:t.bind})]);case r.key:if(void 0===t.key)throw Error("Key packet is required for this signature.");return t.key.writeForHash(this.version);case r.keyRevocation:return this.toSign(r.key,t);case r.timestamp:return new Uint8Array(0);case r.thirdParty:throw Error("Not implemented");default:throw Error("Unknown signature type.")}}calculateTrailer(e,t){let r=0;return Tn(Ln(this.signatureData),e=>{r+=e.length},()=>{const n=[];return 5!==this.version||this.signatureType!==qn.signature.binary&&this.signatureType!==qn.signature.text||(t?n.push(new Uint8Array(6)):n.push(e.writeHeader())),n.push(new Uint8Array([this.version,255])),5===this.version&&n.push(new Uint8Array(4)),n.push(Xn.writeNumber(r,4)),Xn.concat(n)})}toHash(e,t,r=!1){const n=this.toSign(e,t);return Xn.concat([this.salt||new Uint8Array,n,this.signatureData,this.calculateTrailer(t,r)])}async hash(e,t,r,n=!1){if(6===this.version&&this.salt.length!==iu(this.hashAlgorithm))throw Error("Signature salt does not have the expected length");return r||(r=this.toHash(e,t,n)),Mi(this.hashAlgorithm,r)}async verify(e,t,r,n=new Date,i=!1,s=Wn){if(!this.issuerKeyID.equals(e.getKeyID()))throw Error("Signature was not issued by the given public key");if(this.publicKeyAlgorithm!==e.algorithm)throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");const a=t===qn.signature.binary||t===qn.signature.text;if(!this[Jc]||a){let n,s;if(this.hashed?s=await this.hashed:(n=this.toHash(t,r,i),s=await this.hash(t,r,n)),s=await Fn(s),this.signedHashValue[0]!==s[0]||this.signedHashValue[1]!==s[1])throw Error("Signed digest did not match");if(this.params=await this.params,this[Jc]=await Xo(this.publicKeyAlgorithm,this.hashAlgorithm,this.params,e.publicParams,n,s),!this[Jc])throw Error("Signature verification failed")}const o=Xn.normalizeDate(n);if(o&&this.created>o)throw Error("Signature creation time is in the future");if(o&&o>=this.getExpirationTime())throw Error("Signature is expired");if(s.rejectHashAlgorithms.has(this.hashAlgorithm))throw Error("Insecure hash algorithm: "+qn.read(qn.hash,this.hashAlgorithm).toUpperCase());if(s.rejectMessageHashAlgorithms.has(this.hashAlgorithm)&&[qn.signature.binary,qn.signature.text].includes(this.signatureType))throw Error("Insecure message hash algorithm: "+qn.read(qn.hash,this.hashAlgorithm).toUpperCase());if(this.unknownSubpackets.forEach(({type:e,critical:t})=>{if(t)throw Error("Unknown critical signature subpacket type "+e)}),this.rawNotations.forEach(({name:e,critical:t})=>{if(t&&s.knownNotations.indexOf(e)<0)throw Error("Unknown critical notation: "+e)}),null!==this.revocationKeyClass)throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.")}isExpired(e=new Date){const t=Xn.normalizeDate(e);return null!==t&&!(this.created<=t&&t<this.getExpirationTime())}getExpirationTime(){return this.signatureNeverExpires?1/0:new Date(this.created.getTime()+1e3*this.signatureExpirationTime)}}function nu(e,t,r){const n=[];return n.push(ts(r.length+1)),n.push(new Uint8Array([(t?128:0)|e])),n.push(r),Xn.concat(n)}function iu(e){switch(e){case qn.hash.sha256:return 16;case qn.hash.sha384:return 24;case qn.hash.sha512:return 32;case qn.hash.sha224:case qn.hash.sha3_256:return 16;case qn.hash.sha3_512:return 32;default:throw Error("Unsupported hash function")}}class su{static get tag(){return qn.packet.onePassSignature}static fromSignaturePacket(e,t){const r=new su;return r.version=6===e.version?6:3,r.signatureType=e.signatureType,r.hashAlgorithm=e.hashAlgorithm,r.publicKeyAlgorithm=e.publicKeyAlgorithm,r.issuerKeyID=e.issuerKeyID,r.salt=e.salt,r.issuerFingerprint=e.issuerFingerprint,r.flags=t?1:0,r}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.salt=null,this.issuerKeyID=null,this.issuerFingerprint=null,this.flags=null}read(e){let t=0;if(this.version=e[t++],3!==this.version&&6!==this.version)throw new os(`Version ${this.version} of the one-pass signature packet is unsupported.`);if(this.signatureType=e[t++],this.hashAlgorithm=e[t++],this.publicKeyAlgorithm=e[t++],6===this.version){const r=e[t++];this.salt=e.subarray(t,t+r),t+=r,this.issuerFingerprint=e.subarray(t,t+32),t+=32,this.issuerKeyID=new Zc,this.issuerKeyID.read(this.issuerFingerprint)}else this.issuerKeyID=new Zc,this.issuerKeyID.read(e.subarray(t,t+8)),t+=8;return this.flags=e[t++],this}write(){const e=[new Uint8Array([this.version,this.signatureType,this.hashAlgorithm,this.publicKeyAlgorithm])];return 6===this.version?e.push(new Uint8Array([this.salt.length]),this.salt,this.issuerFingerprint):e.push(this.issuerKeyID.write()),e.push(new Uint8Array([this.flags])),Xn.concatUint8Array(e)}calculateTrailer(...e){return zn(async()=>ru.prototype.calculateTrailer.apply(await this.correspondingSig,e))}async verify(){const e=await this.correspondingSig;if(!e||e.constructor.tag!==qn.packet.signature)throw Error("Corresponding signature packet missing");if(e.signatureType!==this.signatureType||e.hashAlgorithm!==this.hashAlgorithm||e.publicKeyAlgorithm!==this.publicKeyAlgorithm||!e.issuerKeyID.equals(this.issuerKeyID)||3===this.version&&6===e.version||6===this.version&&6!==e.version||6===this.version&&!Xn.equalsUint8Array(e.issuerFingerprint,this.issuerFingerprint)||6===this.version&&!Xn.equalsUint8Array(e.salt,this.salt))throw Error("Corresponding signature packet does not match one-pass signature packet");return e.hashed=this.hashed,e.verify.apply(e,arguments)}}function au(e,t){if(!t[e]){let r;try{r=qn.read(qn.packet,e)}catch(t){throw new cs("Unknown packet type with tag: "+e)}throw Error("Packet not allowed in this context: "+r)}return new t[e]}su.prototype.hash=ru.prototype.hash,su.prototype.toHash=ru.prototype.toHash,su.prototype.toSign=ru.prototype.toSign;class ou extends Array{static async fromBinary(e,t,r=Wn,n=null,i=!1){const s=new ou;return await s.read(e,t,r,n,i),s}async read(e,t,r=Wn,n=null,i=!1){let s;r.additionalAllowedPackets.length&&(s=Xn.constructAllowedPackets(r.additionalAllowedPackets),t={...t,...s}),this.stream=Bn(e,async(e,a)=>{const o=jn(e),c=Hn(a);try{let a=Xn.isStream(e);for(;;){let u,l;if(await c.ready,await as(o,a,async e=>{try{if(e.tag===qn.packet.marker||e.tag===qn.packet.trust||e.tag===qn.packet.padding)return;const i=au(e.tag,t);try{n?.recordPacket(e.tag,s)}catch(e){if(r.enforceGrammar)throw e;Xn.printDebugError(e)}i.packets=new ou,i.fromStream=Xn.isStream(e.packet),l=i.fromStream;try{await i.read(e.packet,r)}catch(e){if(!(e instanceof os))throw Xn.wrapError(new us(`Parsing ${i.constructor.name} failed`),e);throw e}await c.write(i)}catch(t){const n=t instanceof cs&&e.tag<=39,s=t instanceof os&&!(t instanceof cs)&&!r.ignoreUnsupportedPackets,a=t instanceof us&&!r.ignoreMalformedPackets,o=ss(e.tag);if(n||s||a||o||!(t instanceof cs||t instanceof os||t instanceof us))i?u=t:await c.abort(t);else{const t=new ls(e.tag,e.packet);await c.write(t)}Xn.printDebugError(t)}}),l&&(a=null),u)throw await o.readToEnd(),u;const h=await o.peekBytes(2);if(!h||!h.length){try{n?.recordEnd()}catch(e){if(r.enforceGrammar)throw e;Xn.printDebugError(e)}return await c.ready,void await c.close()}}}catch(e){await c.abort(e)}});const a=jn(this.stream);for(;;){const{done:e,value:t}=await a.read();if(e?this.stream=null:this.push(t),e||ss(t.constructor.tag))break}a.releaseLock()}write(){const e=[];for(let t=0;t<this.length;t++){const r=this[t]instanceof ls?this[t].tag:this[t].constructor.tag,n=this[t].write();if(Xn.isStream(n)&&ss(this[t].constructor.tag)){let t=[],i=0;const s=512;e.push(ns(r)),e.push(Tn(n,e=>{if(t.push(e),i+=e.length,i>=s){const e=Math.min(Math.log(i)/Math.LN2|0,30),r=2**e,n=Xn.concat([rs(e)].concat(t));return t=[n.subarray(1+r)],i=t[0].length,n.subarray(0,1+r)}},()=>Xn.concat([ts(i)].concat(t))))}else{if(Xn.isStream(n)){let t=0;e.push(Tn(Ln(n),e=>{t+=e.length},()=>is(r,t)))}else e.push(is(r,n.length));e.push(n)}}return Xn.concat(e)}filterByTag(...e){const t=new ou,r=e=>t=>e===t;for(let n=0;n<this.length;n++)e.some(r(this[n].constructor.tag))&&t.push(this[n]);return t}findPacket(e){return this.find(t=>t.constructor.tag===e)}indexOfTag(...e){const t=[],r=this,n=e=>t=>e===t;for(let i=0;i<this.length;i++)e.some(n(r[i].constructor.tag))&&t.push(i);return t}}class cu extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,cu),this.name="GrammarError"}}var uu,lu;(lu=uu||(uu={}))[lu.EmptyMessage=0]="EmptyMessage",lu[lu.PlaintextOrEncryptedData=1]="PlaintextOrEncryptedData",lu[lu.EncryptedSessionKeys=2]="EncryptedSessionKeys",lu[lu.StandaloneAdditionalAllowedData=3]="StandaloneAdditionalAllowedData";class hu{constructor(){this.state=uu.EmptyMessage,this.leadingOnePassSignatureCounter=0}recordPacket(e,t){switch(this.state){case uu.EmptyMessage:case uu.StandaloneAdditionalAllowedData:switch(e){case qn.packet.literalData:case qn.packet.compressedData:case qn.packet.aeadEncryptedData:case qn.packet.symEncryptedIntegrityProtectedData:case qn.packet.symmetricallyEncryptedData:return void(this.state=uu.PlaintextOrEncryptedData);case qn.packet.signature:if(this.state===uu.StandaloneAdditionalAllowedData&&--this.leadingOnePassSignatureCounter<0)throw new cu("Trailing signature packet without OPS");return;case qn.packet.onePassSignature:if(this.state===uu.StandaloneAdditionalAllowedData)throw new cu("OPS following StandaloneAdditionalAllowedData");return void this.leadingOnePassSignatureCounter++;case qn.packet.publicKeyEncryptedSessionKey:case qn.packet.symEncryptedSessionKey:return void(this.state=uu.EncryptedSessionKeys);default:if(!t?.[e])throw new cu(`Unexpected packet ${e} in state ${this.state}`);return void(this.state=uu.StandaloneAdditionalAllowedData)}case uu.PlaintextOrEncryptedData:if(e===qn.packet.signature){if(--this.leadingOnePassSignatureCounter<0)throw new cu("Trailing signature packet without OPS");return void(this.state=uu.PlaintextOrEncryptedData)}if(!t?.[e])throw new cu(`Unexpected packet ${e} in state ${this.state}`);return void(this.state=uu.PlaintextOrEncryptedData);case uu.EncryptedSessionKeys:switch(e){case qn.packet.publicKeyEncryptedSessionKey:case qn.packet.symEncryptedSessionKey:return void(this.state=uu.EncryptedSessionKeys);case qn.packet.symEncryptedIntegrityProtectedData:case qn.packet.aeadEncryptedData:case qn.packet.symmetricallyEncryptedData:return void(this.state=uu.PlaintextOrEncryptedData);case qn.packet.signature:if(--this.leadingOnePassSignatureCounter<0)throw new cu("Trailing signature packet without OPS");return void(this.state=uu.PlaintextOrEncryptedData);default:if(!t?.[e])throw new cu(`Unexpected packet ${e} in state ${this.state}`);this.state=uu.EncryptedSessionKeys}}}recordEnd(){switch(this.state){case uu.EmptyMessage:case uu.PlaintextOrEncryptedData:case uu.EncryptedSessionKeys:case uu.StandaloneAdditionalAllowedData:if(this.leadingOnePassSignatureCounter>0)throw new cu("Missing trailing signature packets")}}}const yu=Xn.constructAllowedPackets([Yc,su,ru]);class pu{static get tag(){return qn.packet.compressedData}constructor(e=Wn){this.packets=null,this.algorithm=e.preferredCompressionAlgorithm,this.compressed=null}async read(e,t=Wn){await $n(e,async e=>{this.algorithm=await e.readByte(),this.compressed=e.remainder(),await this.decompress(t)})}write(){return null===this.compressed&&this.compress(),Xn.concat([new Uint8Array([this.algorithm]),this.compressed])}async decompress(e=Wn){const t=qn.read(qn.compression,this.algorithm),r=mu[t];if(!r)throw Error(t+" decompression not supported");this.packets=await ou.fromBinary(await r(this.compressed),yu,e,new hu)}compress(){const e=qn.read(qn.compression,this.algorithm),t=wu[e];if(!t)throw Error(e+" compression not supported");this.compressed=t(this.packets.write())}}function du(e,t){return r=>{if(!Xn.isStream(r)||bn(r))return zn(()=>Fn(r).then(e=>new Promise((r,n)=>{const i=new t,s=[];i.ondata=(e,t)=>{s.push(e),t&&r(Xn.concatUint8Array(s))};try{i.push(e,!0)}catch(e){n(e)}})));if(e)try{const t=e();return r.pipeThrough(t)}catch(e){if("TypeError"!==e.name)throw e}const n=r.getReader(),i=new t;return new ReadableStream({async start(e){for(i.ondata=async(t,r)=>{e.enqueue(t),r&&e.close()};;){const{done:e,value:t}=await n.read();if(e)return void i.push(new Uint8Array,!0);t.length&&i.push(t)}}})}}function fu(){return async function(e){const{decode:t}=await i.e(834).then(i.bind(i,834)).then(function(e){return e.i});return zn(async()=>t(await Fn(e)))}}const gu=e=>({compressor:"undefined"!=typeof CompressionStream&&(()=>new CompressionStream(e)),decompressor:"undefined"!=typeof DecompressionStream&&(()=>new DecompressionStream(e))}),wu={zip:du(gu("deflate-raw").compressor,qc),zlib:du(gu("deflate").compressor,Vc)},mu={uncompressed:e=>e,zip:du(gu("deflate-raw").decompressor,Wc),zlib:du(gu("deflate").decompressor,Xc),bzip2:fu()},bu=Xn.constructAllowedPackets([Yc,pu,su,ru]);class vu{static get tag(){return qn.packet.symEncryptedIntegrityProtectedData}static fromObject({version:e,aeadAlgorithm:t}){if(1!==e&&2!==e)throw Error("Unsupported SEIPD version");const r=new vu;return r.version=e,2===e&&(r.aeadAlgorithm=t),r}constructor(){this.version=null,this.cipherAlgorithm=null,this.aeadAlgorithm=null,this.chunkSizeByte=null,this.salt=null,this.encrypted=null,this.packets=null}async read(e){await $n(e,async e=>{if(this.version=await e.readByte(),1!==this.version&&2!==this.version)throw new os(`Version ${this.version} of the SEIP packet is unsupported.`);2===this.version&&(this.cipherAlgorithm=await e.readByte(),this.aeadAlgorithm=await e.readByte(),this.chunkSizeByte=await e.readByte(),this.salt=await e.readBytes(32)),this.encrypted=e.remainder()})}write(){return 2===this.version?Xn.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.salt,this.encrypted]):Xn.concat([new Uint8Array([this.version]),this.encrypted])}async encrypt(e,t,r=Wn){const{blockSize:n,keySize:i}=Sa(e);if(t.length!==i)throw Error("Unexpected session key size");let s=this.packets.write();if(bn(s)&&(s=await Fn(s)),2===this.version)this.cipherAlgorithm=e,this.salt=Ai(32),this.chunkSizeByte=r.aeadChunkSizeByte,this.encrypted=await ku(this,"encrypt",t,s);else{const r=await fo(e),i=new Uint8Array([211,20]),a=Xn.concat([r,s,i]),o=await Mi(qn.hash.sha1,Nn(a)),c=Xn.concat([a,o]);this.encrypted=await go(e,t,c,new Uint8Array(n))}return!0}async decrypt(e,t,r=Wn){if(t.length!==Sa(e).keySize)throw Error("Unexpected session key size");let n,i=Ln(this.encrypted);bn(i)&&(i=await Fn(i));let s=!1;if(2===this.version){if(this.cipherAlgorithm!==e)throw Error("Unexpected session key algorithm");n=await ku(this,"decrypt",t,i)}else{const{blockSize:a}=Sa(e),o=await wo(e,t,i,new Uint8Array(a)),c=Rn(Nn(o),-20),u=Rn(o,0,-20),l=Promise.all([Fn(await Mi(qn.hash.sha1,Nn(u))),Fn(c)]).then(([e,t])=>{if(!Xn.equalsUint8Array(e,t))throw Error("Modification detected.");return new Uint8Array}),h=Rn(u,a+2);n=Rn(h,0,-2),n=xn([n,zn(()=>l)]),Xn.isStream(i)&&r.allowUnauthenticatedStream?s=!0:n=await Fn(n)}return this.packets=await ou.fromBinary(n,bu,r,new hu,s),!0}}async function ku(e,t,r,n){const i=e instanceof vu&&2===e.version,s=!i&&e.constructor.tag===qn.packet.aeadEncryptedData;if(!i&&!s)throw Error("Unexpected packet type");const a=Vo(e.aeadAlgorithm,s),o="decrypt"===t?a.tagLength:0,c="encrypt"===t?a.tagLength:0,u=2**(e.chunkSizeByte+6)+o,l=s?8:0,h=new ArrayBuffer(13+l),y=new Uint8Array(h,0,5+l),p=new Uint8Array(h),d=new DataView(h),f=new Uint8Array(h,5,8);y.set([192|e.constructor.tag,e.version,e.cipherAlgorithm,e.aeadAlgorithm,e.chunkSizeByte],0);let g,w,m=0,b=Promise.resolve(),v=0,k=0;if(i){const{keySize:t}=Sa(e.cipherAlgorithm),{ivLength:n}=a,i=new Uint8Array(h,0,5),s=await Ua(qn.hash.sha256,r,e.salt,i,t+n);r=s.subarray(0,t),g=s.subarray(t),g.fill(0,g.length-8),w=new DataView(g.buffer,g.byteOffset,g.byteLength)}else g=e.iv;const A=await a(e.cipherAlgorithm,r);return Bn(n,async(r,n)=>{if("array"!==Xn.isStream(r)){const t=new TransformStream({},{highWaterMark:Xn.getHardwareConcurrency()*2**(e.chunkSizeByte+6),size:e=>e.length});_n(t.readable,n),n=t.writable}const s=jn(r),a=Hn(n);try{for(;;){let e=await s.readBytes(u+o)||new Uint8Array;const r=e.subarray(e.length-o);let n,h,S;if(e=e.subarray(0,e.length-o),i)S=g;else{S=g.slice();for(let e=0;e<8;e++)S[g.length-8+e]^=f[e]}if(!m||e.length?(s.unshift(r),n=A[t](e,S,y),n.catch(()=>{}),k+=e.length-o+c):(d.setInt32(5+l+4,v),n=A[t](r,S,p),n.catch(()=>{}),k+=c,h=!0),v+=e.length-o,b=b.then(()=>n).then(async e=>{await a.ready,await a.write(e),k-=e.length}).catch(e=>a.abort(e)),(h||k>a.desiredSize)&&await b,h){await a.close();break}i?w.setInt32(g.length-4,++m):d.setInt32(9,++m)}}catch(e){await a.ready.catch(()=>{}),await a.abort(e)}})}const Au=Xn.constructAllowedPackets([Yc,pu,su,ru]);class Su{static get tag(){return qn.packet.publicKeyEncryptedSessionKey}constructor(){this.version=null,this.publicKeyID=new Zc,this.publicKeyVersion=null,this.publicKeyFingerprint=null,this.publicKeyAlgorithm=null,this.sessionKey=null,this.sessionKeyAlgorithm=null,this.encrypted={}}static fromObject({version:e,encryptionKeyPacket:t,anonymousRecipient:r,sessionKey:n,sessionKeyAlgorithm:i}){const s=new Su;if(3!==e&&6!==e)throw Error("Unsupported PKESK version");return s.version=e,6===e&&(s.publicKeyVersion=r?null:t.version,s.publicKeyFingerprint=r?null:t.getFingerprintBytes()),s.publicKeyID=r?Zc.wildcard():t.getKeyID(),s.publicKeyAlgorithm=t.algorithm,s.sessionKey=n,s.sessionKeyAlgorithm=i,s}read(e){let t=0;if(this.version=e[t++],3!==this.version&&6!==this.version)throw new os(`Version ${this.version} of the PKESK packet is unsupported.`);if(6===this.version){const r=e[t++];if(r){this.publicKeyVersion=e[t++];const n=r-1;this.publicKeyFingerprint=e.subarray(t,t+n),t+=n,this.publicKeyVersion>=5?this.publicKeyID.read(this.publicKeyFingerprint):this.publicKeyID.read(this.publicKeyFingerprint.subarray(-8))}else this.publicKeyID=Zc.wildcard()}else t+=this.publicKeyID.read(e.subarray(t,t+8));if(this.publicKeyAlgorithm=e[t++],this.encrypted=function(e,t){let r=0;switch(e){case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaEncryptSign:return{c:Xn.readMPI(t.subarray(r))};case qn.publicKey.elgamal:{const e=Xn.readMPI(t.subarray(r));return r+=e.length+2,{c1:e,c2:Xn.readMPI(t.subarray(r))}}case qn.publicKey.ecdh:{const e=Xn.readMPI(t.subarray(r));r+=e.length+2;const n=new ro;return n.read(t.subarray(r)),{V:e,C:n}}case qn.publicKey.x25519:case qn.publicKey.x448:{const n=uo(e),i=Xn.readExactSubarray(t,r,r+n);r+=i.length;const s=new io;return s.read(t.subarray(r)),{ephemeralPublicKey:i,C:s}}default:throw new os("Unknown public key encryption algorithm.")}}(this.publicKeyAlgorithm,e.subarray(t)),this.publicKeyAlgorithm===qn.publicKey.x25519||this.publicKeyAlgorithm===qn.publicKey.x448)if(3===this.version)this.sessionKeyAlgorithm=qn.write(qn.symmetric,this.encrypted.C.algorithm);else if(null!==this.encrypted.C.algorithm)throw Error("Unexpected cleartext symmetric algorithm")}write(){const e=[new Uint8Array([this.version])];return 6===this.version?null!==this.publicKeyFingerprint?(e.push(new Uint8Array([this.publicKeyFingerprint.length+1,this.publicKeyVersion])),e.push(this.publicKeyFingerprint)):e.push(new Uint8Array([0])):e.push(this.publicKeyID.write()),e.push(new Uint8Array([this.publicKeyAlgorithm]),ao(this.publicKeyAlgorithm,this.encrypted)),Xn.concatUint8Array(e)}async encrypt(e){const t=qn.write(qn.publicKey,this.publicKeyAlgorithm),r=3===this.version?this.sessionKeyAlgorithm:null,n=5===e.version?e.getFingerprintBytes().subarray(0,20):e.getFingerprintBytes(),i=Eu(this.version,t,r,this.sessionKey);this.encrypted=await async function(e,t,r,n,i){switch(e){case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaEncryptSign:{const{n:e,e:t}=r;return{c:await Vi(n,e,t)}}case qn.publicKey.elgamal:{const{p:e,g:t,y:i}=r;return async function(e,t,r,n){t=di(t),r=di(r),n=di(n);const i=di(Oi(e,bi(t))),s=Si(Yi,t-Yi);return{c1:vi(gi(r,s,t)),c2:vi(fi(gi(n,s,t)*i,t))}}(n,e,t,i)}case qn.publicKey.ecdh:{const{oid:e,Q:t,kdfParams:s}=r,{publicKey:a,wrappedKey:o}=await async function(e,t,r,n,i){const s=function(e){const t=8-e.length%8,r=new Uint8Array(e.length+t).fill(t);return r.set(e),r}(r),a=new Fa(e);Oa(a,n);const{publicKey:o,sharedKey:c}=await async function(e,t){switch(e.type){case"curve25519Legacy":{const{sharedSecret:r,ephemeralPublicKey:n}=await _a(qn.publicKey.x25519,t.subarray(1));return{publicKey:Xn.concatUint8Array([new Uint8Array([e.wireFormatLeadingByte]),n]),sharedKey:r}}case"web":if(e.web&&Xn.getWebCrypto())try{return await async function(e,t){const r=Xn.getWebCrypto(),n=Ha(e.payloadSize,e.web,t);let i=r.generateKey({name:"ECDH",namedCurve:e.web},!0,["deriveKey","deriveBits"]),s=r.importKey("jwk",n,{name:"ECDH",namedCurve:e.web},!1,[]);[i,s]=await Promise.all([i,s]);let a=r.deriveBits({name:"ECDH",namedCurve:e.web,public:s},i.privateKey,e.sharedSize),o=r.exportKey("jwk",i.publicKey);[a,o]=await Promise.all([a,o]);const c=new Uint8Array(a);return{publicKey:new Uint8Array(ja(o,e.wireFormatLeadingByte)),sharedKey:c}}(e,t)}catch(r){return Xn.printDebugError(r),Ja(e,t)}break;case"node":return async function(e,t){const r=Xn.getNodeCrypto().createECDH(e.node);r.generateKeys();const n=new Uint8Array(r.computeSecret(t));return{publicKey:new Uint8Array(r.getPublicKey()),sharedKey:n}}(e,t);default:return Ja(e,t)}}(a,n),u=Qa(qn.publicKey.ecdh,e,t,i),{keySize:l}=Sa(t.cipher),h=await Ya(t.hash,c,l,u);return{publicKey:o,wrappedKey:await Ka(t.cipher,h,s)}}(e,s,n,t,i);return{V:a,C:new ro(o)}}case qn.publicKey.x25519:case qn.publicKey.x448:{if(t&&!Xn.isAES(t))throw Error("X25519 and X448 keys can only encrypt AES session keys");const{A:i}=r,{ephemeralPublicKey:s,wrappedKey:a}=await async function(e,t,r){const{ephemeralPublicKey:n,sharedSecret:i}=await _a(e,r),s=Xn.concatUint8Array([n,r,i]);switch(e){case qn.publicKey.x25519:{const e=qn.symmetric.aes128,{keySize:r}=Sa(e),i=await Ua(qn.hash.sha256,s,new Uint8Array,Da.x25519,r);return{ephemeralPublicKey:n,wrappedKey:await Ka(e,i,t)}}case qn.publicKey.x448:{const e=qn.symmetric.aes256,{keySize:r}=Sa(qn.symmetric.aes256),i=await Ua(qn.hash.sha512,s,new Uint8Array,Da.x448,r);return{ephemeralPublicKey:n,wrappedKey:await Ka(e,i,t)}}default:throw Error("Unsupported ECDH algorithm")}}(e,n,i);return{ephemeralPublicKey:s,C:io.fromObject({algorithm:t,wrappedKey:a})}}default:return[]}}(t,r,e.publicParams,i,n)}async decrypt(e,t){if(this.publicKeyAlgorithm!==e.algorithm)throw Error("Decryption error");const r=t?Eu(this.version,this.publicKeyAlgorithm,t.sessionKeyAlgorithm,t.sessionKey):null,n=5===e.version?e.getFingerprintBytes().subarray(0,20):e.getFingerprintBytes(),i=await so(this.publicKeyAlgorithm,e.publicParams,e.privateParams,this.encrypted,n,r),{sessionKey:s,sessionKeyAlgorithm:a}=function(e,t,r,n){switch(t){case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaEncryptSign:case qn.publicKey.elgamal:case qn.publicKey.ecdh:{const t=r.subarray(0,r.length-2),i=r.subarray(r.length-2),s=Xn.writeChecksum(t.subarray(t.length%8)),a=s[0]===i[0]&s[1]===i[1],o=6===e?{sessionKeyAlgorithm:null,sessionKey:t}:{sessionKeyAlgorithm:t[0],sessionKey:t.subarray(1)};if(n){const t=a&o.sessionKeyAlgorithm===n.sessionKeyAlgorithm&o.sessionKey.length===n.sessionKey.length;return{sessionKey:Xn.selectUint8Array(t,o.sessionKey,n.sessionKey),sessionKeyAlgorithm:6===e?null:Xn.selectUint8(t,o.sessionKeyAlgorithm,n.sessionKeyAlgorithm)}}if(a&&(6===e||qn.read(qn.symmetric,o.sessionKeyAlgorithm)))return o;throw Error("Decryption error")}case qn.publicKey.x25519:case qn.publicKey.x448:return{sessionKeyAlgorithm:null,sessionKey:r};default:throw Error("Unsupported public key algorithm")}}(this.version,this.publicKeyAlgorithm,i,t);if(3===this.version){const e=this.publicKeyAlgorithm!==qn.publicKey.x25519&&this.publicKeyAlgorithm!==qn.publicKey.x448;if(this.sessionKeyAlgorithm=e?a:this.sessionKeyAlgorithm,s.length!==Sa(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}this.sessionKey=s}}function Eu(e,t,r,n){switch(t){case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaEncryptSign:case qn.publicKey.elgamal:case qn.publicKey.ecdh:return Xn.concatUint8Array([new Uint8Array(6===e?[]:[r]),n,Xn.writeChecksum(n.subarray(n.length%8))]);case qn.publicKey.x25519:case qn.publicKey.x448:return n;default:throw Error("Unsupported public key algorithm")}}class Ku{static get tag(){return qn.packet.symEncryptedSessionKey}constructor(e=Wn){this.version=e.aeadProtect?6:4,this.sessionKey=null,this.sessionKeyEncryptionAlgorithm=null,this.sessionKeyAlgorithm=null,this.aeadAlgorithm=qn.write(qn.aead,e.preferredAEADAlgorithm),this.encrypted=null,this.s2k=null,this.iv=null}read(e){let t=0;if(this.version=e[t++],4!==this.version&&5!==this.version&&6!==this.version)throw new os(`Version ${this.version} of the SKESK packet is unsupported.`);6===this.version&&t++;const r=e[t++];this.version>=5&&(this.aeadAlgorithm=e[t++],6===this.version&&t++);const n=e[t++];if(this.s2k=rc(n),t+=this.s2k.read(e.subarray(t,e.length)),this.version>=5){const r=Vo(this.aeadAlgorithm,!0);this.iv=e.subarray(t,t+=r.ivLength)}this.version>=5||t<e.length?(this.encrypted=e.subarray(t,e.length),this.sessionKeyEncryptionAlgorithm=r):this.sessionKeyAlgorithm=r}write(){const e=null===this.encrypted?this.sessionKeyAlgorithm:this.sessionKeyEncryptionAlgorithm;let t;const r=this.s2k.write();if(6===this.version){const n=r.length,i=3+n+this.iv.length;t=Xn.concatUint8Array([new Uint8Array([this.version,i,e,this.aeadAlgorithm,n]),r,this.iv,this.encrypted])}else 5===this.version?t=Xn.concatUint8Array([new Uint8Array([this.version,e,this.aeadAlgorithm]),r,this.iv,this.encrypted]):(t=Xn.concatUint8Array([new Uint8Array([this.version,e]),r]),null!==this.encrypted&&(t=Xn.concatUint8Array([t,this.encrypted])));return t}async decrypt(e){const t=null!==this.sessionKeyEncryptionAlgorithm?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm,{blockSize:r,keySize:n}=Sa(t),i=await this.s2k.produceKey(e,n);if(this.version>=5){const e=Vo(this.aeadAlgorithm,!0),r=new Uint8Array([192|Ku.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),s=6===this.version?await Ua(qn.hash.sha256,i,new Uint8Array,r,n):i,a=await e(t,s);this.sessionKey=await a.decrypt(this.encrypted,this.iv,r)}else if(null!==this.encrypted){const e=await wo(t,i,this.encrypted,new Uint8Array(r));if(this.sessionKeyAlgorithm=qn.write(qn.symmetric,e[0]),this.sessionKey=e.subarray(1,e.length),this.sessionKey.length!==Sa(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}else this.sessionKey=i}async encrypt(e,t=Wn){const r=null!==this.sessionKeyEncryptionAlgorithm?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm;this.sessionKeyEncryptionAlgorithm=r,this.s2k=function(e){const{s2kType:t}=e;if(!tc.has(t))throw Error("The provided `config.s2kType` value is not allowed");return rc(t,e)}(t),this.s2k.generateSalt();const{blockSize:n,keySize:i}=Sa(r),s=await this.s2k.produceKey(e,i);if(null===this.sessionKey&&(this.sessionKey=oo(this.sessionKeyAlgorithm)),this.version>=5){const e=Vo(this.aeadAlgorithm);this.iv=Ai(e.ivLength);const t=new Uint8Array([192|Ku.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),n=6===this.version?await Ua(qn.hash.sha256,s,new Uint8Array,t,i):s,a=await e(r,n);this.encrypted=await a.encrypt(this.sessionKey,this.iv,t)}else{const e=Xn.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]),this.sessionKey]);this.encrypted=await go(r,s,e,new Uint8Array(n))}}}class Pu{static get tag(){return qn.packet.publicKey}constructor(e=new Date,t=Wn){this.version=t.v6Keys?6:4,this.created=Xn.normalizeDate(e),this.algorithm=null,this.publicParams=null,this.expirationTimeV3=0,this.fingerprint=null,this.keyID=null}static fromSecretKeyPacket(e){const t=new Pu,{version:r,created:n,algorithm:i,publicParams:s,keyID:a,fingerprint:o}=e;return t.version=r,t.created=n,t.algorithm=i,t.publicParams=s,t.keyID=a,t.fingerprint=o,t}async read(e,t=Wn){let r=0;if(this.version=e[r++],5===this.version&&!t.enableParsingV5Entities)throw new os("Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(4===this.version||5===this.version||6===this.version){this.created=Xn.readDate(e.subarray(r,r+4)),r+=4,this.algorithm=e[r++],this.version>=5&&(r+=4);const{read:t,publicParams:n}=function(e,t){let r=0;switch(e){case qn.publicKey.rsaEncrypt:case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaSign:{const e=Xn.readMPI(t.subarray(r));r+=e.length+2;const n=Xn.readMPI(t.subarray(r));return r+=n.length+2,{read:r,publicParams:{n:e,e:n}}}case qn.publicKey.dsa:{const e=Xn.readMPI(t.subarray(r));r+=e.length+2;const n=Xn.readMPI(t.subarray(r));r+=n.length+2;const i=Xn.readMPI(t.subarray(r));r+=i.length+2;const s=Xn.readMPI(t.subarray(r));return r+=s.length+2,{read:r,publicParams:{p:e,q:n,g:i,y:s}}}case qn.publicKey.elgamal:{const e=Xn.readMPI(t.subarray(r));r+=e.length+2;const n=Xn.readMPI(t.subarray(r));r+=n.length+2;const i=Xn.readMPI(t.subarray(r));return r+=i.length+2,{read:r,publicParams:{p:e,g:n,y:i}}}case qn.publicKey.ecdsa:{const e=new Ji;r+=e.read(t),co(e);const n=Xn.readMPI(t.subarray(r));return r+=n.length+2,{read:r,publicParams:{oid:e,Q:n}}}case qn.publicKey.eddsaLegacy:{const e=new Ji;if(r+=e.read(t),co(e),e.getName()!==qn.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let n=Xn.readMPI(t.subarray(r));return r+=n.length+2,n=Xn.leftPad(n,33),{read:r,publicParams:{oid:e,Q:n}}}case qn.publicKey.ecdh:{const e=new Ji;r+=e.read(t),co(e);const n=Xn.readMPI(t.subarray(r));r+=n.length+2;const i=new no;return r+=i.read(t.subarray(r)),{read:r,publicParams:{oid:e,Q:n,kdfParams:i}}}case qn.publicKey.ed25519:case qn.publicKey.ed448:case qn.publicKey.x25519:case qn.publicKey.x448:{const n=Xn.readExactSubarray(t,r,r+uo(e));return r+=n.length,{read:r,publicParams:{A:n}}}default:throw new os("Unknown public key encryption algorithm.")}}(this.algorithm,e.subarray(r));if(6===this.version&&n.oid&&(n.oid.getName()===qn.curve.curve25519Legacy||n.oid.getName()===qn.curve.ed25519Legacy))throw Error("Legacy curve25519 cannot be used with v6 keys");return this.publicParams=n,r+=t,await this.computeFingerprintAndKeyID(),r}throw new os(`Version ${this.version} of the key packet is unsupported.`)}write(){const e=[];e.push(new Uint8Array([this.version])),e.push(Xn.writeDate(this.created)),e.push(new Uint8Array([this.algorithm]));const t=ao(this.algorithm,this.publicParams);return this.version>=5&&e.push(Xn.writeNumber(t.length,4)),e.push(t),Xn.concatUint8Array(e)}writeForHash(e){const t=this.writePublicKey(),r=149+e,n=e>=5?4:2;return Xn.concatUint8Array([new Uint8Array([r]),Xn.writeNumber(t.length,n),t])}isDecrypted(){return null}getCreationTime(){return this.created}getKeyID(){return this.keyID}async computeFingerprintAndKeyID(){if(await this.computeFingerprint(),this.keyID=new Zc,this.version>=5)this.keyID.read(this.fingerprint.subarray(0,8));else{if(4!==this.version)throw Error("Unsupported key version");this.keyID.read(this.fingerprint.subarray(12,20))}}async computeFingerprint(){const e=this.writeForHash(this.version);if(this.version>=5)this.fingerprint=await Mi(qn.hash.sha256,e);else{if(4!==this.version)throw Error("Unsupported key version");this.fingerprint=await Mi(qn.hash.sha1,e)}}getFingerprintBytes(){return this.fingerprint}getFingerprint(){return Xn.uint8ArrayToHex(this.getFingerprintBytes())}hasSameFingerprintAs(e){return this.version===e.version&&Xn.equalsUint8Array(this.writePublicKey(),e.writePublicKey())}getAlgorithmInfo(){const e={};e.algorithm=qn.read(qn.publicKey,this.algorithm);const t=this.publicParams.n||this.publicParams.p;return t?e.bits=Xn.uint8ArrayBitLength(t):this.publicParams.oid&&(e.curve=this.publicParams.oid.getName()),e}}Pu.prototype.readPublicKey=Pu.prototype.read,Pu.prototype.writePublicKey=Pu.prototype.write;const Uu=Xn.constructAllowedPackets([Yc,pu,su,ru]);class Du{constructor(e){this.packets=e||new ou}write(){return this.packets.write()}armor(e=Wn){const t=this.packets.some(e=>e.constructor.tag===ru.tag&&6!==e.version);return hi(qn.armor.signature,this.write(),void 0,void 0,void 0,t,e)}getSigningKeyIDs(){return this.packets.map(e=>e.issuerKeyID)}}async function xu(e,t,r,n,i=new Date,s){let a,o;for(let c=e.length-1;c>=0;c--)try{(!a||e[c].created>=a.created)&&(await e[c].verify(t,r,n,i,void 0,s),a=e[c])}catch(e){o=e}if(!a)throw Xn.wrapError(`Could not find valid ${qn.read(qn.signature,r)} signature in key ${t.getKeyID().toHex()}`.replace("certGeneric ","self-").replace(/([a-z])([A-Z])/g,(e,t,r)=>t+" "+r.toLowerCase()),o);return a}function _u(e,t,r=new Date){const n=Xn.normalizeDate(r);if(null!==n){const r=Bu(e,t);return!(e.created<=n&&n<r)}return!1}async function Cu(e,t,r,n,i,s,a=[],o=!1,c){if(r.isDummy())throw Error("Cannot sign with a gnu-dummy key.");if(!r.isDecrypted())throw Error("Signing key is not decrypted.");const u=new ru;return Object.assign(u,n),u.publicKeyAlgorithm=r.algorithm,u.hashAlgorithm=await async function(e,t,r=new Date,n=[],i){const s=qn.hash.sha256,a=i.preferredHashAlgorithm,o=await Promise.all(e.map(async(e,t)=>(await e.getPrimarySelfSignature(r,n[t],i)).preferredHashAlgorithms||[])),c=new Map;for(const e of o)for(const t of e)try{const e=qn.write(qn.hash,t);c.set(e,c.has(e)?c.get(e)+1:1)}catch{}const u=t=>0===e.length||c.get(t)===e.length||t===s,l=()=>{if(0===c.size)return s;const e=Array.from(c.keys()).filter(e=>u(e)).sort((e,t)=>Ri(e)-Ri(t))[0];return Ri(e)>=Ri(s)?e:s};if(new Set([qn.publicKey.ecdsa,qn.publicKey.eddsaLegacy,qn.publicKey.ed25519,qn.publicKey.ed448]).has(t.algorithm)){const e=function(e,t){switch(e){case qn.publicKey.ecdsa:case qn.publicKey.eddsaLegacy:return function(e){return Ra[e.getName()].hash}(t);case qn.publicKey.ed25519:case qn.publicKey.ed448:return ds(e);default:throw Error("Unknown elliptic signing algo")}}(t.algorithm,t.publicParams.oid),r=u(a),n=Ri(a)>=Ri(e);if(r&&n)return a;{const t=l();return Ri(t)>=Ri(e)?t:e}}return u(a)?a:l()}(t,r,i,s,c),u.rawNotations=[...a],await u.sign(r,e,i,o,c),u}async function Iu(e,t,r,n=new Date,i){(e=e[r])&&(t[r].length?await Promise.all(e.map(async function(e){e.isExpired(n)||i&&!await i(e)||t[r].some(function(t){return Xn.equalsUint8Array(t.writeParams(),e.writeParams())})||t[r].push(e)})):t[r]=e)}async function Tu(e,t,r,n,i,s,a=new Date,o){s=s||e;const c=[];return await Promise.all(n.map(async function(e){try{if(!i||e.issuerKeyID.equals(i.issuerKeyID)){const n=![qn.reasonForRevocation.keyRetired,qn.reasonForRevocation.keySuperseded,qn.reasonForRevocation.userIDInvalid].includes(e.reasonForRevocationFlag);await e.verify(s,t,r,n?null:a,!1,o),c.push(e.issuerKeyID)}}catch(e){}})),i?(i.revoked=!!c.some(e=>e.equals(i.issuerKeyID))||i.revoked||!1,i.revoked):c.length>0}function Bu(e,t){let r;return!1===t.keyNeverExpires&&(r=e.created.getTime()+1e3*t.keyExpirationTime),r?new Date(r):1/0}function $u(e,t,r){switch(e.algorithm){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaSign:case qn.publicKey.dsa:case qn.publicKey.ecdsa:case qn.publicKey.eddsaLegacy:case qn.publicKey.ed25519:case qn.publicKey.ed448:if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!t.keyFlags||!!(t.keyFlags[0]&qn.keyFlags.signData);default:return!1}}function Lu(e,t,r){switch(e.algorithm){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaEncrypt:case qn.publicKey.elgamal:case qn.publicKey.ecdh:case qn.publicKey.x25519:case qn.publicKey.x448:if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!t.keyFlags||!!(t.keyFlags[0]&qn.keyFlags.encryptCommunication)||!!(t.keyFlags[0]&qn.keyFlags.encryptStorage);default:return!1}}function Nu(e,t){const r=qn.write(qn.publicKey,e.algorithm),n=e.getAlgorithmInfo();if(t.rejectPublicKeyAlgorithms.has(r))throw Error(n.algorithm+" keys are considered too weak.");switch(r){case qn.publicKey.rsaEncryptSign:case qn.publicKey.rsaSign:case qn.publicKey.rsaEncrypt:if(n.bits<t.minRSABits)throw Error(`RSA keys shorter than ${t.minRSABits} bits are considered too weak.`);break;case qn.publicKey.ecdsa:case qn.publicKey.eddsaLegacy:case qn.publicKey.ecdh:if(t.rejectCurves.has(n.curve))throw Error(`Support for ${n.algorithm} keys using curve ${n.curve} is disabled.`)}}class Mu{constructor(e,t){this.userID=e.constructor.tag===qn.packet.userID?e:null,this.userAttribute=e.constructor.tag===qn.packet.userAttribute?e:null,this.selfCertifications=[],this.otherCertifications=[],this.revocationSignatures=[],this.mainKey=t}toPacketList(){const e=new ou;return e.push(this.userID||this.userAttribute),e.push(...this.revocationSignatures),e.push(...this.selfCertifications),e.push(...this.otherCertifications),e}clone(){const e=new Mu(this.userID||this.userAttribute,this.mainKey);return e.selfCertifications=[...this.selfCertifications],e.otherCertifications=[...this.otherCertifications],e.revocationSignatures=[...this.revocationSignatures],e}async certify(e,t,r){const n=this.mainKey.keyPacket,i={userID:this.userID,userAttribute:this.userAttribute,key:n},s=new Mu(i.userID||i.userAttribute,this.mainKey);return s.otherCertifications=await Promise.all(e.map(async function(e){if(!e.isPrivate())throw Error("Need private key for signing");if(e.hasSameFingerprintAs(n))throw Error("The user's own key can only be used for self-certifications");const s=await e.getSigningKey(void 0,t,void 0,r);return Cu(i,[e],s.keyPacket,{signatureType:qn.signature.certGeneric,keyFlags:[qn.keyFlags.certifyKeys|qn.keyFlags.signData]},t,void 0,void 0,void 0,r)})),await s.update(this,t,r),s}async isRevoked(e,t,r=new Date,n=Wn){const i=this.mainKey.keyPacket;return Tu(i,qn.signature.certRevocation,{key:i,userID:this.userID,userAttribute:this.userAttribute},this.revocationSignatures,e,t,r,n)}async verifyCertificate(e,t,r=new Date,n){const i=this,s=this.mainKey.keyPacket,a={userID:this.userID,userAttribute:this.userAttribute,key:s},{issuerKeyID:o}=e,c=t.filter(e=>e.getKeys(o).length>0);return 0===c.length?null:(await Promise.all(c.map(async t=>{const s=await t.getSigningKey(o,e.created,void 0,n);if(e.revoked||await i.isRevoked(e,s.keyPacket,r,n))throw Error("User certificate is revoked");try{await e.verify(s.keyPacket,qn.signature.certGeneric,a,r,void 0,n)}catch(e){throw Xn.wrapError("User certificate is invalid",e)}})),!0)}async verifyAllCertifications(e,t=new Date,r){const n=this,i=this.selfCertifications.concat(this.otherCertifications);return Promise.all(i.map(async i=>({keyID:i.issuerKeyID,valid:await n.verifyCertificate(i,e,t,r).catch(()=>!1)})))}async verify(e=new Date,t){if(!this.selfCertifications.length)throw Error("No self-certifications found");const r=this,n=this.mainKey.keyPacket,i={userID:this.userID,userAttribute:this.userAttribute,key:n};let s;for(let a=this.selfCertifications.length-1;a>=0;a--)try{const s=this.selfCertifications[a];if(s.revoked||await r.isRevoked(s,void 0,e,t))throw Error("Self-certification is revoked");try{await s.verify(n,qn.signature.certGeneric,i,e,void 0,t)}catch(e){throw Xn.wrapError("Self-certification is invalid",e)}return!0}catch(e){s=e}throw s}async update(e,t,r){const n=this.mainKey.keyPacket,i={userID:this.userID,userAttribute:this.userAttribute,key:n};await Iu(e,this,"selfCertifications",t,async function(e){try{return await e.verify(n,qn.signature.certGeneric,i,t,!1,r),!0}catch(e){return!1}}),await Iu(e,this,"otherCertifications",t),await Iu(e,this,"revocationSignatures",t,function(e){return Tu(n,qn.signature.certRevocation,i,[e],void 0,void 0,t,r)})}async revoke(e,{flag:t=qn.reasonForRevocation.noReason,string:r=""}={},n=new Date,i=Wn){const s={userID:this.userID,userAttribute:this.userAttribute,key:e},a=new Mu(s.userID||s.userAttribute,this.mainKey);return a.revocationSignatures.push(await Cu(s,[],e,{signatureType:qn.signature.certRevocation,reasonForRevocationFlag:qn.write(qn.reasonForRevocation,t),reasonForRevocationString:r},n,void 0,void 0,!1,i)),await a.update(this),a}}class Ru{constructor(e,t){this.keyPacket=e,this.bindingSignatures=[],this.revocationSignatures=[],this.mainKey=t}toPacketList(){const e=new ou;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.bindingSignatures),e}clone(){const e=new Ru(this.keyPacket,this.mainKey);return e.bindingSignatures=[...this.bindingSignatures],e.revocationSignatures=[...this.revocationSignatures],e}async isRevoked(e,t,r=new Date,n=Wn){const i=this.mainKey.keyPacket;return Tu(i,qn.signature.subkeyRevocation,{key:i,bind:this.keyPacket},this.revocationSignatures,e,t,r,n)}async verify(e=new Date,t=Wn){const r=this.mainKey.keyPacket,n={key:r,bind:this.keyPacket},i=await xu(this.bindingSignatures,r,qn.signature.subkeyBinding,n,e,t);if(i.revoked||await this.isRevoked(i,null,e,t))throw Error("Subkey is revoked");if(_u(this.keyPacket,i,e))throw Error("Subkey is expired");return i}async getExpirationTime(e=new Date,t=Wn){const r=this.mainKey.keyPacket,n={key:r,bind:this.keyPacket};let i;try{i=await xu(this.bindingSignatures,r,qn.signature.subkeyBinding,n,e,t)}catch(e){return null}const s=Bu(this.keyPacket,i),a=i.getExpirationTime();return s<a?s:a}async update(e,t=new Date,r=Wn){const n=this.mainKey.keyPacket;if(!this.hasSameFingerprintAs(e))throw Error("Subkey update method: fingerprints of subkeys not equal");this.keyPacket.constructor.tag===qn.packet.publicSubkey&&e.keyPacket.constructor.tag===qn.packet.secretSubkey&&(this.keyPacket=e.keyPacket);const i=this,s={key:n,bind:i.keyPacket};await Iu(e,this,"bindingSignatures",t,async function(e){for(let t=0;t<i.bindingSignatures.length;t++)if(i.bindingSignatures[t].issuerKeyID.equals(e.issuerKeyID))return e.created>i.bindingSignatures[t].created&&(i.bindingSignatures[t]=e),!1;try{return await e.verify(n,qn.signature.subkeyBinding,s,t,void 0,r),!0}catch(e){return!1}}),await Iu(e,this,"revocationSignatures",t,function(e){return Tu(n,qn.signature.subkeyRevocation,s,[e],void 0,void 0,t,r)})}async revoke(e,{flag:t=qn.reasonForRevocation.noReason,string:r=""}={},n=new Date,i=Wn){const s={key:e,bind:this.keyPacket},a=new Ru(this.keyPacket,this.mainKey);return a.revocationSignatures.push(await Cu(s,[],e,{signatureType:qn.signature.subkeyRevocation,reasonForRevocationFlag:qn.write(qn.reasonForRevocation,t),reasonForRevocationString:r},n,void 0,void 0,!1,i)),await a.update(this),a}hasSameFingerprintAs(e){return this.keyPacket.hasSameFingerprintAs(e.keyPacket||e)}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","isDecrypted"].forEach(e=>{Ru.prototype[e]=function(){return this.keyPacket[e]()}});const Fu=Xn.constructAllowedPackets([ru]),Ou=new Set([qn.packet.publicKey,qn.packet.privateKey]),zu=new Set([qn.packet.publicKey,qn.packet.privateKey,qn.packet.publicSubkey,qn.packet.privateSubkey]);class ju{packetListToStructure(e,t=new Set){let r,n,i,s;for(const a of e){if(a instanceof ls){zu.has(a.tag)&&!s&&(s=Ou.has(a.tag)?Ou:zu);continue}const e=a.constructor.tag;if(s){if(!s.has(e))continue;s=null}if(t.has(e))throw Error("Unexpected packet type: "+e);switch(e){case qn.packet.publicKey:case qn.packet.secretKey:if(this.keyPacket)throw Error("Key block contains multiple keys");if(this.keyPacket=a,n=this.getKeyID(),!n)throw Error("Missing Key ID");break;case qn.packet.userID:case qn.packet.userAttribute:r=new Mu(a,this),this.users.push(r);break;case qn.packet.publicSubkey:case qn.packet.secretSubkey:r=null,i=new Ru(a,this),this.subkeys.push(i);break;case qn.packet.signature:switch(a.signatureType){case qn.signature.certGeneric:case qn.signature.certPersona:case qn.signature.certCasual:case qn.signature.certPositive:if(!r){Xn.printDebug("Dropping certification signatures without preceding user packet");continue}a.issuerKeyID.equals(n)?r.selfCertifications.push(a):r.otherCertifications.push(a);break;case qn.signature.certRevocation:r?r.revocationSignatures.push(a):this.directSignatures.push(a);break;case qn.signature.key:this.directSignatures.push(a);break;case qn.signature.subkeyBinding:if(!i){Xn.printDebug("Dropping subkey binding signature without preceding subkey packet");continue}i.bindingSignatures.push(a);break;case qn.signature.keyRevocation:this.revocationSignatures.push(a);break;case qn.signature.subkeyRevocation:if(!i){Xn.printDebug("Dropping subkey revocation signature without preceding subkey packet");continue}i.revocationSignatures.push(a)}}}}toPacketList(){const e=new ou;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.directSignatures),this.users.map(t=>e.push(...t.toPacketList())),this.subkeys.map(t=>e.push(...t.toPacketList())),e}clone(e=!1){const t=new this.constructor(this.toPacketList());return e&&t.getKeys().forEach(e=>{if(e.keyPacket=Object.create(Object.getPrototypeOf(e.keyPacket),Object.getOwnPropertyDescriptors(e.keyPacket)),!e.keyPacket.isDecrypted())return;const t={};Object.keys(e.keyPacket.privateParams).forEach(r=>{t[r]=new Uint8Array(e.keyPacket.privateParams[r])}),e.keyPacket.privateParams=t}),t}getSubkeys(e=null){return this.subkeys.filter(t=>!e||t.getKeyID().equals(e,!0))}getKeys(e=null){const t=[];return e&&!this.getKeyID().equals(e,!0)||t.push(this),t.concat(this.getSubkeys(e))}getKeyIDs(){return this.getKeys().map(e=>e.getKeyID())}getUserIDs(){return this.users.map(e=>e.userID?e.userID.userID:null).filter(e=>null!==e)}write(){return this.toPacketList().write()}async getSigningKey(e=null,t=new Date,r={},n=Wn){await this.verifyPrimaryKey(t,r,n);const i=this.keyPacket;try{Nu(i,n)}catch(e){throw Xn.wrapError("Could not verify primary key",e)}const s=this.subkeys.slice().sort((e,t)=>t.keyPacket.created-e.keyPacket.created||t.keyPacket.algorithm-e.keyPacket.algorithm);let a;for(const r of s)if(!e||r.getKeyID().equals(e))try{await r.verify(t,n);const e={key:i,bind:r.keyPacket},s=await xu(r.bindingSignatures,i,qn.signature.subkeyBinding,e,t,n);if(!$u(r.keyPacket,s,n))continue;if(!s.embeddedSignature)throw Error("Missing embedded signature");return await xu([s.embeddedSignature],r.keyPacket,qn.signature.keyBinding,e,t,n),Nu(r.keyPacket,n),r}catch(e){a=e}try{const s=await this.getPrimarySelfSignature(t,r,n);if((!e||i.getKeyID().equals(e))&&$u(i,s,n))return Nu(i,n),this}catch(e){a=e}throw Xn.wrapError("Could not find valid signing key packet in key "+this.getKeyID().toHex(),a)}async getEncryptionKey(e,t=new Date,r={},n=Wn){await this.verifyPrimaryKey(t,r,n);const i=this.keyPacket;try{Nu(i,n)}catch(e){throw Xn.wrapError("Could not verify primary key",e)}const s=this.subkeys.slice().sort((e,t)=>t.keyPacket.created-e.keyPacket.created||t.keyPacket.algorithm-e.keyPacket.algorithm);let a;for(const r of s)if(!e||r.getKeyID().equals(e))try{await r.verify(t,n);const e={key:i,bind:r.keyPacket},s=await xu(r.bindingSignatures,i,qn.signature.subkeyBinding,e,t,n);if(Lu(r.keyPacket,s,n))return Nu(r.keyPacket,n),r}catch(e){a=e}try{const s=await this.getPrimarySelfSignature(t,r,n);if((!e||i.getKeyID().equals(e))&&Lu(i,s,n))return Nu(i,n),this}catch(e){a=e}throw Xn.wrapError("Could not find valid encryption key packet in key "+this.getKeyID().toHex(),a)}async isRevoked(e,t,r=new Date,n=Wn){return Tu(this.keyPacket,qn.signature.keyRevocation,{key:this.keyPacket},this.revocationSignatures,e,t,r,n)}async verifyPrimaryKey(e=new Date,t={},r=Wn){const n=this.keyPacket;if(await this.isRevoked(null,null,e,r))throw Error("Primary key is revoked");if(_u(n,await this.getPrimarySelfSignature(e,t,r),e))throw Error("Primary key is expired");if(6!==n.version){const t=await xu(this.directSignatures,n,qn.signature.key,{key:n},e,r).catch(()=>{});if(t&&_u(n,t,e))throw Error("Primary key is expired")}}async getExpirationTime(e,t=Wn){let r;try{const n=await this.getPrimarySelfSignature(null,e,t),i=Bu(this.keyPacket,n),s=n.getExpirationTime(),a=6!==this.keyPacket.version&&await xu(this.directSignatures,this.keyPacket,qn.signature.key,{key:this.keyPacket},null,t).catch(()=>{});if(a){const e=Bu(this.keyPacket,a);r=Math.min(i,s,e)}else r=i<s?i:s}catch(e){r=null}return Xn.normalizeDate(r)}async getPrimarySelfSignature(e=new Date,t={},r=Wn){const n=this.keyPacket;if(6===n.version)return xu(this.directSignatures,n,qn.signature.key,{key:n},e,r);const{selfCertification:i}=await this.getPrimaryUser(e,t,r);return i}async getPrimaryUser(e=new Date,t={},r=Wn){const n=this.keyPacket,i=[];let s;for(let a=0;a<this.users.length;a++)try{const s=this.users[a];if(!s.userID)continue;if(void 0!==t.name&&s.userID.name!==t.name||void 0!==t.email&&s.userID.email!==t.email||void 0!==t.comment&&s.userID.comment!==t.comment)throw Error("Could not find user that matches that user ID");const o={userID:s.userID,key:n},c=await xu(s.selfCertifications,n,qn.signature.certGeneric,o,e,r);i.push({index:a,user:s,selfCertification:c})}catch(e){s=e}if(!i.length)throw s||Error("Could not find primary user");await Promise.all(i.map(async function(t){return t.selfCertification.revoked||t.user.isRevoked(t.selfCertification,null,e,r)}));const a=i.sort(function(e,t){const r=e.selfCertification,n=t.selfCertification;return n.revoked-r.revoked||r.isPrimaryUserID-n.isPrimaryUserID||r.created-n.created}).pop(),{user:o,selfCertification:c}=a;if(c.revoked||await o.isRevoked(c,null,e,r))throw Error("Primary user is revoked");return a}async update(e,t=new Date,r=Wn){if(!this.hasSameFingerprintAs(e))throw Error("Primary key fingerprints must be equal to update the key");if(!this.isPrivate()&&e.isPrivate()){if(this.subkeys.length!==e.subkeys.length||!this.subkeys.every(t=>e.subkeys.some(e=>t.hasSameFingerprintAs(e))))throw Error("Cannot update public key with private key if subkeys mismatch");return e.update(this,r)}const n=this.clone();return await Iu(e,n,"revocationSignatures",t,i=>Tu(n.keyPacket,qn.signature.keyRevocation,n,[i],null,e.keyPacket,t,r)),await Iu(e,n,"directSignatures",t),await Promise.all(e.users.map(async e=>{const i=n.users.filter(t=>e.userID&&e.userID.equals(t.userID)||e.userAttribute&&e.userAttribute.equals(t.userAttribute));if(i.length>0)await Promise.all(i.map(n=>n.update(e,t,r)));else{const t=e.clone();t.mainKey=n,n.users.push(t)}})),await Promise.all(e.subkeys.map(async e=>{const i=n.subkeys.filter(t=>t.hasSameFingerprintAs(e));if(i.length>0)await Promise.all(i.map(n=>n.update(e,t,r)));else{const t=e.clone();t.mainKey=n,n.subkeys.push(t)}})),n}async getRevocationCertificate(e=new Date,t=Wn){const r={key:this.keyPacket},n=await xu(this.revocationSignatures,this.keyPacket,qn.signature.keyRevocation,r,e,t),i=new ou;i.push(n);const s=6!==this.keyPacket.version;return hi(qn.armor.publicKey,i.write(),null,null,"This is a revocation certificate",s,t)}async applyRevocationCertificate(e,t=new Date,r=Wn){const n=await li(e),i=(await ou.fromBinary(n.data,Fu,r)).findPacket(qn.packet.signature);if(!i||i.signatureType!==qn.signature.keyRevocation)throw Error("Could not find revocation signature packet");if(!i.issuerKeyID.equals(this.getKeyID()))throw Error("Revocation signature does not match key");try{await i.verify(this.keyPacket,qn.signature.keyRevocation,{key:this.keyPacket},t,void 0,r)}catch(e){throw Xn.wrapError("Could not verify revocation signature",e)}const s=this.clone();return s.revocationSignatures.push(i),s}async signPrimaryUser(e,t,r,n=Wn){const{index:i,user:s}=await this.getPrimaryUser(t,r,n),a=await s.certify(e,t,n),o=this.clone();return o.users[i]=a,o}async signAllUsers(e,t=new Date,r=Wn){const n=this.clone();return n.users=await Promise.all(this.users.map(function(n){return n.certify(e,t,r)})),n}async verifyPrimaryUser(e,t=new Date,r,n=Wn){const i=this.keyPacket,{user:s}=await this.getPrimaryUser(t,r,n);return e?await s.verifyAllCertifications(e,t,n):[{keyID:i.getKeyID(),valid:await s.verify(t,n).catch(()=>!1)}]}async verifyAllUsers(e,t=new Date,r=Wn){const n=this.keyPacket,i=[];return await Promise.all(this.users.map(async s=>{const a=e?await s.verifyAllCertifications(e,t,r):[{keyID:n.getKeyID(),valid:await s.verify(t,r).catch(()=>!1)}];i.push(...a.map(e=>({userID:s.userID?s.userID.userID:null,userAttribute:s.userAttribute,keyID:e.keyID,valid:e.valid})))})),i}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","hasSameFingerprintAs"].forEach(e=>{ju.prototype[e]=Ru.prototype[e]});const Hu=Xn.constructAllowedPackets([Yc,pu,class{static get tag(){return qn.packet.aeadEncryptedData}constructor(){this.version=1,this.cipherAlgorithm=null,this.aeadAlgorithm=qn.aead.eax,this.chunkSizeByte=null,this.iv=null,this.encrypted=null,this.packets=null}async read(e){await $n(e,async e=>{const t=await e.readByte();if(1!==t)throw new os(`Version ${t} of the AEAD-encrypted data packet is not supported.`);this.cipherAlgorithm=await e.readByte(),this.aeadAlgorithm=await e.readByte(),this.chunkSizeByte=await e.readByte();const r=Vo(this.aeadAlgorithm,!0);this.iv=await e.readBytes(r.ivLength),this.encrypted=e.remainder()})}write(){return Xn.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.iv,this.encrypted])}async decrypt(e,t,r=Wn){this.packets=await ou.fromBinary(await ku(this,"decrypt",t,Ln(this.encrypted)),Au,r,new hu)}async encrypt(e,t,r=Wn){this.cipherAlgorithm=e;const{ivLength:n}=Vo(this.aeadAlgorithm,!0);this.iv=Ai(n),this.chunkSizeByte=r.aeadChunkSizeByte;const i=this.packets.write();this.encrypted=await ku(this,"encrypt",t,i)}},vu,class{static get tag(){return qn.packet.symmetricallyEncryptedData}constructor(){this.encrypted=null,this.packets=null}read(e){this.encrypted=e}write(){return this.encrypted}async decrypt(e,t,r=Wn){if(!r.allowUnauthenticatedMessages)throw Error("Message is not authenticated.");const{blockSize:n}=Sa(e),i=await Fn(Ln(this.encrypted)),s=await wo(e,t,i.subarray(n+2),i.subarray(2,n+2));this.packets=await ou.fromBinary(s,Uu,r)}async encrypt(e,t,r=Wn){const n=this.packets.write(),{blockSize:i}=Sa(e),s=await fo(e),a=await go(e,t,s,new Uint8Array(i)),o=await go(e,t,n,a.subarray(2));this.encrypted=Xn.concat([a,o])}},Su,Ku,su,ru]),Gu=Xn.constructAllowedPackets([Ku]),qu=Xn.constructAllowedPackets([ru]);class Wu{constructor(e){this.packets=e||new ou}getEncryptionKeyIDs(){const e=[];return this.packets.filterByTag(qn.packet.publicKeyEncryptedSessionKey).forEach(function(t){e.push(t.publicKeyID)}),e}getSigningKeyIDs(){const e=this.unwrapCompressed(),t=e.packets.filterByTag(qn.packet.onePassSignature);return t.length>0?t.map(e=>e.issuerKeyID):e.packets.filterByTag(qn.packet.signature).map(e=>e.issuerKeyID)}async decrypt(e,t,r,n=new Date,i=Wn){const s=this.packets.filterByTag(qn.packet.symmetricallyEncryptedData,qn.packet.symEncryptedIntegrityProtectedData,qn.packet.aeadEncryptedData);if(0===s.length)throw Error("No encrypted data found");const a=s[0],o=a.cipherAlgorithm,c=r||await this.decryptSessionKeys(e,t,o,n,i);let u=null;const l=Promise.all(c.map(async({algorithm:e,data:t})=>{if(!Xn.isUint8Array(t)||!a.cipherAlgorithm&&!Xn.isString(e))throw Error("Invalid session key for decryption.");try{const r=a.cipherAlgorithm||qn.write(qn.symmetric,e);await a.decrypt(r,t,i)}catch(e){Xn.printDebugError(e),u=e}}));if(On(a.encrypted),a.encrypted=null,await l,!a.packets||!a.packets.length)throw u||Error("Decryption failed.");const h=new Wu(a.packets);return a.packets=new ou,h}async decryptSessionKeys(e,t,r,n=new Date,i=Wn){let s,a=[];if(t){const e=this.packets.filterByTag(qn.packet.symEncryptedSessionKey);if(0===e.length)throw Error("No symmetrically encrypted session key packet found.");await Promise.all(t.map(async function(t,r){let n;n=r?await ou.fromBinary(e.write(),Gu,i):e,await Promise.all(n.map(async function(e){try{await e.decrypt(t),a.push(e)}catch(e){Xn.printDebugError(e),e instanceof Qo&&(s=e)}}))}))}else{if(!e)throw Error("No key or password specified.");{const t=this.packets.filterByTag(qn.packet.publicKeyEncryptedSessionKey);if(0===t.length)throw Error("No public key encrypted session key packet found.");await Promise.all(t.map(async function(t){await Promise.all(e.map(async function(e){let o;try{o=(await e.getDecryptionKeys(t.publicKeyID,null,void 0,i)).map(e=>e.keyPacket)}catch(e){return void(s=e)}let c=[qn.symmetric.aes256,qn.symmetric.aes128,qn.symmetric.tripledes,qn.symmetric.cast5];try{const t=await e.getPrimarySelfSignature(n,void 0,i);t.preferredSymmetricAlgorithms&&(c=c.concat(t.preferredSymmetricAlgorithms))}catch(e){}await Promise.all(o.map(async function(e){if(!e.isDecrypted())throw Error("Decryption key is not decrypted.");if(!i.constantTimePKCS1Decryption||t.publicKeyAlgorithm!==qn.publicKey.rsaEncrypt&&t.publicKeyAlgorithm!==qn.publicKey.rsaEncryptSign&&t.publicKeyAlgorithm!==qn.publicKey.rsaSign&&t.publicKeyAlgorithm!==qn.publicKey.elgamal)try{await t.decrypt(e);const n=r||t.sessionKeyAlgorithm;if(n&&!c.includes(qn.write(qn.symmetric,n)))throw Error("A non-preferred symmetric algorithm was used.");a.push(t)}catch(e){Xn.printDebugError(e),s=e}else{const n=t.write();await Promise.all((r?[r]:Array.from(i.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)).map(async t=>{const r=new Su;r.read(n);const i={sessionKeyAlgorithm:t,sessionKey:oo(t)};try{await r.decrypt(e,i),a.push(r)}catch(e){Xn.printDebugError(e),s=e}}))}}))})),On(t.encrypted),t.encrypted=null}))}}if(a.length>0){if(a.length>1){const e=new Set;a=a.filter(t=>{const r=t.sessionKeyAlgorithm+Xn.uint8ArrayToString(t.sessionKey);return!e.has(r)&&(e.add(r),!0)})}return a.map(e=>({data:e.sessionKey,algorithm:e.sessionKeyAlgorithm&&qn.read(qn.symmetric,e.sessionKeyAlgorithm)}))}throw s||Error("Session key decryption failed.")}getLiteralData(){const e=this.unwrapCompressed().packets.findPacket(qn.packet.literalData);return e&&e.getBytes()||null}getFilename(){const e=this.unwrapCompressed().packets.findPacket(qn.packet.literalData);return e&&e.getFilename()||null}getText(){const e=this.unwrapCompressed().packets.findPacket(qn.packet.literalData);return e?e.getText():null}static async generateSessionKey(e=[],t=new Date,r=[],n=Wn){const{symmetricAlgo:i,aeadAlgo:s}=await async function(e=[],t=new Date,r=[],n=Wn){const i=await Promise.all(e.map((e,i)=>e.getPrimarySelfSignature(t,r[i],n)));if(e.length?i.every(e=>e.features&&e.features[0]&qn.features.seipdv2):n.aeadProtect){const e={symmetricAlgo:qn.symmetric.aes128,aeadAlgo:qn.aead.ocb},t=[{symmetricAlgo:n.preferredSymmetricAlgorithm,aeadAlgo:n.preferredAEADAlgorithm},{symmetricAlgo:n.preferredSymmetricAlgorithm,aeadAlgo:qn.aead.ocb},{symmetricAlgo:qn.symmetric.aes128,aeadAlgo:n.preferredAEADAlgorithm}];for(const e of t)if(i.every(t=>t.preferredCipherSuites&&t.preferredCipherSuites.some(t=>t[0]===e.symmetricAlgo&&t[1]===e.aeadAlgo)))return e;return e}const s=qn.symmetric.aes128,a=n.preferredSymmetricAlgorithm;return{symmetricAlgo:i.every(e=>e.preferredSymmetricAlgorithms&&e.preferredSymmetricAlgorithms.includes(a))?a:s,aeadAlgo:void 0}}(e,t,r,n),a=qn.read(qn.symmetric,i),o=s?qn.read(qn.aead,s):void 0;return await Promise.all(e.map(e=>e.getEncryptionKey().catch(()=>null).then(e=>{if(e&&(e.keyPacket.algorithm===qn.publicKey.x25519||e.keyPacket.algorithm===qn.publicKey.x448)&&!o&&!Xn.isAES(i))throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.")}))),{data:oo(i),algorithm:a,aeadAlgorithm:o}}async encrypt(e,t,r,n=!1,i=[],s=new Date,a=[],o=Wn){if(r){if(!Xn.isUint8Array(r.data)||!Xn.isString(r.algorithm))throw Error("Invalid session key for encryption.")}else if(e&&e.length)r=await Wu.generateSessionKey(e,s,a,o);else{if(!t||!t.length)throw Error("No keys, passwords, or session key provided.");r=await Wu.generateSessionKey(void 0,void 0,void 0,o)}const{data:c,algorithm:u,aeadAlgorithm:l}=r,h=await Wu.encryptSessionKey(c,u,l,e,t,n,i,s,a,o),y=vu.fromObject({version:l?2:1,aeadAlgorithm:l?qn.write(qn.aead,l):null});y.packets=this.packets;const p=qn.write(qn.symmetric,u);return await y.encrypt(p,c,o),h.packets.push(y),y.packets=new ou,h}static async encryptSessionKey(e,t,r,n,i,s=!1,a=[],o=new Date,c=[],u=Wn){const l=new ou,h=qn.write(qn.symmetric,t),y=r&&qn.write(qn.aead,r);if(n){const t=await Promise.all(n.map(async function(t,r){const n=await t.getEncryptionKey(a[r],o,c,u),i=Su.fromObject({version:y?6:3,encryptionKeyPacket:n.keyPacket,anonymousRecipient:s,sessionKey:e,sessionKeyAlgorithm:h});return await i.encrypt(n.keyPacket),delete i.sessionKey,i}));l.push(...t)}if(i){const t=async function(e,t){try{return await e.decrypt(t),1}catch(e){return 0}},r=(e,t)=>e+t,n=async function(e,s,a,o){const c=new Ku(u);return c.sessionKey=e,c.sessionKeyAlgorithm=s,a&&(c.aeadAlgorithm=a),await c.encrypt(o,u),u.passwordCollisionCheck&&1!==(await Promise.all(i.map(e=>t(c,e)))).reduce(r)?n(e,s,o):(delete c.sessionKey,c)},s=await Promise.all(i.map(t=>n(e,h,y,t)));l.push(...s)}return new Wu(l)}async sign(e=[],t=[],r=null,n=[],i=new Date,s=[],a=[],o=[],c=Wn){const u=new ou,l=this.packets.findPacket(qn.packet.literalData);if(!l)throw Error("No literal data packet to sign.");const h=await Vu(l,e,t,r,n,i,s,a,o,!1,c),y=h.map((e,t)=>su.fromSignaturePacket(e,0===t)).reverse();return u.push(...y),u.push(l),u.push(...h),new Wu(u)}compress(e,t=Wn){if(e===qn.compression.uncompressed)return this;const r=new pu(t);r.algorithm=e,r.packets=this.packets;const n=new ou;return n.push(r),new Wu(n)}async signDetached(e=[],t=[],r=null,n=[],i=[],s=new Date,a=[],o=[],c=Wn){const u=this.packets.findPacket(qn.packet.literalData);if(!u)throw Error("No literal data packet to sign.");return new Du(await Vu(u,e,t,r,n,i,s,a,o,!0,c))}async verify(e,t=new Date,r=Wn){const n=this.unwrapCompressed(),i=n.packets.filterByTag(qn.packet.literalData);if(1!==i.length)throw Error("Can only verify message with one literal data packet.");let s=n.packets;bn(s.stream)&&(s=s.concat(await Fn(s.stream,e=>e||[])));const a=s.filterByTag(qn.packet.onePassSignature).reverse(),o=s.filterByTag(qn.packet.signature);return a.length&&!o.length&&Xn.isStream(s.stream)&&!bn(s.stream)?(await Promise.all(a.map(async e=>{e.correspondingSig=new Promise((t,r)=>{e.correspondingSigResolve=t,e.correspondingSigReject=r}),e.signatureData=zn(async()=>(await e.correspondingSig).signatureData),e.hashed=Fn(await e.hash(e.signatureType,i[0],void 0,!1)),e.hashed.catch(()=>{})})),s.stream=Bn(s.stream,async(e,t)=>{const r=jn(e),n=Hn(t);try{for(let e=0;e<a.length;e++){const{value:t}=await r.read();a[e].correspondingSigResolve(t)}await r.readToEnd(),await n.ready,await n.close()}catch(e){a.forEach(t=>{t.correspondingSigReject(e)}),await n.abort(e)}}),Xu(a,i,e,t,!1,r)):Xu(o,i,e,t,!1,r)}verifyDetached(e,t,r=new Date,n=Wn){const i=this.unwrapCompressed().packets.filterByTag(qn.packet.literalData);if(1!==i.length)throw Error("Can only verify message with one literal data packet.");return Xu(e.packets.filterByTag(qn.packet.signature),i,t,r,!0,n)}unwrapCompressed(){const e=this.packets.filterByTag(qn.packet.compressedData);return e.length?new Wu(e[0].packets):this}async appendSignature(e,t=Wn){await this.packets.read(Xn.isUint8Array(e)?e:(await li(e)).data,qu,t)}write(){return this.packets.write()}armor(e=Wn){const t=this.packets[this.packets.length-1],r=t.constructor.tag===vu.tag?2!==t.version:this.packets.some(e=>e.constructor.tag===ru.tag&&6!==e.version);return hi(qn.armor.message,this.write(),null,null,null,r,e)}}async function Vu(e,t,r=[],n=null,i=[],s=new Date,a=[],o=[],c=[],u=!1,l=Wn){const h=new ou,y=null===e.text?qn.signature.binary:qn.signature.text;if(await Promise.all(t.map(async(t,n)=>{const h=a[n];if(!t.isPrivate())throw Error("Need private key for signing");const p=await t.getSigningKey(i[n],s,h,l);return Cu(e,r.length?r:[t],p.keyPacket,{signatureType:y},s,o,c,u,l)})).then(e=>{h.push(...e)}),n){const e=n.packets.filterByTag(qn.packet.signature);h.push(...e)}return h}async function Xu(e,t,r,n=new Date,i=!1,s=Wn){return Promise.all(e.filter(function(e){return["text","binary"].includes(qn.read(qn.signature,e.signatureType))}).map(async function(e){return async function(e,t,r,n=new Date,i=!1,s=Wn){let a,o;for(const t of r){const r=t.getKeys(e.issuerKeyID);if(r.length>0){a=t,o=r[0];break}}const c=e instanceof su?e.correspondingSig:e,u={keyID:e.issuerKeyID,verified:(async()=>{if(!o)throw Error("Could not find signing key with key ID "+e.issuerKeyID.toHex());await e.verify(o.keyPacket,e.signatureType,t[0],n,i,s);const r=await c;if(o.getCreationTime()>r.created)throw Error("Key is newer than the signature");try{await a.getSigningKey(o.getKeyID(),r.created,void 0,s)}catch(e){if(!s.allowInsecureVerificationWithReformattedKeys||!e.message.match(/Signature creation time is in the future/))throw e;await a.getSigningKey(o.getKeyID(),n,void 0,s)}return!0})(),signature:(async()=>{const e=await c,t=new ou;return e&&t.push(e),new Du(t)})()};return u.signature.catch(()=>{}),u.verified.catch(()=>{}),u}(e,t,r,n,i,s)}))}async function Qu({text:e,binary:t,filename:r,date:n=new Date,format:i=(void 0!==e?"utf8":"binary"),...s}){const a=void 0!==e?e:t;if(void 0===a)throw Error("createMessage: must pass options object containing `text` or `binary`");if(e&&!Xn.isString(e)&&!Xn.isStream(e))throw Error("createMessage: options.text must be a string or stream");if(t&&!Xn.isUint8Array(t)&&!Xn.isStream(t))throw Error("createMessage: options.binary must be a Uint8Array or stream");const o=Object.keys(s);if(o.length>0)throw Error("Unknown option: "+o.join(", "));const c=Xn.isStream(a),u=new Yc(n);void 0!==e?u.setText(a,qn.write(qn.literal,i)):u.setBytes(a,qn.write(qn.literal,i)),void 0!==r&&u.setFilename(r);const l=new ou;l.push(u);const h=new Wu(l);return h.fromStream=c,h}async function Yu({message:e,encryptionKeys:t,signingKeys:r,passwords:n,sessionKey:i,format:s="armored",signature:a=null,wildcard:o=!1,signingKeyIDs:c=[],encryptionKeyIDs:u=[],date:l=new Date,signingUserIDs:h=[],encryptionUserIDs:y=[],signatureNotations:p=[],config:d,...f}){if(el(d={...Wn,...d}),Zu(e),function(e){if("armored"!==e&&"binary"!==e&&"object"!==e)throw Error("Unsupported format "+e)}(s),t=tl(t),r=tl(r),n=tl(n),c=tl(c),u=tl(u),h=tl(h),y=tl(y),p=tl(p),f.detached)throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");if(f.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");if(f.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");if(void 0!==f.armor)throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");const g=Object.keys(f);if(g.length>0)throw Error("Unknown option: "+g.join(", "));r||(r=[]);try{if((r.length||a)&&(e=await e.sign(r,t,a,c,l,h,u,p,d)),e=e.compress(await async function(e=[],t=new Date,r=[],n=Wn){const i=qn.compression.uncompressed,s=n.preferredCompressionAlgorithm,a=await Promise.all(e.map(async function(e,i){const a=(await e.getPrimarySelfSignature(t,r[i],n)).preferredCompressionAlgorithms;return!!a&&a.indexOf(s)>=0}));return a.every(Boolean)?s:i}(t,l,y,d),d),e=await e.encrypt(t,n,i,o,u,l,y,d),"object"===s)return e;const f="armored"===s?e.armor(d):e.write();return await rl(f)}catch(e){throw Xn.wrapError("Error encrypting message",e)}}function Zu(e){if(!(e instanceof Wu))throw Error("Parameter [message] needs to be of type Message")}const Ju=Object.keys(Wn).length;function el(e){const t=Object.keys(e);if(t.length!==Ju)for(const e of t)if(void 0===Wn[e])throw Error("Unknown config property: "+e)}function tl(e){return e&&!Xn.isArray(e)&&(e=[e]),e}async function rl(e){return"array"===Xn.isStream(e)?Fn(e):e}var nl=(e,t)=>{try{navigator.clipboard.readText().then(e=>Ve(t,e,!0))}catch(e){Ve(t,"  : "+e)}},il=(e,t,r)=>Ve(t,cn(or(r)),!0),sl=(e,t,r)=>{try{Ve(t,un(or(r)),!0)}catch(e){Ve(t," :  Base64  .")}},al=mr('<button type="button"></button> <button type="button"></button>',1),ol=(e,t,r,n)=>Ve(t,or(r)?an(cn(or(n))):an(or(n)),!0),cl=(e,t,r,n)=>Ve(t,or(r)?un(on(function(e){let t,r;try{const n=sn(e,Vr.__wbindgen_malloc,Vr.__wbindgen_realloc),i=tn,s=Vr.ext_encode(n,i);return t=s[0],r=s[1],en(s[0],s[1])}finally{Vr.__wbindgen_free(t,r,1)}}(or(n)))):on(or(n)),!0),ul=mr('<button type="button"></button> <button type="button"></button> <fieldset><label><input type="checkbox" role="switch"/> <span data-tooltip=" Base64   ASCII     .">Base64 </span></label></fieldset>',1),ll=(e,t)=>{try{navigator.clipboard.readText().then(e=>Ve(t,e,!0))}catch(e){Ve(t,"  : "+e)}},hl=async(e,t,r,n)=>{const i=await Qu({text:or(t)});console.log(i),Ve(n,await Yu({message:i,passwords:[or(r)]}),!0)},yl=async(e,t,r,n)=>{const i=await Qu({text:or(t)});console.log(i),Ve(n,an(await Yu({message:i,passwords:[or(r)]})),!0)},pl=async(e,t,r,n)=>{try{const e=await async function({armoredMessage:e,binaryMessage:t,config:r,...n}){r={...Wn,...r};let i=e||t;if(!i)throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");if(e&&!Xn.isString(e)&&!Xn.isStream(e))throw Error("readMessage: options.armoredMessage must be a string or stream");if(t&&!Xn.isUint8Array(t)&&!Xn.isStream(t))throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");const s=Object.keys(n);if(s.length>0)throw Error("Unknown option: "+s.join(", "));const a=Xn.isStream(i);if(e){const{type:e,data:t}=await li(i);if(e!==qn.armor.message)throw Error("Armored text not of type message");i=t}const o=await ou.fromBinary(i,Hu,r,new hu),c=new Wu(o);return c.fromStream=a,c}({armoredMessage:or(t)}),{data:i}=await async function({message:e,decryptionKeys:t,passwords:r,sessionKeys:n,verificationKeys:i,expectSigned:s=!1,format:a="utf8",signature:o=null,date:c=new Date,config:u,...l}){if(el(u={...Wn,...u}),Zu(e),i=tl(i),t=tl(t),r=tl(r),n=tl(n),l.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");if(l.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");const h=Object.keys(l);if(h.length>0)throw Error("Unknown option: "+h.join(", "));try{const l=await e.decrypt(t,r,n,c,u);i||(i=[]);const h={};if(h.signatures=o?await l.verifyDetached(o,i,c,u):await l.verify(i,c,u),h.data="binary"===a?l.getLiteralData():l.getText(),h.filename=l.getFilename(),function(e,t,...r){e.data=Bn(t.packets.stream,async(t,n)=>{await _n(e.data,n,{preventClose:!0});const i=Hn(n);try{await Fn(t,e=>e),await Promise.all(r.map(e=>Fn(e.packets.stream,e=>e))),await i.close()}catch(e){await i.abort(e)}})}(h,e,...new Set([l,l.unwrapCompressed()])),s){if(0===i.length)throw Error("Verification keys are required to verify message signatures");if(0===h.signatures.length)throw Error("Message is not signed");h.data=xn([h.data,zn(async()=>(await Xn.anyPromise(h.signatures.map(e=>e.verified)),"binary"===a?new Uint8Array:""))])}return h.data=await rl(h.data),h}catch(e){throw Xn.wrapError("Error decrypting message",e)}}({message:e,passwords:[or(r)]});Ve(n,i,!0)}catch(e){Ve(n,":"+e)}},dl=mr('<form role="group"><textarea class="key" placeholder=""></textarea> <button type="button"></button></form> <button type="button"></button> <button type="button"> </button> <button type="button"></button>',1),fl=mr("<p>       </p>"),gl=(e,t)=>navigator.clipboard.writeText(or(t)),wl=(e,t,r)=>Ve(t,or(r),!0),ml=(e,t,r)=>Ve(t,or(t)+or(r)),bl=(e,t)=>navigator.clipboard.writeText(or(t)),vl=(e,t,r)=>Ve(t,or(r),!0),kl=mr('<main class="container"><nav><ul><li><h1><strong>WebCrypt</strong></h1></li></ul> <ul><li><a href="https://freecommunity.kro.kr">  </a></li> <li><a href="https://goroawase.kro.kr"> </a></li></ul></nav> <form role="group"><textarea class="source" placeholder="  ."></textarea> <button type="button"></button></form> <select aria-label=" "><option>Base64</option><option> </option><option>PGP -  </option></select> <!> <form role="group"><textarea class="result" name="read-only" readonly=""></textarea> <button type="button"></button></form> <button type="button">   </button> <button type="button">  </button> <form role="group"><textarea class="memory" placeholder=""></textarea> <button type="button"> </button></form> <button type="button">   </button><br/> <fieldset><label><input type="checkbox" role="switch"/> <span data-tooltip="       ">   </span></label></fieldset></main> <footer class="container"><p>    ,     .</p></footer>',1);!function(e){for(var t=0;t<e.length;t++)yr.add(e[t]);for(var r of pr)r(e)}(["click"]),"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("SW registered: ",e)}).catch(e=>{console.log("SW registration failed: ",e)})}),Er(function(e,t){se(t,!0),async function(){await yn()}();let r=We(""),n=We(""),i=We(""),s=We(""),a=We(!1),o=We(!1),c=We("base64");var u=kl(),l=dt(u),h=ft(pt(l),2),y=pt(h);wt(y),ft(y,2).__click=[nl,r],q(h);var p=ft(h,2),d=pt(p);d.value=d.__value="base64";var f=ft(d);f.value=f.__value="inv";var g=ft(f);g.value=g.__value="aes256",q(p);var w=ft(p,2),m=e=>{var t=al(),i=dt(t);i.__click=[il,n,r],ft(i,2).__click=[sl,n,r],vr(e,t)},b=e=>{var t=br(),i=dt(t),a=e=>{var t=ul(),i=dt(t);i.__click=[ol,n,o,r];var s=ft(i,2);s.__click=[cl,n,o,r];var a=ft(s,2),c=pt(a),u=pt(c);Lr(u),W(2),q(c),q(a),jr(u,()=>or(o),e=>Ve(o,e)),vr(e,t)},u=e=>{var t=br(),i=dt(t),a=e=>{var t=dl(),i=dt(t),a=pt(i);wt(a),ft(a,2).__click=[ll,s],q(i);var o=ft(i,2);o.__click=[hl,r,s,n];var c=ft(o,2);c.__click=[yl,r,s,n],ft(c,2).__click=[pl,r,s,n],zr(a,()=>or(s),e=>Ve(s,e)),vr(e,t)},o=e=>{vr(e,fl())};xr(i,e=>{"aes256"===or(c)?e(a):e(o,!1)},!0),vr(e,t)};xr(i,e=>{"inv"===or(c)?e(a):e(u,!1)},!0),vr(e,t)};xr(w,e=>{"base64"===or(c)?e(m):e(b,!1)});var v=ft(w,2),k=pt(v);wt(k),ft(k,2).__click=[gl,n],q(v);var A=ft(v,2);A.__click=[wl,r,n];var S=ft(A,2);S.__click=[ml,i,n];var E=ft(S,2),K=pt(E);wt(K),ft(K,2).__click=[bl,i],q(E);var P=ft(E,2);P.__click=[vl,r,i];var U=ft(P,3),D=pt(U),x=pt(D);Lr(x),W(2),q(D),q(U),q(l),W(2),Kt(e=>{var t,r,i;Nr(y,"aria-invalid",e),t=k,r=or(n),(i=Mr(t)).value!==(i.value=r??void 0)&&(t.value!==r||0===r&&"PROGRESS"===t.nodeName)&&(t.value=r??"")},[()=>or(a)&&function(e){const t=sn(e,Vr.__wbindgen_malloc,Vr.__wbindgen_realloc),r=tn;return 0!==Vr.inv_detect(t,r)}(or(r))?"false":null]),zr(y,()=>or(r),e=>Ve(r,e)),Ir(p,()=>or(c),e=>Ve(c,e)),zr(K,()=>or(i),e=>Ve(i,e)),jr(x,()=>or(a),e=>Ve(a,e)),vr(e,u),ae()},{target:document.body})})()})();